{"version":3,"sources":["webpack://spectraProcessor/webpack/universalModuleDefinition","webpack://spectraProcessor/webpack/bootstrap","webpack://spectraProcessor/./node_modules/is-any-array/src/index.js","webpack://spectraProcessor/./lib/index.js","webpack://spectraProcessor/./node_modules/ml-stat/array.js","webpack://spectraProcessor/./node_modules/jcampconverter/src/index.js","webpack://spectraProcessor/./node_modules/ml-array-sequential-fill/lib-es6/index.js","webpack://spectraProcessor/./node_modules/ml-array-xy-equally-spaced/src/integral.js","webpack://spectraProcessor/./node_modules/ml-array-xy-equally-spaced/src/index.js","webpack://spectraProcessor/./node_modules/ml-array-xy-equally-spaced/src/getZones.js","webpack://spectraProcessor/./node_modules/ml-array-xy-equally-spaced/src/equallySpacedSlot.js","webpack://spectraProcessor/./node_modules/ml-array-xy-equally-spaced/src/equallySpacedSmooth.js","webpack://spectraProcessor/./node_modules/ml-array-xy-filter-x/src/index.js","webpack://spectraProcessor/./node_modules/ml-array-xy-filter-x/src/getZones.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","toString","endsWith","_interopDefault","ex","default","filterX","require","equallySpaced","Stat","jcampconverter","Spectrum","constructor","x","y","id","_options$meta","arguments","length","undefined","meta","Error","reverse","normalized","getXY","getData","options","spectrum","filter","data","updateNormalized","_options$from","from","_options$to","to","_options$numberOfPoin","numberOfPoints","_options$processes","processes","_options$exclusions","exclusions","slice","process","kind","mean","meanFct","map","std","standardDeviation","stdFct","console","error","concat","result","getNormalized","fromJcamp","jcamp","IR_TRANSMITTANCE","normalization","importation","converter","transmittance","Math","log10","display","xLabel","xInverted","yLabel","IR_ABSORBANCE","parsed","convert","xy","datatype","spectra","dataType","toLowerCase","yUnit","xUnit","match","getJcampKind","SpectraProcessor","keepOriginalData","normalizationFilter","setNormalizationFilter","addFromJcamp","jcamp$1","contains","createAndAddSpectrum","index","getSpectrumIndex","removeSpectrum","splice","isNaN","getNormalizedData","matrix","ids","push","getChart","_options$filter","_options$mode","chart","includes","styles","unselected","lineColor","color","lineWidth","lineStyle","selected","label","log","compareNumbers","a","b","sum","values","max","min","minMax","arithmeticMean","geometricMean","mul","pow","logMean","lnsum","grandMean","means","samples","truncatedMean","percent","alreadySorted","sort","k","floor","harmonicMean","RangeError","contraHarmonicMean","r1","r2","median","half","variance","unbiased","theMean","theVariance","sqrt","standardError","robustMeanAndStdev","averageDeviations","Array","abs","stdev","quartiles","quart","q1","ceil","q2","q3","pooledStandardDeviation","pooledVariance","vari","itemCount","itemArray","count","indexOf","maxValue","maxIndex","covariance","vector1","vector2","mean1","mean2","cov","skewness","s2","s3","dev","m2","g","kurtosis","s4","v","entropy","eps","weightedMean","weights","weightedStandardDeviation","weightedVariance","z","w","center","inPlace","standardize","standardDev","cumulativeSum","array","getConverter","ntuplesSeparator","GC_MS_FIELDS","convertToFloatArray","stringArray","floatArray","parseFloat","defaultOptions","keepRecordsRegExp","withoutXY","chromatogram","keepSpectra","noContour","nbContourLevels","noiseMultiplier","profiling","convertMSFieldToLabel","replace","isMSField","dataLabel","prepareSpectrum","xFactor","yFactor","observeFrequency","toUpperCase","firstX","lastX","deltaX","shiftOffsetVal","shift","fastParseXYData","isXYdata","currentData","ascii","currentX","currentY","firstY","endLine","charCodeAt","newLine","isDifference","isLastDifference","lastDifference","isDuplicate","inComment","currentValue","lastValue","isNegative","inValue","skipFirstValue","decimalPosition","duplicate","j","ascii2","parseXYA","removeSymbolRegExp","isXYAdata","lines","split","trim","parsePeakTable","removeCommentRegExp","peakTableSplitRegExp","isPeaktable","logs","ldr","dataValue","ldrs","position","infos","wantXY","assign","start","Date","now","ntuples","info","TypeError","action","time","substring","xIndex","yIndex","firstVariable","secondVariable","symbol","first","last","lastY","vardim","nbPoints","factor","units","datatable","title","twoD","maxX","minX","maxY","minY","xType","indirectFrequency","shiftOffsetNum","varname","vartype","varform","yType","page","pageValue","pageSymbol","pageSymbolIndex","unit","sampleDescription","isArray","keys","newNtuples","zData","minZ","maxZ","ySize","xSize","xVector","noise","convertTo3DZ","contourLines","povarHeight0","povarHeight1","povarHeight2","povarHeight3","isOver0","isOver1","isOver2","isOver3","pAx","pAy","pBx","pBy","lineZValue","nbSubSpectra","nbPovars","x0","dx","y0","dy","iter","contourLevels","level","contourLevel","side","exp","zValue","iSubSpectra","subSpectra","subSpectraAfter","povar","segments","generateContourLines","add2D","newData","times","series","ms","dimension","existingGCMSFields","complexChromatogram","intensity","simpleChromatogram","worker","stamps","input","useWorker","workerURL","URL","createObjectURL","Blob","type","Worker","revokeObjectURL","addEventListener","event","JSON","parse","stamp","output","Promise","resolve","random","postMessage","stringify","postToWorker","createTree","_options$flatten","flatten","current","flat","stack","ntupleLevel","spaces","line","labelLine","startsWith","join","children","finished","pop","forEach","entry","_typeof","obj","iterator","sequentialFill","_options","_options$size","size","step","_i","integral","x1","slope","intercept","arrayXY","xLength","_options$variant","variant","zones","_ref","exclusion","_ref2","toRemove","reduce","previous","unitsPerPoint","currentFrom","totalPoints","currentNbPoints","round","getZones","xResult","yResult","zone","zoneResult","processZone","halfStep","lastStep","previousX","Number","MAX_VALUE","previousY","nextX","nextY","frontOutsideSpectra","backOutsideSpectra","currentPoints","main","equallySpacedSlot","initialOriginalStep","lastOriginalStep","MIN_VALUE","sumAtMin","sumAtMax","add","equallySpacedSmooth","__webpack_exports__","points","currentZoneIndex","newX","newY"],"mappings":"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","file":"spectra-processor.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"spectraProcessor\"] = factory();\n\telse\n\t\troot[\"spectraProcessor\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","'use strict';\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n","\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex.default : ex;\n}\n\nvar filterX = _interopDefault(require('ml-array-xy-filter-x'));\nvar equallySpaced = _interopDefault(require('ml-array-xy-equally-spaced'));\nvar Stat = _interopDefault(require('ml-stat/array'));\nvar jcampconverter = require('jcampconverter');\n\n/**\n *\n * @param {*} spectrum\n * @param {object} [options={}]\n *\n */\n\nfunction getData(spectrum, options = {}) {\n  const { filter } = options;\n\n  let data = { x: [], y: [] };\n\n  if (filter) {\n    data = filterX(data, filter);\n  }\n  return data;\n}\n\nfunction getNormalized(spectrum, options = {}) {\n  let {\n    from = spectrum.x[0],\n    to = spectrum.x[spectrum.x.length - 1],\n    numberOfPoints = 1024,\n    processes = [],\n    exclusions = []\n  } = options;\n\n  let y = spectrum.y.slice(0);\n  for (let process of processes) {\n    switch (process.kind) {\n      case 'centerMean': {\n        let mean = Stat.mean(spectrum.y);\n        let meanFct = (y) => y - mean;\n        y = y.map(meanFct);\n        break;\n      }\n      case 'scaleSD': {\n        let std = Stat.standardDeviation(spectrum.y);\n        let stdFct = (y) => y / std;\n        y = y.map(stdFct);\n        break;\n      }\n      default:\n        console.error(`Unknown process kind: ${process.kind}`);\n    }\n  }\n\n  let result = equallySpaced(\n    { x: spectrum.x, y },\n    { from, to, numberOfPoints, exclusions }\n  );\n  spectrum.normalized = result;\n\n  return result;\n}\n\n/**\n * Class allowing manipulate one IR spectrum\n * @class spectrum\n * @param {object} [json={}] - object containing a spectrum\n * @param {Array} [json.x=[]] - x values\n * @param {Array} [json.y=[]] - y values\n */\nclass Spectrum {\n  constructor(x, y, id, options = {}) {\n    const { meta = {} } = options;\n    if (!id) throw new Error('Spectrum: id is mandatory');\n\n    if (x && x.length > 1 && x[0] > x[1]) {\n      this.x = x.reverse();\n      this.y = y.reverse();\n    } else {\n      this.x = x || [];\n      this.y = y || [];\n    }\n    this.id = id;\n    this.meta = meta;\n    this.normalized = undefined;\n  }\n\n  getXY() {\n    return { x: this.x, y: this.y };\n  }\n}\n\nSpectrum.prototype.getData = function (options) {\n  return getData(this, options);\n};\n\nSpectrum.prototype.updateNormalized = function (options) {\n  this.normalized = getNormalized(this, options);\n  return this.normalized;\n};\n\nSpectrum.fromJcamp = function (jcamp, id, meta) {};\n\nfunction getJcampKind(data) {\n  let datatype = data.spectra[0].dataType.toLowerCase();\n  let xUnit = data.spectra[0].xUnit.toLowerCase();\n  let yUnit = data.spectra[0].yUnit.toLowerCase();\n\n  if (datatype.match(/infrared/)) {\n    if (yUnit.match(/absorbance/)) {\n      return IR_ABSORBANCE;\n    } else {\n      return IR_TRANSMITTANCE;\n    }\n  }\n  return undefined;\n}\n\nconst IR_TRANSMITTANCE = {\n  normalization: {},\n  importation: {\n    converter: (transmittance) => -Math.log10(transmittance)\n  },\n  kind: 'Infrared',\n  display: {\n    xLabel: 'wavelength [cm-1]',\n    xInverted: true,\n    yLabel: 'Absorbance'\n  }\n};\n\nconst IR_ABSORBANCE = {\n  normalization: {},\n  kind: 'Infrared',\n  display: {\n    xLabel: 'wavelength [cm-1]',\n    xInverted: true,\n    yLabel: 'Absorbance'\n  }\n};\n\n/**\n * Creates a new Chromatogram element based in a JCAMP string\n * @param {string} jcamp - String containing the JCAMP data\n * @return {Spectrum} - New class element with the given data\n */\nfunction jcamp(jcamp) {\n  const parsed = jcampconverter.convert(jcamp, { xy: true });\n  const kind = getJcampKind(parsed);\n  const data = parsed.spectra[0].data[0];\n  // we convert the data\n  if (kind && kind.importation && kind.importation.converter) {\n    data.y = data.y.map(kind.importation.converter);\n  }\n\n  return { data, kind };\n}\n\nclass SpectraProcessor {\n  constructor(options = {}) {\n    this.keepOriginalData =\n      options.keepOriginalData === undefined ? false : options.keepOriginalData;\n    this.normalizationFilter = undefined;\n    this.spectra = [];\n  }\n\n  setNormalizationFilter(normalizationFilter = {}) {\n    if (!this.keepOriginalData && this.spectra.length > 0) {\n      throw new Error(\n        'Can not change normalization filter, missing original data. Use the option keepOriginalData=true.'\n      );\n    }\n    this.normalizationFilter = normalizationFilter;\n    for (let spectrum of this.spectra) {\n      spectrum.updateNormalized(this.normalizationFilter);\n    }\n  }\n\n  /**\n   * Add jcamp\n   * @param {string} jcamp\n   * @param {string} id\n   * @param {boolean} [force=false]\n   * @param {object} [meta={}]\n   * @param {string} [meta.color]\n   */\n  addFromJcamp(jcamp$1, id, meta = {}, force = false) {\n    if (force === false && this.contains(id)) {\n      return;\n    }\n\n    let parsed = jcamp(jcamp$1);\n    this.createAndAddSpectrum(parsed, id, meta);\n  }\n\n  /**\n   * Add a spectrum\n   * @param {Spectrum} spectrum\n   */\n  createAndAddSpectrum(parsed, id, meta) {\n    let index = this.getSpectrumIndex(id);\n    if (index === undefined) index = this.spectra.length;\n    let spectrum = new Spectrum(parsed.data.x, parsed.data.y, id, {\n      meta\n    });\n    spectrum.updateNormalized(this.normalizationFilter);\n    this.spectra[index] = spectrum;\n  }\n\n  removeSpectrum(id) {\n    let index = this.getSpectrumIndex(id);\n    if (index === undefined) return undefined;\n    return this.data.splice(index, 1);\n  }\n\n  contains(id) {\n    return !isNaN(this.getSpectrumIndex(id));\n  }\n\n  getSpectrumIndex(id) {\n    if (!id) return undefined;\n    for (let i = 0; i < this.spectra.length; i++) {\n      let spectrum = this.spectra[i];\n      if (spectrum.id === id) return i;\n    }\n    return undefined;\n  }\n\n  getNormalizedData() {\n    if (!this.spectra || !this.spectra[0]) return {};\n    let matrix = [];\n    let meta = [];\n    let ids = [];\n    for (let spectrum of this.spectra) {\n      ids.push(spectrum.id);\n      matrix.push(spectrum.normalized.y);\n      meta.push(spectrum.meta);\n    }\n    let x = this.spectra[0].normalized.x;\n    return { ids, matrix, meta, x };\n  }\n\n  getChart(options = {}) {\n    const { ids, filter = {}, mode = this.mode } = options;\n    let chart = {\n      data: []\n    };\n    for (let spectrum of this.spectra) {\n      if (!ids || ids.includes(spectrum.id)) {\n        let data = spectrum.getData({ mode, filter });\n        data.styles = {\n          unselected: {\n            lineColor: spectrum.meta.color || 'darkgrey',\n            lineWidth: 1,\n            lineStyle: 1\n          },\n          selected: {\n            lineColor: spectrum.meta.color || 'darkgrey',\n            lineWidth: 3,\n            lineStyle: 1\n          }\n        };\n        data.label = spectrum.meta.id || spectrum.id;\n        chart.data.push(data);\n      }\n    }\n    return chart;\n  }\n}\n\nconsole.log('--------', { SpectraProcessor });\n\nexports.SpectraProcessor = SpectraProcessor;\n","'use strict';\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = values[0];\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\n/**\n * IEEE Transactions on biomedical engineering, vol. 52, no. 1, january 2005, p. 76-\n * Calculate the standard deviation via the Median of the absolute deviation\n *  The formula for the standard deviation only holds for Gaussian random variables.\n * @returns {{mean: number, stdev: number}}\n */\nexports.robustMeanAndStdev = function robustMeanAndStdev(y) {\n    var mean = 0, stdev = 0;\n    var length = y.length, i = 0;\n    for (i = 0; i < length; i++) {\n        mean += y[i];\n    }\n    mean /= length;\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort(compareNumbers);\n    if (length % 2 === 1) {\n        stdev = averageDeviations[(length - 1) / 2] / 0.6745;\n    } else {\n        stdev = 0.5 * (averageDeviations[length / 2] + averageDeviations[length / 2 - 1]) / 0.6745;\n    }\n\n    return {\n        mean: mean,\n        stdev: stdev\n    };\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof (alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw 'Vectors do not have the same dimensions';\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    } else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    } else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof (eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = [].concat(values);\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof (standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n","'use strict';\n\nfunction getConverter() {\n  // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n  const ntuplesSeparator = /[, \\t]+/;\n  const GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n  function convertToFloatArray(stringArray) {\n    var floatArray = [];\n    for (let i = 0; i < stringArray.length; i++) {\n      floatArray.push(parseFloat(stringArray[i]));\n    }\n    return floatArray;\n  }\n\n  class Spectrum {}\n\n  const defaultOptions = {\n    keepRecordsRegExp: /^$/,\n    xy: false,\n    withoutXY: false,\n    chromatogram: false,\n    keepSpectra: false,\n    noContour: false,\n    nbContourLevels: 7,\n    noiseMultiplier: 5,\n    profiling: false\n  };\n\n  function convert(jcamp, options) {\n    options = Object.assign({}, defaultOptions, options);\n\n    var wantXY = !options.withoutXY;\n\n    var start = Date.now();\n\n    var ntuples = {};\n    var ldr, dataLabel, dataValue, ldrs;\n    var position, endLine, infos;\n\n    var result = {};\n    result.profiling = options.profiling ? [] : false;\n    result.logs = [];\n    var spectra = [];\n    result.spectra = spectra;\n    result.info = {};\n    var spectrum = new Spectrum();\n\n    if (!(typeof jcamp === 'string')) {\n      throw new TypeError('the JCAMP should be a string');\n    }\n\n    if (result.profiling) {\n      result.profiling.push({\n        action: 'Before split to LDRS',\n        time: Date.now() - start\n      });\n    }\n\n    ldrs = jcamp.split(/[\\r\\n]+##/);\n\n    if (result.profiling) {\n      result.profiling.push({\n        action: 'Split to LDRS',\n        time: Date.now() - start\n      });\n    }\n\n    if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n    for (let i = 0; i < ldrs.length; i++) {\n      ldr = ldrs[i];\n      // This is a new LDR\n      position = ldr.indexOf('=');\n      if (position > 0) {\n        dataLabel = ldr.substring(0, position);\n        dataValue = ldr.substring(position + 1).trim();\n      } else {\n        dataLabel = ldr;\n        dataValue = '';\n      }\n      dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n      if (dataLabel === 'DATATABLE') {\n        endLine = dataValue.indexOf('\\n');\n        if (endLine === -1) endLine = dataValue.indexOf('\\r');\n        if (endLine > 0) {\n          var xIndex = -1;\n          var yIndex = -1;\n          // ##DATA TABLE= (X++(I..I)), XYDATA\n          // We need to find the variables\n\n          infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n          if (infos[0].indexOf('++') > 0) {\n            var firstVariable = infos[0].replace(\n              /.*\\(([a-zA-Z0-9]+)\\+\\+.*/,\n              '$1'\n            );\n            var secondVariable = infos[0].replace(\n              /.*\\.\\.([a-zA-Z0-9]+).*/,\n              '$1'\n            );\n            xIndex = ntuples.symbol.indexOf(firstVariable);\n            yIndex = ntuples.symbol.indexOf(secondVariable);\n          }\n\n          if (xIndex === -1) xIndex = 0;\n          if (yIndex === -1) yIndex = 0;\n\n          if (ntuples.first) {\n            if (ntuples.first.length > xIndex) {\n              spectrum.firstX = ntuples.first[xIndex];\n            }\n            if (ntuples.first.length > yIndex) {\n              spectrum.firstY = ntuples.first[yIndex];\n            }\n          }\n          if (ntuples.last) {\n            if (ntuples.last.length > xIndex) {\n              spectrum.lastX = ntuples.last[xIndex];\n            }\n            if (ntuples.last.length > yIndex) {\n              spectrum.lastY = ntuples.last[yIndex];\n            }\n          }\n          if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n            spectrum.nbPoints = ntuples.vardim[xIndex];\n          }\n          if (ntuples.factor) {\n            if (ntuples.factor.length > xIndex) {\n              spectrum.xFactor = ntuples.factor[xIndex];\n            }\n            if (ntuples.factor.length > yIndex) {\n              spectrum.yFactor = ntuples.factor[yIndex];\n            }\n          }\n          if (ntuples.units) {\n            if (ntuples.units.length > xIndex) {\n              spectrum.xUnit = ntuples.units[xIndex];\n            }\n            if (ntuples.units.length > yIndex) {\n              spectrum.yUnit = ntuples.units[yIndex];\n            }\n          }\n          spectrum.datatable = infos[0];\n          if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n            dataLabel = 'PEAKTABLE';\n          } else if (\n            infos[1] &&\n            (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)\n          ) {\n            dataLabel = 'XYDATA';\n            spectrum.deltaX =\n              (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n          }\n        }\n      }\n\n      if (dataLabel === 'XYDATA') {\n        if (wantXY) {\n          prepareSpectrum(result, spectrum);\n          // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n          if (dataValue.match(/.*\\+\\+.*/)) {\n            // ex: (X++(Y..Y))\n            if (!spectrum.deltaX) {\n              spectrum.deltaX =\n                (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n            }\n            fastParseXYData(spectrum, dataValue, result);\n          } else {\n            parsePeakTable(spectrum, dataValue, result);\n          }\n          spectra.push(spectrum);\n          spectrum = new Spectrum();\n        }\n        continue;\n      } else if (dataLabel === 'PEAKTABLE') {\n        if (wantXY) {\n          prepareSpectrum(result, spectrum);\n          parsePeakTable(spectrum, dataValue, result);\n          spectra.push(spectrum);\n          spectrum = new Spectrum();\n        }\n        continue;\n      }\n      if (dataLabel === 'PEAKASSIGNMENTS') {\n        if (wantXY) {\n          if (dataValue.match(/.*(XYA).*/)) {\n            // ex: (XYA)\n            parseXYA(spectrum, dataValue);\n          }\n          spectra.push(spectrum);\n          spectrum = new Spectrum();\n        }\n        continue;\n      }\n\n      if (dataLabel === 'TITLE') {\n        spectrum.title = dataValue;\n      } else if (dataLabel === 'DATATYPE') {\n        spectrum.dataType = dataValue;\n        if (dataValue.indexOf('nD') > -1) {\n          result.twoD = true;\n        }\n      } else if (dataLabel === 'NTUPLES') {\n        if (dataValue.indexOf('nD') > -1) {\n          result.twoD = true;\n        }\n      } else if (dataLabel === 'XUNITS') {\n        spectrum.xUnit = dataValue;\n      } else if (dataLabel === 'YUNITS') {\n        spectrum.yUnit = dataValue;\n      } else if (dataLabel === 'FIRSTX') {\n        spectrum.firstX = parseFloat(dataValue);\n      } else if (dataLabel === 'LASTX') {\n        spectrum.lastX = parseFloat(dataValue);\n      } else if (dataLabel === 'FIRSTY') {\n        spectrum.firstY = parseFloat(dataValue);\n      } else if (dataLabel === 'LASTY') {\n        spectrum.lastY = parseFloat(dataValue);\n      } else if (dataLabel === 'NPOINTS') {\n        spectrum.nbPoints = parseFloat(dataValue);\n      } else if (dataLabel === 'XFACTOR') {\n        spectrum.xFactor = parseFloat(dataValue);\n      } else if (dataLabel === 'YFACTOR') {\n        spectrum.yFactor = parseFloat(dataValue);\n      } else if (dataLabel === 'MAXX') {\n        spectrum.maxX = parseFloat(dataValue);\n      } else if (dataLabel === 'MINX') {\n        spectrum.minX = parseFloat(dataValue);\n      } else if (dataLabel === 'MAXY') {\n        spectrum.maxY = parseFloat(dataValue);\n      } else if (dataLabel === 'MINY') {\n        spectrum.minY = parseFloat(dataValue);\n      } else if (dataLabel === 'DELTAX') {\n        spectrum.deltaX = parseFloat(dataValue);\n      } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n        if (!spectrum.observeFrequency) {\n          spectrum.observeFrequency = parseFloat(dataValue);\n        }\n      } else if (dataLabel === '.OBSERVENUCLEUS') {\n        if (!spectrum.xType) {\n          result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n        }\n      } else if (dataLabel === '$SFO2') {\n        if (!result.indirectFrequency) {\n          result.indirectFrequency = parseFloat(dataValue);\n        }\n      } else if (dataLabel === '$OFFSET') {\n        // OFFSET for Bruker spectra\n        result.shiftOffsetNum = 0;\n        if (!spectrum.shiftOffsetVal) {\n          spectrum.shiftOffsetVal = parseFloat(dataValue);\n        }\n      } else if (dataLabel === '$REFERENCEPOINT') {\n        // OFFSET for Varian spectra\n        // if we activate this part it does not work for ACD specmanager\n        //         } else if (dataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n        //                 var parts = dataValue.split(/ *, */);\n        //                 result.shiftOffsetNum = parseInt(parts[2].trim());\n        //                 spectrum.shiftOffsetVal = parseFloat(parts[3].trim());\n      } else if (dataLabel === 'VARNAME') {\n        ntuples.varname = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'SYMBOL') {\n        ntuples.symbol = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'VARTYPE') {\n        ntuples.vartype = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'VARFORM') {\n        ntuples.varform = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'VARDIM') {\n        ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'UNITS') {\n        ntuples.units = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'FACTOR') {\n        ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'FIRST') {\n        ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'LAST') {\n        ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'MIN') {\n        ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'MAX') {\n        ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === '.NUCLEUS') {\n        if (result.twoD) {\n          result.yType = dataValue.split(ntuplesSeparator)[0];\n        }\n      } else if (dataLabel === 'PAGE') {\n        spectrum.page = dataValue.trim();\n        spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n        spectrum.pageSymbol = spectrum.page.replace(/[=].*/, '');\n        var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n        var unit = '';\n        if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n          unit = ntuples.units[pageSymbolIndex];\n        }\n        if (result.indirectFrequency && unit !== 'PPM') {\n          spectrum.pageValue /= result.indirectFrequency;\n        }\n      } else if (dataLabel === 'RETENTIONTIME') {\n        spectrum.pageValue = parseFloat(dataValue);\n      } else if (isMSField(dataLabel)) {\n        spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n      } else if (dataLabel === 'SAMPLEDESCRIPTION') {\n        spectrum.sampleDescription = dataValue;\n      }\n      if (dataLabel.match(options.keepRecordsRegExp)) {\n        if (result.info[dataLabel]) {\n          if (!Array.isArray(result.info[dataLabel])) {\n            result.info[dataLabel] = [result.info[dataLabel]];\n          }\n          result.info[dataLabel].push(dataValue.trim());\n        } else {\n          result.info[dataLabel] = dataValue.trim();\n        }\n      }\n    }\n\n    if (result.profiling) {\n      result.profiling.push({\n        action: 'Finished parsing',\n        time: Date.now() - start\n      });\n    }\n\n    if (Object.keys(ntuples).length > 0) {\n      var newNtuples = [];\n      var keys = Object.keys(ntuples);\n      for (let i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var values = ntuples[key];\n        for (let j = 0; j < values.length; j++) {\n          if (!newNtuples[j]) newNtuples[j] = {};\n          newNtuples[j][key] = values[j];\n        }\n      }\n      result.ntuples = newNtuples;\n    }\n\n    if (result.twoD && wantXY) {\n      add2D(result, options);\n      if (result.profiling) {\n        result.profiling.push({\n          action: 'Finished countour plot calculation',\n          time: Date.now() - start\n        });\n      }\n      if (!options.keepSpectra) {\n        delete result.spectra;\n      }\n    }\n\n    if (options.chromatogram) {\n      options.xy = true;\n    }\n\n    if (options.xy && wantXY) {\n      // the spectraData should not be a oneD array but an object with x and y\n      if (spectra.length > 0) {\n        for (let i = 0; i < spectra.length; i++) {\n          spectrum = spectra[i];\n          if (spectrum.data.length > 0) {\n            for (let j = 0; j < spectrum.data.length; j++) {\n              var data = spectrum.data[j];\n              var newData = {\n                x: new Array(data.length / 2),\n                y: new Array(data.length / 2)\n              };\n              for (var k = 0; k < data.length; k = k + 2) {\n                newData.x[k / 2] = data[k];\n                newData.y[k / 2] = data[k + 1];\n              }\n              spectrum.data[j] = newData;\n            }\n          }\n        }\n      }\n    }\n\n    // maybe it is a GC (HPLC) / MS. In this case we add a new format\n    if (options.chromatogram) {\n      if (result.spectra.length > 1) {\n        complexChromatogram(result);\n      } else {\n        simpleChromatogram(result);\n      }\n      if (result.profiling) {\n        result.profiling.push({\n          action: 'Finished chromatogram calculation',\n          time: Date.now() - start\n        });\n      }\n    }\n\n    if (result.profiling) {\n      result.profiling.push({\n        action: 'Total time',\n        time: Date.now() - start\n      });\n    }\n\n    return result;\n  }\n\n  function convertMSFieldToLabel(value) {\n    return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n  }\n\n  function isMSField(dataLabel) {\n    return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n  }\n\n  function complexChromatogram(result) {\n    var spectra = result.spectra;\n    var length = spectra.length;\n    var chromatogram = {\n      times: new Array(length),\n      series: {\n        ms: {\n          dimension: 2,\n          data: new Array(length)\n        }\n      }\n    };\n\n    var existingGCMSFields = [];\n    for (let i = 0; i < GC_MS_FIELDS.length; i++) {\n      var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n      if (spectra[0][label]) {\n        existingGCMSFields.push(label);\n        chromatogram.series[label] = {\n          dimension: 1,\n          data: new Array(length)\n        };\n      }\n    }\n\n    for (let i = 0; i < length; i++) {\n      var spectrum = spectra[i];\n      chromatogram.times[i] = spectrum.pageValue;\n      for (let j = 0; j < existingGCMSFields.length; j++) {\n        chromatogram.series[existingGCMSFields[j]].data[i] = parseFloat(\n          spectrum[existingGCMSFields[j]]\n        );\n      }\n      if (spectrum.data) {\n        chromatogram.series.ms.data[i] = [\n          spectrum.data[0].x,\n          spectrum.data[0].y\n        ];\n      }\n    }\n    result.chromatogram = chromatogram;\n  }\n\n  function simpleChromatogram(result) {\n    var data = result.spectra[0].data[0];\n    result.chromatogram = {\n      times: data.x.slice(),\n      series: {\n        intensity: {\n          dimension: 1,\n          data: data.y.slice()\n        }\n      }\n    };\n  }\n\n  function prepareSpectrum(result, spectrum) {\n    if (!spectrum.xFactor) spectrum.xFactor = 1;\n    if (!spectrum.yFactor) spectrum.yFactor = 1;\n    if (spectrum.observeFrequency) {\n      if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n        spectrum.xUnit = 'PPM';\n        spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n        spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n        spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n        spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n      }\n    }\n    if (spectrum.shiftOffsetVal) {\n      var shift = spectrum.firstX - spectrum.shiftOffsetVal;\n      spectrum.firstX = spectrum.firstX - shift;\n      spectrum.lastX = spectrum.lastX - shift;\n    }\n  }\n\n  function getMedian(data) {\n    data = data.sort(compareNumbers);\n    var l = data.length;\n    return data[Math.floor(l / 2)];\n  }\n\n  function compareNumbers(a, b) {\n    return a - b;\n  }\n\n  function convertTo3DZ(spectra) {\n    var minZ = spectra[0].data[0][0];\n    var maxZ = minZ;\n    var ySize = spectra.length;\n    var xSize = spectra[0].data[0].length / 2;\n    var z = new Array(ySize);\n    for (let i = 0; i < ySize; i++) {\n      z[i] = new Array(xSize);\n      var xVector = spectra[i].data[0];\n      for (let j = 0; j < xSize; j++) {\n        var value = xVector[j * 2 + 1];\n        z[i][j] = value;\n        if (value < minZ) minZ = value;\n        if (value > maxZ) maxZ = value;\n      }\n    }\n\n    const firstX = spectra[0].data[0][0];\n    const lastX = spectra[0].data[0][spectra[0].data[0].length - 2]; // has to be -2 because it is a 1D array [x,y,x,y,...]\n    const firstY = spectra[0].pageValue;\n    const lastY = spectra[ySize - 1].pageValue;\n\n    // Because the min / max value are the only information about the matrix if we invert\n    // min and max we need to invert the array\n    if (firstX > lastX) {\n      for (let spectrum of z) {\n        spectrum.reverse();\n      }\n    }\n    if (firstY > lastY) {\n      z.reverse();\n    }\n\n    return {\n      z: z,\n      minX: Math.min(firstX, lastX),\n      maxX: Math.max(firstX, lastX),\n      minY: Math.min(firstY, lastY),\n      maxY: Math.max(firstY, lastY),\n      minZ: minZ,\n      maxZ: maxZ,\n      noise: getMedian(z[0].map(Math.abs))\n    };\n  }\n\n  function add2D(result, options) {\n    var zData = convertTo3DZ(result.spectra);\n    if (!options.noContour) {\n      result.contourLines = generateContourLines(zData, options);\n      delete zData.z;\n    }\n    result.minMax = zData;\n  }\n\n  function generateContourLines(zData, options) {\n    var noise = zData.noise;\n    var z = zData.z;\n    var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n    var isOver0, isOver1, isOver2, isOver3;\n    var nbSubSpectra = z.length;\n    var nbPovars = z[0].length;\n    var pAx, pAy, pBx, pBy;\n\n    var x0 = zData.minX;\n    var xN = zData.maxX;\n    var dx = (xN - x0) / (nbPovars - 1);\n    var y0 = zData.minY;\n    var yN = zData.maxY;\n    var dy = (yN - y0) / (nbSubSpectra - 1);\n    var minZ = zData.minZ;\n    var maxZ = zData.maxZ;\n\n    // System.out.prvarln('y0 '+y0+' yN '+yN);\n    // -------------------------\n    // Povars attribution\n    //\n    // 0----1\n    // |  / |\n    // | /  |\n    // 2----3\n    //\n    // ---------------------d------\n\n    var iter = options.nbContourLevels * 2;\n    var contourLevels = new Array(iter);\n    var lineZValue;\n    for (var level = 0; level < iter; level++) {\n      // multiply by 2 for positif and negatif\n      var contourLevel = {};\n      contourLevels[level] = contourLevel;\n      var side = level % 2;\n      var factor =\n        (maxZ - options.noiseMultiplier * noise) *\n        Math.exp((level >> 1) - options.nbContourLevels);\n      if (side === 0) {\n        lineZValue = factor + options.noiseMultiplier * noise;\n      } else {\n        lineZValue = 0 - factor - options.noiseMultiplier * noise;\n      }\n      var lines = [];\n      contourLevel.zValue = lineZValue;\n      contourLevel.lines = lines;\n\n      if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n      for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n        var subSpectra = z[iSubSpectra];\n        var subSpectraAfter = z[iSubSpectra + 1];\n        for (var povar = 0; povar < nbPovars - 1; povar++) {\n          povarHeight0 = subSpectra[povar];\n          povarHeight1 = subSpectra[povar + 1];\n          povarHeight2 = subSpectraAfter[povar];\n          povarHeight3 = subSpectraAfter[povar + 1];\n\n          isOver0 = povarHeight0 > lineZValue;\n          isOver1 = povarHeight1 > lineZValue;\n          isOver2 = povarHeight2 > lineZValue;\n          isOver3 = povarHeight3 > lineZValue;\n\n          // Example povar0 is over the plane and povar1 and\n          // povar2 are below, we find the varersections and add\n          // the segment\n          if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n            pAx =\n              povar +\n              (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n            pAy = iSubSpectra;\n            pBx = povar;\n            pBy =\n              iSubSpectra +\n              (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n            lines.push(pAx * dx + x0);\n            lines.push(pAy * dy + y0);\n            lines.push(pBx * dx + x0);\n            lines.push(pBy * dy + y0);\n          }\n          // remove push does not help !!!!\n          if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n            pAx = povar + 1;\n            pAy =\n              iSubSpectra +\n              1 -\n              (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n            pBx =\n              povar +\n              1 -\n              (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n            pBy = iSubSpectra + 1;\n            lines.push(pAx * dx + x0);\n            lines.push(pAy * dy + y0);\n            lines.push(pBx * dx + x0);\n            lines.push(pBy * dy + y0);\n          }\n          // test around the diagonal\n          if (isOver1 !== isOver2) {\n            pAx =\n              (povar +\n                1 -\n                (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) *\n                dx +\n              x0;\n            pAy =\n              (iSubSpectra +\n                (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) *\n                dy +\n              y0;\n            if (isOver1 !== isOver0) {\n              pBx =\n                povar +\n                1 -\n                (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n              pBy = iSubSpectra;\n              lines.push(pAx);\n              lines.push(pAy);\n              lines.push(pBx * dx + x0);\n              lines.push(pBy * dy + y0);\n            }\n            if (isOver2 !== isOver0) {\n              pBx = povar;\n              pBy =\n                iSubSpectra +\n                1 -\n                (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n              lines.push(pAx);\n              lines.push(pAy);\n              lines.push(pBx * dx + x0);\n              lines.push(pBy * dy + y0);\n            }\n            if (isOver1 !== isOver3) {\n              pBx = povar + 1;\n              pBy =\n                iSubSpectra +\n                (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n              lines.push(pAx);\n              lines.push(pAy);\n              lines.push(pBx * dx + x0);\n              lines.push(pBy * dy + y0);\n            }\n            if (isOver2 !== isOver3) {\n              pBx =\n                povar +\n                (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n              pBy = iSubSpectra + 1;\n              lines.push(pAx);\n              lines.push(pAy);\n              lines.push(pBx * dx + x0);\n              lines.push(pBy * dy + y0);\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      minX: zData.minX,\n      maxX: zData.maxX,\n      minY: zData.minY,\n      maxY: zData.maxY,\n      segments: contourLevels\n    };\n  }\n\n  function fastParseXYData(spectrum, value) {\n    // TODO need to deal with result\n    //  console.log(value);\n    // we check if deltaX is defined otherwise we calculate it\n\n    var yFactor = spectrum.yFactor;\n    var deltaX = spectrum.deltaX;\n\n    spectrum.isXYdata = true;\n    // TODO to be improved using 2 array {x:[], y:[]}\n    var currentData = [];\n    spectrum.data = [currentData];\n\n    var currentX = spectrum.firstX;\n    var currentY = spectrum.firstY;\n\n    // we skip the first line\n    //\n    var endLine = false;\n    var ascii;\n    let i = 0;\n    for (; i < value.length; i++) {\n      ascii = value.charCodeAt(i);\n      if (ascii === 13 || ascii === 10) {\n        endLine = true;\n      } else {\n        if (endLine) break;\n      }\n    }\n\n    // we proceed taking the i after the first line\n    var newLine = true;\n    var isDifference = false;\n    var isLastDifference = false;\n    var lastDifference = 0;\n    var isDuplicate = false;\n    var inComment = false;\n    var currentValue = 0; // can be a difference or a duplicate\n    var lastValue = 0; // must be the real last value\n    var isNegative = false;\n    var inValue = false;\n    var skipFirstValue = false;\n    var decimalPosition = 0;\n    for (; i <= value.length; i++) {\n      if (i === value.length) ascii = 13;\n      else ascii = value.charCodeAt(i);\n      if (inComment) {\n        // we should ignore the text if we are after $$\n        if (ascii === 13 || ascii === 10) {\n          newLine = true;\n          inComment = false;\n        }\n      } else {\n        // when is it a new value ?\n        // when it is not a digit, . or comma\n        // it is a number that is either new or we continue\n        if (ascii <= 57 && ascii >= 48) {\n          // a number\n          inValue = true;\n          if (decimalPosition > 0) {\n            currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n          } else {\n            currentValue *= 10;\n            currentValue += ascii - 48;\n          }\n        } else if (ascii === 44 || ascii === 46) {\n          // a \",\" or \".\"\n          inValue = true;\n          decimalPosition++;\n        } else {\n          if (inValue) {\n            // need to process the previous value\n            if (newLine) {\n              newLine = false; // we don't check the X value\n              // console.log(\"NEW LINE\",isDifference, lastDifference);\n              // if new line and lastDifference, the first value is just a check !\n              // that we don't check ...\n              if (isLastDifference) skipFirstValue = true;\n            } else {\n              // need to deal with duplicate and differences\n              if (skipFirstValue) {\n                skipFirstValue = false;\n              } else {\n                if (isDifference) {\n                  lastDifference = isNegative ? 0 - currentValue : currentValue;\n                  isLastDifference = true;\n                  isDifference = false;\n                } else if (!isDuplicate) {\n                  lastValue = isNegative ? 0 - currentValue : currentValue;\n                }\n                var duplicate = isDuplicate ? currentValue - 1 : 1;\n                for (var j = 0; j < duplicate; j++) {\n                  if (isLastDifference) {\n                    currentY += lastDifference;\n                  } else {\n                    currentY = lastValue;\n                  }\n                  currentData.push(currentX);\n                  currentData.push(currentY * yFactor);\n                  currentX += deltaX;\n                }\n              }\n            }\n            isNegative = false;\n            currentValue = 0;\n            decimalPosition = 0;\n            inValue = false;\n            isDuplicate = false;\n          }\n\n          // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n          if (ascii < 74 && ascii > 63) {\n            inValue = true;\n            isLastDifference = false;\n            currentValue = ascii - 64;\n          } else if (ascii > 96 && ascii < 106) {\n            // negative SQZ digits a b c d e f g h i (ascii 97-105)\n            inValue = true;\n            isLastDifference = false;\n            currentValue = ascii - 96;\n            isNegative = true;\n          } else if (ascii === 115) {\n            // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n            inValue = true;\n            isDuplicate = true;\n            currentValue = 9;\n          } else if (ascii > 82 && ascii < 91) {\n            inValue = true;\n            isDuplicate = true;\n            currentValue = ascii - 82;\n          } else if (ascii > 73 && ascii < 83) {\n            // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n            inValue = true;\n            isDifference = true;\n            currentValue = ascii - 73;\n          } else if (ascii > 105 && ascii < 115) {\n            // negative DIF digits j k l m n o p q r (ascii 106-114)\n            inValue = true;\n            isDifference = true;\n            currentValue = ascii - 105;\n            isNegative = true;\n          } else if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n            // $ sign, we need to check the next one\n            inValue = true;\n            inComment = true;\n          } else if (ascii === 37) {\n            // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n            inValue = true;\n            isDifference = true;\n            currentValue = 0;\n            isNegative = false;\n          } else if (ascii === 45) {\n            // a \"-\"\n            // check if after there is a number, decimal or comma\n            var ascii2 = value.charCodeAt(i + 1);\n            if (\n              (ascii2 >= 48 && ascii2 <= 57) ||\n              ascii2 === 44 ||\n              ascii2 === 46\n            ) {\n              inValue = true;\n              if (!newLine) isLastDifference = false;\n              isNegative = true;\n            }\n          } else if (ascii === 13 || ascii === 10) {\n            newLine = true;\n            inComment = false;\n          }\n          // and now analyse the details ... space or tabulation\n          // if \"+\" we just don't care\n        }\n      }\n    }\n  }\n\n  function parseXYA(spectrum, value) {\n    var removeSymbolRegExp = /(\\(+|\\)+|<+|>+|\\s+)/g;\n\n    spectrum.isXYAdata = true;\n    var values;\n    var currentData = [];\n    spectrum.data = [currentData];\n\n    var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n    for (let i = 1; i < lines.length; i++) {\n      values = lines[i]\n        .trim()\n        .replace(removeSymbolRegExp, '')\n        .split(',');\n      currentData.push(parseFloat(values[0]));\n      currentData.push(parseFloat(values[1]));\n    }\n  }\n\n  function parsePeakTable(spectrum, value, result) {\n    var removeCommentRegExp = /\\$\\$.*/;\n    var peakTableSplitRegExp = /[,\\t ]+/;\n\n    spectrum.isPeaktable = true;\n    var values;\n    var currentData = [];\n    spectrum.data = [currentData];\n\n    // counts for around 20% of the time\n    var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n    for (let i = 1; i < lines.length; i++) {\n      values = lines[i]\n        .trim()\n        .replace(removeCommentRegExp, '')\n        .split(peakTableSplitRegExp);\n      if (values.length % 2 === 0) {\n        for (let j = 0; j < values.length; j = j + 2) {\n          // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n          currentData.push(parseFloat(values[j]) * spectrum.xFactor);\n          currentData.push(parseFloat(values[j + 1]) * spectrum.yFactor);\n        }\n      } else {\n        result.logs.push(`Format error: ${values}`);\n      }\n    }\n  }\n\n  return convert;\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n  if (typeof options === 'boolean') {\n    useWorker = options;\n    options = {};\n  }\n  if (useWorker) {\n    return postToWorker(input, options);\n  } else {\n    return convert(input, options);\n  }\n}\n\nvar stamps = {};\nvar worker;\n\nfunction postToWorker(input, options) {\n  if (!worker) {\n    createWorker();\n  }\n  return new Promise(function (resolve) {\n    var stamp = `${Date.now()}${Math.random()}`;\n    stamps[stamp] = resolve;\n    worker.postMessage(\n      JSON.stringify({\n        stamp: stamp,\n        input: input,\n        options: options\n      })\n    );\n  });\n}\n\nfunction createWorker() {\n  var workerURL = URL.createObjectURL(\n    new Blob(\n      [`var getConverter =${getConverter.toString()};var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };`],\n      { type: 'application/javascript' }\n    )\n  );\n  worker = new Worker(workerURL);\n  URL.revokeObjectURL(workerURL);\n  worker.addEventListener('message', function (event) {\n    var data = JSON.parse(event.data);\n    var stamp = data.stamp;\n    if (stamps[stamp]) {\n      stamps[stamp](data.output);\n    }\n  });\n}\n\nfunction createTree(jcamp, options = {}) {\n  const { flatten = false } = options;\n  if (typeof jcamp !== 'string') {\n    throw new TypeError('the JCAMP should be a string');\n  }\n\n  let lines = jcamp.split(/[\\r\\n]+/);\n  let flat = [];\n  let stack = [];\n  let result = [];\n  let current;\n  let ntupleLevel = 0;\n\n  let spaces = jcamp.includes('## ');\n\n  for (var i = 0; i < lines.length; i++) {\n    let line = lines[i];\n    let labelLine = spaces ? line.replace(/ /g, '') : line;\n\n    if (labelLine.substring(0, 9) === '##NTUPLES') {\n      ntupleLevel++;\n    }\n\n    if (labelLine.substring(0, 7) === '##TITLE') {\n      let title = [labelLine.substring(8).trim()];\n      for (let j = i + 1; j < lines.length; j++) {\n        if (lines[j].startsWith('##')) {\n          break;\n        } else {\n          title.push(lines[j].trim());\n        }\n      }\n      stack.push({\n        title: title.join('\\n'),\n        jcamp: `${line}\\n`,\n        children: []\n      });\n      current = stack[stack.length - 1];\n      flat.push(current);\n    } else if (labelLine.substring(0, 5) === '##END' && ntupleLevel === 0) {\n      current.jcamp += `${line}\\n`;\n      var finished = stack.pop();\n      if (stack.length !== 0) {\n        current = stack[stack.length - 1];\n        current.children.push(finished);\n      } else {\n        current = undefined;\n        result.push(finished);\n      }\n    } else if (current && current.jcamp) {\n      current.jcamp += `${line}\\n`;\n      var match = labelLine.match(/^##(.*?)=(.+)/);\n      if (match) {\n        var dataLabel = match[1].replace(/[ _-]/g, '').toUpperCase();\n        if (dataLabel === 'DATATYPE') {\n          current.dataType = match[2].trim();\n        }\n      }\n    }\n\n    if (labelLine.substring(0, 5) === '##END' && ntupleLevel > 0) {\n      ntupleLevel--;\n    }\n  }\n  if (flatten) {\n    flat.forEach((entry) => {\n      entry.children = undefined;\n    });\n    return flat;\n  } else {\n    return result;\n  }\n}\n\nmodule.exports = {\n  convert: JcampConverter,\n  createTree: createTree\n};\n","import isArray from 'is-any-array';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n/**\n * Fill an array with sequential numbers\n * @param {Array<number>} [input] - optional destination array (if not provided a new array will be created)\n * @param {object} [options={}]\n * @param {number} [options.from=0] - first value in the array\n * @param {number} [options.to=10] - last value in the array\n * @param {number} [options.size=input.length] - size of the array (if not provided calculated from step)\n * @param {number} [options.step] - if not provided calculated from size\n * @return {Array<number>}\n */\n\nfunction sequentialFill() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (_typeof(input) === 'object' && !isArray(input)) {\n    options = input;\n    input = [];\n  }\n\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  var _options = options,\n      _options$from = _options.from,\n      from = _options$from === void 0 ? 0 : _options$from,\n      _options$to = _options.to,\n      to = _options$to === void 0 ? 10 : _options$to,\n      _options$size = _options.size,\n      size = _options$size === void 0 ? input.length : _options$size,\n      step = _options.step;\n\n  if (size && step) {\n    throw new Error('step is defined by the array size');\n  }\n\n  if (!size) {\n    if (step) {\n      size = Math.floor((to - from) / step) + 1;\n    } else {\n      size = to - from + 1;\n    }\n  }\n\n  if (!step && size) {\n    step = (to - from) / (size - 1);\n  }\n\n  if (Array.isArray(input)) {\n    input.length = 0; // only works with normal array\n\n    for (var i = 0; i < size; i++) {\n      input.push(from);\n      from += step;\n    }\n  } else {\n    if (input.length !== size) {\n      throw new Error('sequentialFill typed array must have the correct length');\n    }\n\n    for (var _i = 0; _i < size; _i++) {\n      input[_i] = from;\n      from += step;\n    }\n  }\n\n  return input;\n}\n\nexport default sequentialFill;\n","/**\n * Function that calculates the integral of the line between two\n * x-coordinates, given the slope and intercept of the line.\n * @param {number} x0\n * @param {number} x1\n * @param {number} slope\n * @param {number} intercept\n * @return {number} integral value.\n */\nexport default function integral(x0, x1, slope, intercept) {\n  return (\n    0.5 * slope * x1 * x1 +\n    intercept * x1 -\n    (0.5 * slope * x0 * x0 + intercept * x0)\n  );\n}\n","import sequentialFill from 'ml-array-sequential-fill';\n\nimport equallySpacedSmooth from './equallySpacedSmooth';\nimport equallySpacedSlot from './equallySpacedSlot';\nimport getZones from './getZones';\n\n/**\n * Function that returns a Number array of equally spaced numberOfPoints\n * containing a representation of intensities of the spectra arguments x\n * and y.\n *\n * The options parameter contains an object in the following form:\n * from: starting point\n * to: last point\n * numberOfPoints: number of points between from and to\n * variant: \"slot\" or \"smooth\" - smooth is the default option\n *\n * The slot variant consist that each point in the new array is calculated\n * averaging the existing points between the slot that belongs to the current\n * value. The smooth variant is the same but takes the integral of the range\n * of the slot and divide by the step size between two points in the new array.\n *\n * @param {object} [arrayXY={}] - object containing 2 properties x and y (both an array)\n * @param {object} [options={}]\n * @param {number} [options.from=x[0]]\n * @param {number} [options.to=x[x.length-1]]\n * @param {string} [options.variant='smooth']\n * @param {number} [options.numberOfPoints=100]\n * @param {Array} [options.exclusions=[]] array of from / to that should be skipped for the generation of the points\n * @return {object<x: Array, y:Array>} new object with x / y array with the equally spaced data.\n */\n\nexport default function equallySpaced(arrayXY = {}, options = {}) {\n  let { x, y } = arrayXY;\n  let xLength = x.length;\n  let reverse = false;\n  if (x.length > 1 && x[0] > x[1]) {\n    x = x.slice().reverse();\n    y = y.slice().reverse();\n    reverse = true;\n  }\n\n  let {\n    from = x[0],\n    to = x[xLength - 1],\n    variant = 'smooth',\n    numberOfPoints = 100,\n    exclusions = []\n  } = options;\n\n  if (xLength !== y.length) {\n    throw new RangeError(\"the x and y vector doesn't have the same size.\");\n  }\n\n  if (typeof from !== 'number' || isNaN(from)) {\n    throw new RangeError(\"'from' option must be a number\");\n  }\n\n  if (typeof to !== 'number' || isNaN(to)) {\n    throw new RangeError(\"'to' option must be a number\");\n  }\n\n  if (typeof numberOfPoints !== 'number' || isNaN(numberOfPoints)) {\n    throw new RangeError(\"'numberOfPoints' option must be a number\");\n  }\n\n  let zones = getZones(from, to, numberOfPoints, exclusions);\n\n  let xResult = [];\n  let yResult = [];\n  for (let zone of zones) {\n    let zoneResult = processZone(\n      x,\n      y,\n      zone.from,\n      zone.to,\n      zone.numberOfPoints,\n      variant,\n      reverse\n    );\n    xResult.push(...zoneResult.x);\n    yResult.push(...zoneResult.y);\n  }\n\n  if (reverse) {\n    if (from < to) {\n      return { x: xResult.reverse(), y: yResult.reverse() };\n    } else {\n      return { x: xResult, y: yResult };\n    }\n  } else {\n    if (from < to) {\n      return { x: xResult, y: yResult };\n    } else {\n      return { x: xResult.reverse(), y: yResult.reverse() };\n    }\n  }\n}\n\nfunction processZone(x, y, from, to, numberOfPoints, variant) {\n  if (numberOfPoints < 1) {\n    throw new RangeError('the number of points must be at least 1');\n  }\n\n  var output =\n    variant === 'slot'\n      ? equallySpacedSlot(x, y, from, to, numberOfPoints)\n      : equallySpacedSmooth(x, y, from, to, numberOfPoints);\n\n  return {\n    x: sequentialFill({\n      from,\n      to,\n      size: numberOfPoints\n    }),\n    y: output\n  };\n}\n","export default function getZones(from, to, numberOfPoints, exclusions = []) {\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n\n  // in exclusions from and to have to be defined\n  exclusions = exclusions.filter(\n    (exclusion) => exclusion.from !== undefined && exclusion.to !== undefined\n  );\n\n  exclusions = JSON.parse(JSON.stringify(exclusions));\n  // we ensure that from before to\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from > exclusion.to) {\n      [exclusion.to, exclusion.from] = [exclusion.from, exclusion.to];\n    }\n  });\n\n  exclusions.sort((a, b) => a.from - b.from);\n\n  // we will rework the exclusions in order to remove overlap and outside range (from / to)\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from < from) exclusion.from = from;\n    if (exclusion.to > to) exclusion.to = to;\n  });\n  for (let i = 0; i < exclusions.length - 1; i++) {\n    if (exclusions[i].to > exclusions[i + 1].from) {\n      exclusions[i].to = exclusions[i + 1].from;\n    }\n  }\n  exclusions = exclusions.filter((exclusion) => exclusion.from < exclusion.to);\n\n  if (!exclusions || exclusions.length === 0) {\n    return [{ from, to, numberOfPoints }];\n  }\n\n  // need to deal with overlapping exclusions and out of bound exclusions\n\n  let toRemove = exclusions.reduce(\n    (previous, exclusion) => (previous += exclusion.to - exclusion.from),\n    0\n  );\n  let total = to - from;\n  let unitsPerPoint = (total - toRemove) / numberOfPoints;\n  let zones = [];\n  let currentFrom = from;\n  let totalPoints = 0;\n  for (let exclusion of exclusions) {\n    let currentNbPoints = Math.round(\n      (exclusion.from - currentFrom) / unitsPerPoint\n    );\n    totalPoints += currentNbPoints;\n    if (currentNbPoints > 0) {\n      zones.push({\n        from: currentFrom,\n        to: exclusion.from,\n        numberOfPoints: currentNbPoints\n      });\n    }\n\n    currentFrom = exclusion.to;\n  }\n  if (numberOfPoints - totalPoints > 0) {\n    zones.push({\n      from: currentFrom,\n      to: to,\n      numberOfPoints: numberOfPoints - totalPoints\n    });\n  }\n\n  return zones;\n}\n","/**\n * function that retrieves the getEquallySpacedData with the variant \"slot\"\n *\n * @param {Array<number>} x\n * @param {Array<number>} y\n * @param {number} from - Initial point\n * @param {number} to - Final point\n * @param {number} numberOfPoints\n * @return {Array} - Array of y's equally spaced with the variant \"slot\"\n */\nexport default function equallySpacedSlot(x, y, from, to, numberOfPoints) {\n  var xLength = x.length;\n\n  var step = (to - from) / (numberOfPoints - 1);\n  var halfStep = step / 2;\n  var lastStep = x[x.length - 1] - x[x.length - 2];\n\n  var start = from - halfStep;\n  var output = new Array(numberOfPoints);\n\n  // Init main variables\n  var min = start;\n  var max = start + step;\n\n  var previousX = -Number.MAX_VALUE;\n  var previousY = 0;\n  var nextX = x[0];\n  var nextY = y[0];\n  var frontOutsideSpectra = 0;\n  var backOutsideSpectra = true;\n\n  var currentValue = 0;\n\n  // for slot algorithm\n  var currentPoints = 0;\n\n  var i = 1; // index of input\n  var j = 0; // index of output\n\n  main: while (true) {\n    if (previousX >= nextX) throw new Error('x must be an increasing serie');\n    while (previousX - max > 0) {\n      // no overlap with original point, just consume current value\n      if (backOutsideSpectra) {\n        currentPoints++;\n        backOutsideSpectra = false;\n      }\n\n      output[j] = currentPoints <= 0 ? 0 : currentValue / currentPoints;\n      j++;\n\n      if (j === numberOfPoints) {\n        break main;\n      }\n\n      min = max;\n      max += step;\n      currentValue = 0;\n      currentPoints = 0;\n    }\n\n    if (previousX > min) {\n      currentValue += previousY;\n      currentPoints++;\n    }\n\n    if (previousX === -Number.MAX_VALUE || frontOutsideSpectra > 1) {\n      currentPoints--;\n    }\n\n    previousX = nextX;\n    previousY = nextY;\n\n    if (i < xLength) {\n      nextX = x[i];\n      nextY = y[i];\n      i++;\n    } else {\n      nextX += lastStep;\n      nextY = 0;\n      frontOutsideSpectra++;\n    }\n  }\n\n  return output;\n}\n","import integral from './integral';\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"smooth\"\n *\n * @param {Array<number>} x\n * @param {Array<number>} y\n * @param {number} from - Initial point\n * @param {number} to - Final point\n * @param {number} numberOfPoints\n * @return {Array} - Array of y's equally spaced with the variant \"smooth\"\n */\nexport default function equallySpacedSmooth(x, y, from, to, numberOfPoints) {\n  var xLength = x.length;\n\n  var step = (to - from) / (numberOfPoints - 1);\n  var halfStep = step / 2;\n\n  var output = new Array(numberOfPoints);\n\n  var initialOriginalStep = x[1] - x[0];\n  var lastOriginalStep = x[xLength - 1] - x[xLength - 2];\n\n  // Init main variables\n  var min = from - halfStep;\n  var max = from + halfStep;\n\n  var previousX = Number.MIN_VALUE;\n  var previousY = 0;\n  var nextX = x[0] - initialOriginalStep;\n  var nextY = 0;\n\n  var currentValue = 0;\n  var slope = 0;\n  var intercept = 0;\n  var sumAtMin = 0;\n  var sumAtMax = 0;\n\n  var i = 0; // index of input\n  var j = 0; // index of output\n\n  function getSlope(x0, y0, x1, y1) {\n    return (y1 - y0) / (x1 - x0);\n  }\n\n  main: while (true) {\n    if (previousX <= min && min <= nextX) {\n      add = integral(0, min - previousX, slope, previousY);\n      sumAtMin = currentValue + add;\n    }\n\n    while (nextX - max >= 0) {\n      // no overlap with original point, just consume current value\n      var add = integral(0, max - previousX, slope, previousY);\n      sumAtMax = currentValue + add;\n\n      output[j++] = (sumAtMax - sumAtMin) / step;\n\n      if (j === numberOfPoints) {\n        break main;\n      }\n\n      min = max;\n      max += step;\n      sumAtMin = sumAtMax;\n    }\n\n    currentValue += integral(previousX, nextX, slope, intercept);\n\n    previousX = nextX;\n    previousY = nextY;\n\n    if (i < xLength) {\n      nextX = x[i];\n      nextY = y[i];\n      i++;\n    } else if (i === xLength) {\n      nextX += lastOriginalStep;\n      nextY = 0;\n    }\n\n    slope = getSlope(previousX, previousY, nextX, nextY);\n    intercept = -slope * previousX + previousY;\n  }\n\n  return output;\n}\n","import getZones from './getZones';\n\n/**\n * Filter an array x/y based on various criteria\n * x points are expected to be sorted\n *\n * @param {object} points\n * @param {object} [options={}]\n * @param {array} [options.from]\n * @param {array} [options.to]\n * @param {array} [options.exclusions=[]]\n * @return {{x: Array<number>, y: Array<number>}}\n */\n\nexport default function filterX(points, options = {}) {\n  const { x, y } = points;\n  const { from = x[0], to = x[x.length - 1], exclusions = [] } = options;\n\n  let zones = getZones(from, to, exclusions);\n\n\n  let currentZoneIndex = 0;\n  let newX = [];\n  let newY = [];\n  let position = 0;\n  while (position < x.length) {\n    if (\n      x[position] <= zones[currentZoneIndex].to &&\n      x[position] >= zones[currentZoneIndex].from\n    ) {\n      newX.push(x[position]);\n      newY.push(y[position]);\n    } else {\n      if (x[position] > zones[currentZoneIndex].to) {\n        currentZoneIndex++;\n        if (!zones[currentZoneIndex]) break;\n      }\n    }\n    position++;\n  }\n\n  return {\n    x: newX,\n    y: newY\n  };\n}\n","export default function getZones(from, to, exclusions = []) {\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n\n  // in exclusions from and to have to be defined\n  exclusions = exclusions.filter(\n    (exclusion) => exclusion.from !== undefined && exclusion.to !== undefined\n  );\n\n  exclusions = JSON.parse(JSON.stringify(exclusions));\n  // we ensure that from before to\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from > exclusion.to) {\n      [exclusion.to, exclusion.from] = [exclusion.from, exclusion.to];\n    }\n  });\n\n  exclusions.sort((a, b) => a.from - b.from);\n\n  // we will rework the exclusions in order to remove overlap and outside range (from / to)\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from < from) exclusion.from = from;\n    if (exclusion.to > to) exclusion.to = to;\n  });\n  for (let i = 0; i < exclusions.length - 1; i++) {\n    if (exclusions[i].to > exclusions[i + 1].from) {\n      exclusions[i].to = exclusions[i + 1].from;\n    }\n  }\n  exclusions = exclusions.filter((exclusion) => exclusion.from < exclusion.to);\n\n  if (!exclusions || exclusions.length === 0) {\n    return [{ from, to }];\n  }\n\n  let zones = [];\n  let currentFrom = from;\n  for (let exclusion of exclusions) {\n    if (currentFrom < exclusion.from) {\n      zones.push({\n        from: currentFrom,\n        to: exclusion.from\n      });\n    }\n\n    currentFrom = exclusion.to;\n  }\n  if (currentFrom < to) {\n    zones.push({\n      from: currentFrom,\n      to: to\n    });\n  }\n\n  return zones;\n}\n"],"sourceRoot":""}