{"version":3,"file":"spectra-processor.min.js","sources":["../node_modules/is-any-array/src/index.js","../lib/index.js"],"sourcesContent":["'use strict';\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar array = createCommonjsModule(function (module, exports) {\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = values[0];\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\n/**\n * IEEE Transactions on biomedical engineering, vol. 52, no. 1, january 2005, p. 76-\n * Calculate the standard deviation via the Median of the absolute deviation\n *  The formula for the standard deviation only holds for Gaussian random variables.\n * @returns {{mean: number, stdev: number}}\n */\nexports.robustMeanAndStdev = function robustMeanAndStdev(y) {\n    var mean = 0, stdev = 0;\n    var length = y.length, i = 0;\n    for (i = 0; i < length; i++) {\n        mean += y[i];\n    }\n    mean /= length;\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort(compareNumbers);\n    if (length % 2 === 1) {\n        stdev = averageDeviations[(length - 1) / 2] / 0.6745;\n    } else {\n        stdev = 0.5 * (averageDeviations[length / 2] + averageDeviations[length / 2 - 1]) / 0.6745;\n    }\n\n    return {\n        mean: mean,\n        stdev: stdev\n    };\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof (alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw 'Vectors do not have the same dimensions';\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    } else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    } else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof (eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = [].concat(values);\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof (standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n});\nvar array_1 = array.sum;\nvar array_2 = array.max;\nvar array_3 = array.min;\nvar array_4 = array.minMax;\nvar array_5 = array.arithmeticMean;\nvar array_6 = array.mean;\nvar array_7 = array.geometricMean;\nvar array_8 = array.logMean;\nvar array_9 = array.grandMean;\nvar array_10 = array.truncatedMean;\nvar array_11 = array.harmonicMean;\nvar array_12 = array.contraHarmonicMean;\nvar array_13 = array.median;\nvar array_14 = array.variance;\nvar array_15 = array.standardDeviation;\nvar array_16 = array.standardError;\nvar array_17 = array.robustMeanAndStdev;\nvar array_18 = array.quartiles;\nvar array_19 = array.pooledStandardDeviation;\nvar array_20 = array.pooledVariance;\nvar array_21 = array.mode;\nvar array_22 = array.covariance;\nvar array_23 = array.skewness;\nvar array_24 = array.kurtosis;\nvar array_25 = array.entropy;\nvar array_26 = array.weightedMean;\nvar array_27 = array.weightedStandardDeviation;\nvar array_28 = array.weightedVariance;\nvar array_29 = array.center;\nvar array_30 = array.standardize;\nvar array_31 = array.cumulativeSum;\n\nfunction getZones(from, to, exclusions = []) {\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n\n  // in exclusions from and to have to be defined\n  exclusions = exclusions.filter(\n    (exclusion) => exclusion.from !== undefined && exclusion.to !== undefined\n  );\n\n  exclusions = JSON.parse(JSON.stringify(exclusions));\n  // we ensure that from before to\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from > exclusion.to) {\n      [exclusion.to, exclusion.from] = [exclusion.from, exclusion.to];\n    }\n  });\n\n  exclusions.sort((a, b) => a.from - b.from);\n\n  // we will rework the exclusions in order to remove overlap and outside range (from / to)\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from < from) exclusion.from = from;\n    if (exclusion.to > to) exclusion.to = to;\n  });\n  for (let i = 0; i < exclusions.length - 1; i++) {\n    if (exclusions[i].to > exclusions[i + 1].from) {\n      exclusions[i].to = exclusions[i + 1].from;\n    }\n  }\n  exclusions = exclusions.filter((exclusion) => exclusion.from < exclusion.to);\n\n  if (!exclusions || exclusions.length === 0) {\n    return [{ from, to }];\n  }\n\n  let zones = [];\n  let currentFrom = from;\n  for (let exclusion of exclusions) {\n    if (currentFrom < exclusion.from) {\n      zones.push({\n        from: currentFrom,\n        to: exclusion.from\n      });\n    }\n\n    currentFrom = exclusion.to;\n  }\n  if (currentFrom < to) {\n    zones.push({\n      from: currentFrom,\n      to: to\n    });\n  }\n\n  return zones;\n}\n\n/**\n * Filter an array x/y based on various criteria\n * x points are expected to be sorted\n *\n * @param {object} points\n * @param {object} [options={}]\n * @param {array} [options.from]\n * @param {array} [options.to]\n * @param {array} [options.exclusions=[]]\n * @return {{x: Array<number>, y: Array<number>}}\n */\n\nfunction filterX(points, options = {}) {\n  const { x, y } = points;\n  const { from = x[0], to = x[x.length - 1], exclusions = [] } = options;\n\n  let zones = getZones(from, to, exclusions);\n\n\n  let currentZoneIndex = 0;\n  let newX = [];\n  let newY = [];\n  let position = 0;\n  while (position < x.length) {\n    if (\n      x[position] <= zones[currentZoneIndex].to &&\n      x[position] >= zones[currentZoneIndex].from\n    ) {\n      newX.push(x[position]);\n      newY.push(y[position]);\n    } else {\n      if (x[position] > zones[currentZoneIndex].to) {\n        currentZoneIndex++;\n        if (!zones[currentZoneIndex]) break;\n      }\n    }\n    position++;\n  }\n\n  return {\n    x: newX,\n    y: newY\n  };\n}\n\n/**\n *\n * @private\n * @param {Spectrum} spectrum\n * @param {object} [filter={}]\n * @param {array} [filter.from]\n * @param {array} [filter.to]\n * @param {array} [filter.exclusions=[]]\n */\n\nfunction getData(spectrum, filter = {}) {\n  let data = { x: spectrum.x, y: spectrum.y };\n\n  if (filter) {\n    data = filterX({ x: spectrum.x, y: spectrum.y }, filter);\n  }\n  return data;\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nvar src = isAnyArray;\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n/**\n * Fill an array with sequential numbers\n * @param {Array<number>} [input] - optional destination array (if not provided a new array will be created)\n * @param {object} [options={}]\n * @param {number} [options.from=0] - first value in the array\n * @param {number} [options.to=10] - last value in the array\n * @param {number} [options.size=input.length] - size of the array (if not provided calculated from step)\n * @param {number} [options.step] - if not provided calculated from size\n * @return {Array<number>}\n */\n\nfunction sequentialFill() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (_typeof(input) === 'object' && !src(input)) {\n    options = input;\n    input = [];\n  }\n\n  if (!src(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  var _options = options,\n      _options$from = _options.from,\n      from = _options$from === void 0 ? 0 : _options$from,\n      _options$to = _options.to,\n      to = _options$to === void 0 ? 10 : _options$to,\n      _options$size = _options.size,\n      size = _options$size === void 0 ? input.length : _options$size,\n      step = _options.step;\n\n  if (size && step) {\n    throw new Error('step is defined by the array size');\n  }\n\n  if (!size) {\n    if (step) {\n      size = Math.floor((to - from) / step) + 1;\n    } else {\n      size = to - from + 1;\n    }\n  }\n\n  if (!step && size) {\n    step = (to - from) / (size - 1);\n  }\n\n  if (Array.isArray(input)) {\n    input.length = 0; // only works with normal array\n\n    for (var i = 0; i < size; i++) {\n      input.push(from);\n      from += step;\n    }\n  } else {\n    if (input.length !== size) {\n      throw new Error('sequentialFill typed array must have the correct length');\n    }\n\n    for (var _i = 0; _i < size; _i++) {\n      input[_i] = from;\n      from += step;\n    }\n  }\n\n  return input;\n}\n\n/**\n * Function that calculates the integral of the line between two\n * x-coordinates, given the slope and intercept of the line.\n * @param {number} x0\n * @param {number} x1\n * @param {number} slope\n * @param {number} intercept\n * @return {number} integral value.\n */\nfunction integral(x0, x1, slope, intercept) {\n  return (\n    0.5 * slope * x1 * x1 +\n    intercept * x1 -\n    (0.5 * slope * x0 * x0 + intercept * x0)\n  );\n}\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"smooth\"\n *\n * @param {Array<number>} x\n * @param {Array<number>} y\n * @param {number} from - Initial point\n * @param {number} to - Final point\n * @param {number} numberOfPoints\n * @return {Array} - Array of y's equally spaced with the variant \"smooth\"\n */\nfunction equallySpacedSmooth(x, y, from, to, numberOfPoints) {\n  var xLength = x.length;\n\n  var step = (to - from) / (numberOfPoints - 1);\n  var halfStep = step / 2;\n\n  var output = new Array(numberOfPoints);\n\n  var initialOriginalStep = x[1] - x[0];\n  var lastOriginalStep = x[xLength - 1] - x[xLength - 2];\n\n  // Init main variables\n  var min = from - halfStep;\n  var max = from + halfStep;\n\n  var previousX = Number.MIN_VALUE;\n  var previousY = 0;\n  var nextX = x[0] - initialOriginalStep;\n  var nextY = 0;\n\n  var currentValue = 0;\n  var slope = 0;\n  var intercept = 0;\n  var sumAtMin = 0;\n  var sumAtMax = 0;\n\n  var i = 0; // index of input\n  var j = 0; // index of output\n\n  function getSlope(x0, y0, x1, y1) {\n    return (y1 - y0) / (x1 - x0);\n  }\n\n  main: while (true) {\n    if (previousX <= min && min <= nextX) {\n      add = integral(0, min - previousX, slope, previousY);\n      sumAtMin = currentValue + add;\n    }\n\n    while (nextX - max >= 0) {\n      // no overlap with original point, just consume current value\n      var add = integral(0, max - previousX, slope, previousY);\n      sumAtMax = currentValue + add;\n\n      output[j++] = (sumAtMax - sumAtMin) / step;\n\n      if (j === numberOfPoints) {\n        break main;\n      }\n\n      min = max;\n      max += step;\n      sumAtMin = sumAtMax;\n    }\n\n    currentValue += integral(previousX, nextX, slope, intercept);\n\n    previousX = nextX;\n    previousY = nextY;\n\n    if (i < xLength) {\n      nextX = x[i];\n      nextY = y[i];\n      i++;\n    } else if (i === xLength) {\n      nextX += lastOriginalStep;\n      nextY = 0;\n    }\n\n    slope = getSlope(previousX, previousY, nextX, nextY);\n    intercept = -slope * previousX + previousY;\n  }\n\n  return output;\n}\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"slot\"\n *\n * @param {Array<number>} x\n * @param {Array<number>} y\n * @param {number} from - Initial point\n * @param {number} to - Final point\n * @param {number} numberOfPoints\n * @return {Array} - Array of y's equally spaced with the variant \"slot\"\n */\nfunction equallySpacedSlot(x, y, from, to, numberOfPoints) {\n  var xLength = x.length;\n\n  var step = (to - from) / (numberOfPoints - 1);\n  var halfStep = step / 2;\n  var lastStep = x[x.length - 1] - x[x.length - 2];\n\n  var start = from - halfStep;\n  var output = new Array(numberOfPoints);\n\n  // Init main variables\n  var min = start;\n  var max = start + step;\n\n  var previousX = -Number.MAX_VALUE;\n  var previousY = 0;\n  var nextX = x[0];\n  var nextY = y[0];\n  var frontOutsideSpectra = 0;\n  var backOutsideSpectra = true;\n\n  var currentValue = 0;\n\n  // for slot algorithm\n  var currentPoints = 0;\n\n  var i = 1; // index of input\n  var j = 0; // index of output\n\n  main: while (true) {\n    if (previousX >= nextX) throw new Error('x must be an increasing serie');\n    while (previousX - max > 0) {\n      // no overlap with original point, just consume current value\n      if (backOutsideSpectra) {\n        currentPoints++;\n        backOutsideSpectra = false;\n      }\n\n      output[j] = currentPoints <= 0 ? 0 : currentValue / currentPoints;\n      j++;\n\n      if (j === numberOfPoints) {\n        break main;\n      }\n\n      min = max;\n      max += step;\n      currentValue = 0;\n      currentPoints = 0;\n    }\n\n    if (previousX > min) {\n      currentValue += previousY;\n      currentPoints++;\n    }\n\n    if (previousX === -Number.MAX_VALUE || frontOutsideSpectra > 1) {\n      currentPoints--;\n    }\n\n    previousX = nextX;\n    previousY = nextY;\n\n    if (i < xLength) {\n      nextX = x[i];\n      nextY = y[i];\n      i++;\n    } else {\n      nextX += lastStep;\n      nextY = 0;\n      frontOutsideSpectra++;\n    }\n  }\n\n  return output;\n}\n\nfunction getZones$1(from, to, numberOfPoints, exclusions = []) {\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n\n  // in exclusions from and to have to be defined\n  exclusions = exclusions.filter(\n    (exclusion) => exclusion.from !== undefined && exclusion.to !== undefined\n  );\n\n  exclusions = JSON.parse(JSON.stringify(exclusions));\n  // we ensure that from before to\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from > exclusion.to) {\n      [exclusion.to, exclusion.from] = [exclusion.from, exclusion.to];\n    }\n  });\n\n  exclusions.sort((a, b) => a.from - b.from);\n\n  // we will rework the exclusions in order to remove overlap and outside range (from / to)\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from < from) exclusion.from = from;\n    if (exclusion.to > to) exclusion.to = to;\n  });\n  for (let i = 0; i < exclusions.length - 1; i++) {\n    if (exclusions[i].to > exclusions[i + 1].from) {\n      exclusions[i].to = exclusions[i + 1].from;\n    }\n  }\n  exclusions = exclusions.filter((exclusion) => exclusion.from < exclusion.to);\n\n  if (!exclusions || exclusions.length === 0) {\n    return [{ from, to, numberOfPoints }];\n  }\n\n  // need to deal with overlapping exclusions and out of bound exclusions\n\n  let toRemove = exclusions.reduce(\n    (previous, exclusion) => (previous += exclusion.to - exclusion.from),\n    0\n  );\n  let total = to - from;\n  let unitsPerPoint = (total - toRemove) / numberOfPoints;\n  let zones = [];\n  let currentFrom = from;\n  let totalPoints = 0;\n  for (let exclusion of exclusions) {\n    let currentNbPoints = Math.round(\n      (exclusion.from - currentFrom) / unitsPerPoint\n    );\n    totalPoints += currentNbPoints;\n    if (currentNbPoints > 0) {\n      zones.push({\n        from: currentFrom,\n        to: exclusion.from,\n        numberOfPoints: currentNbPoints\n      });\n    }\n\n    currentFrom = exclusion.to;\n  }\n  if (numberOfPoints - totalPoints > 0) {\n    zones.push({\n      from: currentFrom,\n      to: to,\n      numberOfPoints: numberOfPoints - totalPoints\n    });\n  }\n\n  return zones;\n}\n\n/**\n * Function that returns a Number array of equally spaced numberOfPoints\n * containing a representation of intensities of the spectra arguments x\n * and y.\n *\n * The options parameter contains an object in the following form:\n * from: starting point\n * to: last point\n * numberOfPoints: number of points between from and to\n * variant: \"slot\" or \"smooth\" - smooth is the default option\n *\n * The slot variant consist that each point in the new array is calculated\n * averaging the existing points between the slot that belongs to the current\n * value. The smooth variant is the same but takes the integral of the range\n * of the slot and divide by the step size between two points in the new array.\n *\n * @param {object} [arrayXY={}] - object containing 2 properties x and y (both an array)\n * @param {object} [options={}]\n * @param {number} [options.from=x[0]]\n * @param {number} [options.to=x[x.length-1]]\n * @param {string} [options.variant='smooth']\n * @param {number} [options.numberOfPoints=100]\n * @param {Array} [options.exclusions=[]] array of from / to that should be skipped for the generation of the points\n * @return {object<x: Array, y:Array>} new object with x / y array with the equally spaced data.\n */\n\nfunction equallySpaced(arrayXY = {}, options = {}) {\n  let { x, y } = arrayXY;\n  let xLength = x.length;\n  let reverse = false;\n  if (x.length > 1 && x[0] > x[1]) {\n    x = x.slice().reverse();\n    y = y.slice().reverse();\n    reverse = true;\n  }\n\n  let {\n    from = x[0],\n    to = x[xLength - 1],\n    variant = 'smooth',\n    numberOfPoints = 100,\n    exclusions = []\n  } = options;\n\n  if (xLength !== y.length) {\n    throw new RangeError(\"the x and y vector doesn't have the same size.\");\n  }\n\n  if (typeof from !== 'number' || isNaN(from)) {\n    throw new RangeError(\"'from' option must be a number\");\n  }\n\n  if (typeof to !== 'number' || isNaN(to)) {\n    throw new RangeError(\"'to' option must be a number\");\n  }\n\n  if (typeof numberOfPoints !== 'number' || isNaN(numberOfPoints)) {\n    throw new RangeError(\"'numberOfPoints' option must be a number\");\n  }\n\n  if (numberOfPoints < 2) {\n    throw new RangeError(\"'numberOfPoints' option must be greater than 1\");\n  }\n\n  let zones = getZones$1(from, to, numberOfPoints, exclusions);\n\n  let xResult = [];\n  let yResult = [];\n  for (let zone of zones) {\n    let zoneResult = processZone(\n      x,\n      y,\n      zone.from,\n      zone.to,\n      zone.numberOfPoints,\n      variant);\n    xResult = xResult.concat(zoneResult.x);\n    yResult = yResult.concat(zoneResult.y);\n  }\n\n  if (reverse) {\n    if (from < to) {\n      return { x: xResult.reverse(), y: yResult.reverse() };\n    } else {\n      return { x: xResult, y: yResult };\n    }\n  } else {\n    if (from < to) {\n      return { x: xResult, y: yResult };\n    } else {\n      return { x: xResult.reverse(), y: yResult.reverse() };\n    }\n  }\n}\n\nfunction processZone(x, y, from, to, numberOfPoints, variant) {\n  if (numberOfPoints < 1) {\n    throw new RangeError('the number of points must be at least 1');\n  }\n\n  var output =\n    variant === 'slot'\n      ? equallySpacedSlot(x, y, from, to, numberOfPoints)\n      : equallySpacedSmooth(x, y, from, to, numberOfPoints);\n\n  return {\n    x: sequentialFill({\n      from,\n      to,\n      size: numberOfPoints\n    }),\n    y: output\n  };\n}\n\n/**\n * Computes the maximum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction max(input) {\n  if (!src(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var maxValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\n/**\n * Computes the mean of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction sum(input) {\n  if (!src(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var sumValue = 0;\n\n  for (var i = 0; i < input.length; i++) {\n    sumValue += input[i];\n  }\n\n  return sumValue;\n}\n\n/**\n * Computes the norm of the given values\n * @param {Array<number>} input\n * @param {object} [options={}]\n * @param {string} [options.algorithm='absolute'] absolute, sum or max\n * @return {number}\n */\n\nfunction norm(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$algorithm = options.algorithm,\n      algorithm = _options$algorithm === void 0 ? 'absolute' : _options$algorithm;\n\n  if (!Array.isArray(input)) {\n    throw new Error('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new Error('input must not be empty');\n  }\n\n  switch (algorithm.toLowerCase()) {\n    case 'absolute':\n      {\n        var absoluteSumValue = absoluteSum(input);\n        if (absoluteSumValue === 0) return input.slice(0);\n        return input.map(function (element) {\n          return element / absoluteSumValue;\n        });\n      }\n\n    case 'max':\n      {\n        var maxValue = max(input);\n        if (maxValue === 0) return input.slice(0);\n        return input.map(function (element) {\n          return element / maxValue;\n        });\n      }\n\n    case 'sum':\n      {\n        var sumValue = sum(input);\n        if (sumValue === 0) return input.slice(0);\n        return input.map(function (element) {\n          return element / sumValue;\n        });\n      }\n\n    default:\n      throw new Error(\"norm: unknown algorithm: \".concat(algorithm));\n  }\n}\n\nfunction absoluteSum(input) {\n  var sumValue = 0;\n\n  for (var i = 0; i < input.length; i++) {\n    sumValue += Math.abs(input[i]);\n  }\n\n  return sumValue;\n}\n\n/**\n * Computes the minimum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction min(input) {\n  if (!src(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var minValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\nfunction rescale(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!src(input)) {\n    throw new TypeError('input must be an array');\n  } else if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!src(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  var currentMin = min(input);\n  var currentMax = max(input);\n\n  if (currentMin === currentMax) {\n    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');\n  }\n\n  var _options$min = options.min,\n      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,\n      _options$max = options.max,\n      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;\n\n  if (minValue >= maxValue) {\n    throw new RangeError('min option must be smaller than max option');\n  }\n\n  var factor = (maxValue - minValue) / (currentMax - currentMin);\n\n  for (var i = 0; i < input.length; i++) {\n    output[i] = (input[i] - currentMin) * factor + minValue;\n  }\n\n  return output;\n}\n\n/**\n *\n * @private\n * @param {*} spectrum\n * @param {*} options\n */\nfunction getNormalized(spectrum, options = {}) {\n  if (!Array.isArray(spectrum.x) || !Array.isArray(spectrum.y)) {\n    throw new Error(\n      'getNormalized: Can not get normalized data, missing original data.',\n    );\n  }\n\n  let {\n    from = spectrum.x[0],\n    to = spectrum.x[spectrum.x.length - 1],\n    numberOfPoints = 1024,\n    filters = [],\n    exclusions = [],\n  } = options;\n\n  let y = spectrum.y.slice(0);\n\n  for (let filter of filters) {\n    switch (filter.name) {\n      case 'centerMean': {\n        let mean = array.mean(spectrum.y);\n        let meanFct = (y) => y - mean;\n        y = y.map(meanFct);\n        break;\n      }\n      case 'scaleSD': {\n        let std = array.standardDeviation(spectrum.y);\n        let stdFct = (y) => y / std;\n        y = y.map(stdFct);\n        break;\n      }\n      case 'normalize': {\n        y = norm(y);\n        break;\n      }\n      case 'rescale': {\n        y = rescale(y);\n        break;\n      }\n      case '':\n      case undefined:\n        break;\n      default:\n        throw new Error(`Unknown process kind: ${process.kind}`);\n    }\n  }\n  let result = equallySpaced(\n    { x: spectrum.x, y },\n    { from, to, numberOfPoints, exclusions },\n  );\n  return result;\n}\n\nconst isAnyArray$1 = require('is-any-array');\n\n/**\n * Throw an error in no an object of x,y arrays\n * @param {object} [points={}]\n */\nfunction check(points = {}) {\n  if (!isAnyArray$1(points.x) || !isAnyArray$1(points.y)) {\n    throw new Error('Points must be an object of x and y arrays');\n  }\n  if (points.x.length !== points.y.length) {\n    throw new Error('The x and y arrays mush have the same length');\n  }\n}\n\n/**\n * Returns the closest index of a `target` in an ordered array\n * @param {array} array\n * @param {number} target\n */\n\nfunction findClosestIndex(array, target) {\n  let low = 0;\n  let high = array.length - 1;\n  let middle = 0;\n  while (high - low > 1) {\n    middle = low + ((high - low) >> 1);\n    if (array[middle] < target) {\n      low = middle;\n    } else if (array[middle] > target) {\n      high = middle;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low < array.length - 1) {\n    if (Math.abs(target - array[low]) < Math.abs(array[low + 1] - target)) {\n      return low;\n    } else {\n      return low + 1;\n    }\n  } else {\n    return low;\n  }\n}\n\n/**\n * Returns an object with {fromIndex, toIndex} for a specific from / to\n * @param {array} x\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n */\n\nfunction getFromToIndex(x, options = {}) {\n  let { fromIndex, toIndex, from, to } = options;\n\n  if (fromIndex === undefined) {\n    if (from !== undefined) {\n      fromIndex = findClosestIndex(x, from);\n    } else {\n      fromIndex = 0;\n    }\n  }\n  if (toIndex === undefined) {\n    if (to !== undefined) {\n      toIndex = findClosestIndex(x, to);\n    } else {\n      toIndex = x.length - 1;\n    }\n  }\n  return { fromIndex, toIndex };\n}\n\n/**\n * In place modification of the 2 arrays to make X unique and sum the Y if X has the same value\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {number} Integration value on the specified range\n */\n\nfunction integration(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n  let integration = 0;\n  for (let i = fromIndex; i < toIndex; i++) {\n    integration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;\n  }\n\n  return integration;\n}\n\n/**\n * Generate a X / Y of the integral\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @param {boolean} [options.reverse=false] - Integrate from the larger value to the smallest value\n * @return {{x:[],y:[]}} An object with the integration function\n */\n\nfunction integral$1(points = {}, options = {}) {\n  const { reverse = false } = options;\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let integration = 0;\n  let integral;\n  if (reverse) {\n    integral = { x: [x[toIndex]], y: [0] };\n    for (let i = toIndex; i > fromIndex; i--) {\n      integration += ((x[i] - x[i - 1]) * (y[i - 1] + y[i])) / 2;\n      integral.x.push(x[i - 1]);\n      integral.y.push(integration);\n    }\n    integral.x.reverse();\n    integral.y.reverse();\n  } else {\n    integral = { x: [x[fromIndex]], y: [0] };\n    for (let i = fromIndex; i < toIndex; i++) {\n      integration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;\n      integral.x.push(x[i + 1]);\n      integral.y.push(integration);\n    }\n  }\n\n  return integral;\n}\n\n/**\n * Finds the max value in a zone\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {number} Max y on the specified range\n */\n\nfunction maxY(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let maxY = y[fromIndex];\n  for (let i = fromIndex; i <= toIndex; i++) {\n    if (y[i] > maxY) maxY = y[i];\n  }\n\n  return maxY;\n}\n\n/**\n * Finds the max y value in a range and return a {x,y} point\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {object}\n */\n\nfunction maxYPoint(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let current = { x: x[fromIndex], y: y[fromIndex] };\n  for (let i = fromIndex; i <= toIndex; i++) {\n    if (y[i] > current.y) current = { x: x[i], y: y[i] };\n  }\n\n  return current;\n}\n\n/**\n * Finds the max y value in a range and return a {x,y} point\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {object}\n */\n\nfunction minYPoint(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let current = { x: x[fromIndex], y: y[fromIndex] };\n  for (let i = fromIndex; i <= toIndex; i++) {\n    if (y[i] < current.y) current = { x: x[i], y: y[i] };\n  }\n\n  return current;\n}\n\n/**\n * Reduce the number of points while keeping the same noise. Practical to\n * display many spectra as SVG\n * @param {array} x\n * @param {array} y\n * @param {object} [options={}]\n * @param {number} [from=x[0]]\n * @param {number} [to=x[x.length-1]]\n * @param {number} [nbPoints=4001] Number of points\n */\n\nfunction reduce(x, y, options = {}) {\n  let { from = x[0], to = x[x.length - 1], nbPoints = 4000 } = options;\n\n  let fromIndex = findClosestIndex(x, from);\n  let toIndex = findClosestIndex(x, to);\n\n  if (fromIndex > 0 && x[fromIndex] > from) fromIndex--;\n  if (toIndex < x.length - 1 && x[toIndex] < to) toIndex++;\n\n  if (toIndex - fromIndex < nbPoints) {\n    return {\n      x: x.slice(fromIndex, toIndex + 1),\n      y: y.slice(fromIndex, toIndex + 1),\n    };\n  }\n\n  let newX = [x[fromIndex]];\n  let newY = [y[fromIndex]];\n  let minY = Number.MAX_VALUE;\n  let maxY = Number.MIN_VALUE;\n  if (nbPoints % 2 === 0) {\n    nbPoints = nbPoints / 2 + 1;\n  } else {\n    nbPoints = (nbPoints - 1) / 2 + 1;\n  }\n\n  let slot = (x[toIndex] - x[fromIndex]) / (nbPoints - 1);\n  let currentX = x[fromIndex] + slot;\n  let first = true;\n  for (let i = fromIndex + 1; i <= toIndex; i++) {\n    if (first) {\n      minY = y[i];\n      maxY = y[i];\n      first = false;\n    } else {\n      if (y[i] < minY) minY = y[i];\n      if (y[i] > maxY) maxY = y[i];\n    }\n\n    if (x[i] >= currentX || i === toIndex) {\n      newX.push(currentX - slot / 2);\n      newY.push(minY);\n      newX.push(currentX);\n      newY.push(maxY);\n      currentX += slot;\n      first = true;\n    }\n  }\n\n  // we will need to make some kind of min / max because there are too many points\n  // we will always keep the first point and the last point\n\n  return { x: newX, y: newY };\n}\n\n/**\n * Sort object of array, x has to be monotone.\n * @param {object} data Object of kind {x:[], re:[], im:[]}.\n * @return {SD}\n */\n\nfunction sortX(data) {\n  const { x, y } = data;\n\n  if (x.length !== y.length) {\n    throw TypeError('sortX: length of x and y must be identical');\n  }\n\n  if (x.length < 2 || x[0] < x[1]) return data;\n\n  return {\n    x: x.slice(0).reverse(),\n    y: y.slice(0).reverse(),\n  };\n}\n\n/**\n * Find the closest minimum going down hill\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @return {{x,y,xIndex}} An object with the x/y value\n */\n\nfunction minClosestYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n\n  let { target, targetIndex } = options;\n\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      targetIndex = findClosestIndex(x, target);\n    } else {\n      targetIndex = 0;\n    }\n  }\n\n  let previousIndex = Number.MIN_SAFE_INTEGER;\n  let currentIndex = targetIndex;\n\n  let minY = y[targetIndex];\n\n  while (currentIndex !== previousIndex) {\n    previousIndex = currentIndex;\n    if (currentIndex > 0 && y[currentIndex - 1] < minY) {\n      currentIndex--;\n    } else if (currentIndex < x.length - 1 && y[currentIndex + 1] < minY) {\n      currentIndex++;\n    }\n    minY = y[currentIndex];\n  }\n  return {\n    x: x[currentIndex],\n    y: y[currentIndex],\n    index: currentIndex,\n  };\n}\n\n/**\n * Find the closest maximum going up hill\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @return {{x,y,xIndex}} An object with the x/y value\n */\n\nfunction maxClosestYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n\n  let { target, targetIndex } = options;\n\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      targetIndex = findClosestIndex(x, target);\n    } else {\n      targetIndex = 0;\n    }\n  }\n\n  let previousIndex = Number.MIN_SAFE_INTEGER;\n  let currentIndex = targetIndex;\n\n  let maxY = y[targetIndex];\n\n  while (currentIndex !== previousIndex) {\n    previousIndex = currentIndex;\n    if (currentIndex > 0 && y[currentIndex - 1] > maxY) {\n      currentIndex--;\n    } else if (currentIndex < x.length - 1 && y[currentIndex + 1] > maxY) {\n      currentIndex++;\n    }\n    maxY = y[currentIndex];\n  }\n  return {\n    x: x[currentIndex],\n    y: y[currentIndex],\n    index: currentIndex,\n  };\n}\n\n/**\n *  Returns the targetIndex\n * @param {array} [x]\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @param {number}\n */\n\nfunction getTargetIndex(x, options = {}) {\n  let { target, targetIndex } = options;\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      return findClosestIndex(x, target);\n    } else {\n      return 0;\n    }\n  }\n  return targetIndex;\n}\n\nfunction realMinYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n\n  const targetIndex = getTargetIndex(x, options);\n  // interpolation to a sin() function\n  if (\n    y[targetIndex - 1] < 0 &&\n    y[targetIndex + 1] < 0 &&\n    y[targetIndex] <= y[targetIndex - 1] &&\n    y[targetIndex] <= y[targetIndex + 1]\n  ) {\n    let alpha = 20 * Math.log10(-y[targetIndex - 1]);\n    let beta = 20 * Math.log10(-y[targetIndex]);\n    let gamma = 20 * Math.log10(-y[targetIndex + 1]);\n    let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);\n    return {\n      x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,\n      y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,\n      index: targetIndex,\n    };\n  } else {\n    return {\n      x: x[targetIndex],\n      y: y[targetIndex],\n      index: targetIndex,\n    };\n  }\n}\n\n/**\n * Find the closest minimum going down hill\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @return {{x,y,xIndex}} An object with the x/y value\n */\n\nfunction realMaxYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n  const targetIndex = getTargetIndex(x, options);\n  // interpolation to a sin() function\n  if (\n    y[targetIndex - 1] > 0 &&\n    y[targetIndex + 1] > 0 &&\n    y[targetIndex] >= y[targetIndex - 1] &&\n    y[targetIndex] >= y[targetIndex + 1]\n  ) {\n    let alpha = 20 * Math.log10(y[targetIndex - 1]);\n    let beta = 20 * Math.log10(y[targetIndex]);\n    let gamma = 20 * Math.log10(y[targetIndex + 1]);\n    let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);\n    return {\n      x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,\n      y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,\n      index: targetIndex,\n    };\n  } else {\n    return {\n      x: x[targetIndex],\n      y: y[targetIndex],\n      index: targetIndex,\n    };\n  }\n}\n\n/**\n * Finds all the max values\n * If the values are equal the middle\n * of the equal part will be the position of the signal!\n *\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @return {Array} Array of points\n */\n\nfunction maximaY(points = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 3) return [];\n  let maxima = [];\n  let startEqualIndex = -1;\n  for (let i = 1; i < x.length - 1; i++) {\n    if (y[i - 1] < y[i] && y[i + 1] < y[i]) {\n      maxima.push({ x: x[i], y: y[i], index: i });\n    } else if (y[i - 1] < y[i] && y[i + 1] === y[i]) {\n      startEqualIndex = i;\n    } else if (y[i - 1] === y[i] && y[i + 1] < y[i]) {\n      let index = ((i + startEqualIndex) / 2) >> 0;\n      maxima.push({ x: x[index], y: y[index], index });\n    }\n  }\n  return maxima;\n}\n\n/**\n * Finds all the min values\n * If the values are equal the middle\n * of the equal part will be the position of the signal!\n *\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @return {Array} Array of points\n */\n\nfunction minimaY(points = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 3) return [];\n  let maxima = [];\n  let startEqualIndex = -1;\n  for (let i = 1; i < x.length - 1; i++) {\n    if (y[i - 1] > y[i] && y[i + 1] > y[i]) {\n      maxima.push({ x: x[i], y: y[i], index: i });\n    } else if (y[i - 1] > y[i] && y[i + 1] === y[i]) {\n      startEqualIndex = i;\n    } else if (y[i - 1] === y[i] && y[i + 1] > y[i]) {\n      let index = ((i + startEqualIndex) / 2) >> 0;\n      maxima.push({ x: x[index], y: y[index], index });\n    }\n  }\n  return maxima;\n}\n\n/**\n * Returns an information about a signal\n *\n * We expect ordered data and equidistant X axis\n * You can use the method helper if required:\n * ML.ArrayXY.uniqueX\n * ML.ArrayXY.sortX\n * ML.ArrayXY.equallySpaced\n *\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex]\n * @return {object} Information about signal\n */\n\nfunction peakInfo(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 3) return undefined;\n  let { targetIndex, target } = options;\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      targetIndex = findClosestIndex(x, target);\n    }\n  }\n\n  if (targetIndex === undefined) {\n    throw new Error('peakInfo: need to specify target or targetIndex');\n  }\n\n  let i = targetIndex;\n  let currentDiff = y[i] - y[i + 1];\n\n  let multiplier = currentDiff < 0 ? -1 : 1;\n  currentDiff *= multiplier;\n  while (i < x.length - 1) {\n    i++;\n    let newDiff = (y[i] - y[i + 1]) * multiplier;\n    if (newDiff < currentDiff) break;\n    currentDiff = newDiff;\n  }\n  let after = { x: x[i], y: y[i] };\n\n  i = targetIndex;\n  currentDiff = (y[i] - y[i - 1]) * multiplier;\n  while (i > 1) {\n    i--;\n    let newDiff = (y[i] - y[i - 1]) * multiplier;\n    if (newDiff < currentDiff) break;\n    currentDiff = newDiff;\n  }\n  let before = { x: x[i], y: y[i] };\n\n  return {\n    inflectionBefore: before,\n    inflectionAfter: after,\n    extrema: { x: x[targetIndex], y: y[targetIndex] },\n    inflectionMiddle: {\n      x: (before.x + after.x) / 2,\n      y: (before.y + after.y) / 2,\n    },\n    width: Math.abs(before.x - after.x),\n  };\n}\n\nconst XY = {\n  check,\n  integral: integral$1,\n  integration,\n  maxY,\n  maximaY,\n  maxYPoint,\n  minimaY,\n  minYPoint,\n  reduce,\n  sortX,\n  minClosestYPoint,\n  maxClosestYPoint,\n  realMaxYPoint,\n  realMinYPoint,\n  peakInfo,\n};\n\n/**\n\n/**\n * This function add the first array by the second array or a constant value to each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction add(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] + constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] + array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n * This function subtract the first array by the second array or a constant value from each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @return {object}\n */\nfunction boxPlot(array) {\n  array = array.slice(0).sort((a, b) => a - b);\n  if (array.length < 5) {\n    throw Error(\n      'boxPlot: can not calculate info if array contains less than 3 elements',\n    );\n  }\n  let info = {\n    Q1: 0.0,\n    Q2: 0.0,\n    Q3: 0.0,\n    min: array[0],\n    max: array[array.length - 1],\n  };\n  let q1max, q3min;\n  if (array.length % 2 === 1) {\n    // odd\n    let middle = (array.length - 1) / 2;\n    info.Q2 = array[middle];\n    q1max = middle - 1;\n    q3min = middle + 1;\n  } else {\n    // even\n    q3min = array.length / 2;\n    q1max = q3min - 1;\n    info.Q2 = (array[q1max] + array[q3min]) / 2;\n  }\n  if (q1max % 2 === 0) {\n    info.Q1 = array[q1max / 2];\n    info.Q3 = array[(array.length + q3min - 1) / 2];\n  } else {\n    info.Q1 = (array[(q1max + 1) / 2] + array[(q1max - 1) / 2]) / 2;\n    let middleOver = (array.length + q3min) / 2;\n    info.Q3 = (array[middleOver] + array[middleOver - 1]) / 2;\n  }\n  return info;\n}\n\n/**\n\n/**\n * This function divide the first array by the second array or a constant value to each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction divide(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] / constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] / array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n\n/**\n * This function multiply the first array by the second array or a constant value to each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction multiply(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] * constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] * array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n * This function performs a circular shift to a new array\n * Positive values of shifts will shift to the right and negative values will do to the left\n * @example rotate([1,2,3,4],1) -> [4,1,2,3]\n * @example rotate([1,2,3,4],-1) -> [2,3,4,1]\n * @param {Array} array - the array that will be rotated\n * @param {number} shift\n * @return {Array}\n */\nfunction rotate(array, shift) {\n  shift = shift % array.length;\n  if (shift < 0) shift += array.length;\n  return array\n    .slice(array.length - shift)\n    .concat(array.slice(0, array.length - shift));\n}\n\n/**\n * This function subtract the first array by the second array or a constant value from each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction subtract(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] - constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] - array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n\n/**\n * Calculates the correlation between 2 vectors\n * https://en.wikipedia.org/wiki/Correlation_and_dependence\n *\n * @param {Array} [A] - the array that will be rotated\n * @param {Array} [B]\n * @return {Array}\n */\nfunction correlation(A, B) {\n  let n = A.length;\n  let sumA = 0;\n  let sumA2 = 0;\n  let sumB = 0;\n  let sumB2 = 0;\n  let sumAB = 0;\n  for (let i = 0; i < n; i++) {\n    let a = A[i];\n    let b = B[i];\n    sumA += a;\n    sumA2 += a ** 2;\n    sumB += b;\n    sumB2 += b ** 2;\n    sumAB += a * b;\n  }\n  return (\n    (n * sumAB - sumA * sumB) /\n    (Math.sqrt(n * sumA2 - sumA ** 2) * Math.sqrt(n * sumB2 - sumB ** 2))\n  );\n}\n\nconst X = {\n  add,\n  boxPlot,\n  divide,\n  findClosestIndex,\n  getTargetIndex,\n  multiply,\n  rotate,\n  subtract,\n  correlation,\n};\n\n/**\n *  @private\n * @param {*} spectrum\n * @param {*} ranges\n */\nfunction updateRangesInfo(spectrum, ranges = []) {\n  spectrum.ranges = {};\n  for (let range of ranges) {\n    range = JSON.parse(JSON.stringify(range));\n    spectrum.ranges[range.label] = range;\n    let fromToIndex = {\n      fromIndex: X.findClosestIndex(spectrum.normalized.x, range.from),\n      toIndex: X.findClosestIndex(spectrum.normalized.x, range.to),\n    };\n    range.integration = XY.integration(spectrum.normalized, fromToIndex);\n    range.maxPoint = XY.maxYPoint(spectrum.normalized, fromToIndex);\n  }\n}\n\n/**\n * Class allowing manipulate one IR spectrum\n * @class spectrum\n * @param {object} [json={}] - object containing a spectrum\n * @param {Array} [json.x=[]] - x values\n * @param {Array} [json.y=[]] - y values\n */\nclass Spectrum {\n  /**\n   *\n   * @param {array} x\n   * @param {array} y\n   * @param {string} id\n   * @param {object} [options={}]\n   * @param {object} [options.meta={}]\n   * @param {object} [options.normalization]\n   * @param {object} [options.normalized]\n   */\n  constructor(x, y, id, options = {}) {\n    const { meta = {}, normalization = {}, normalized } = options;\n\n    if (x && x.length > 1 && x[0] > x[1]) {\n      this.x = x.reverse();\n      this.y = y.reverse();\n    } else {\n      this.x = x || [];\n      this.y = y || [];\n    }\n    this.id = id;\n    this.meta = meta;\n    this.normalizedBoundary = { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };\n    if (normalized) {\n      this.normalized = normalized;\n      this.updateNormalizedBoundary();\n    } else {\n      this.updateNormalization(normalization);\n    }\n\n    this.updateMemory();\n  }\n\n  get minX() {\n    return this.x[0];\n  }\n\n  get maxX() {\n    return this.x[this.x.length - 1];\n  }\n\n  updateMemory() {\n    let original = ((this.x && this.x.length) || 0) * 16;\n    let normalized = this.normalized.x.length * 16;\n    this.memory = { original, normalized, total: original + normalized };\n  }\n\n  removeOriginal() {\n    this.x = undefined;\n    this.y = undefined;\n    this.updateMemory();\n  }\n\n  getXY() {\n    if (!Array.isArray(this.x) || !Array.isArray(this.y)) {\n      throw new Error('Can not get normalized data');\n    }\n    return { x: this.x, y: this.y };\n  }\n}\n\nSpectrum.prototype.getData = function(options) {\n  return getData(this, options);\n};\n\nSpectrum.prototype.updateNormalization = function(normalization) {\n  this.normalized = getNormalized(this, normalization);\n  this.ranges = {};\n  this.updateMemory();\n  this.updateNormalizedBoundary();\n};\n\nSpectrum.prototype.updateRangesInfo = function(ranges) {\n  updateRangesInfo(this, ranges);\n};\n\nSpectrum.prototype.updateNormalizedBoundary = function() {\n  this.normalizedBoundary.x = {\n    min: this.normalized.x[0],\n    max: this.normalized.x[this.normalized.x.length - 1],\n  };\n  this.normalizedBoundary.y = array_4(this.normalized.y);\n};\n\nfunction getConverter() {\n  // the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\n  const ntuplesSeparator = /[, \\t]+/;\n  const GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\n  function convertToFloatArray(stringArray) {\n    var floatArray = [];\n    for (let i = 0; i < stringArray.length; i++) {\n      floatArray.push(parseFloat(stringArray[i]));\n    }\n    return floatArray;\n  }\n\n  class Spectrum {}\n\n  const defaultOptions = {\n    keepRecordsRegExp: /^$/,\n    xy: false,\n    withoutXY: false,\n    chromatogram: false,\n    keepSpectra: false,\n    noContour: false,\n    nbContourLevels: 7,\n    noiseMultiplier: 5,\n    profiling: false\n  };\n\n  function convert(jcamp, options) {\n    options = Object.assign({}, defaultOptions, options);\n\n    var wantXY = !options.withoutXY;\n\n    var start = Date.now();\n\n    var ntuples = {};\n    var ldr, dataLabel, dataValue, ldrs;\n    var position, endLine, infos;\n\n    var result = {};\n    result.profiling = options.profiling ? [] : false;\n    result.logs = [];\n    var spectra = [];\n    result.spectra = spectra;\n    result.info = {};\n    var spectrum = new Spectrum();\n\n    if (!(typeof jcamp === 'string')) {\n      throw new TypeError('the JCAMP should be a string');\n    }\n\n    if (result.profiling) {\n      result.profiling.push({\n        action: 'Before split to LDRS',\n        time: Date.now() - start\n      });\n    }\n\n    ldrs = jcamp.split(/[\\r\\n]+##/);\n\n    if (result.profiling) {\n      result.profiling.push({\n        action: 'Split to LDRS',\n        time: Date.now() - start\n      });\n    }\n\n    if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n    for (let i = 0; i < ldrs.length; i++) {\n      ldr = ldrs[i];\n      // This is a new LDR\n      position = ldr.indexOf('=');\n      if (position > 0) {\n        dataLabel = ldr.substring(0, position);\n        dataValue = ldr.substring(position + 1).trim();\n      } else {\n        dataLabel = ldr;\n        dataValue = '';\n      }\n      dataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n      if (dataLabel === 'DATATABLE') {\n        endLine = dataValue.indexOf('\\n');\n        if (endLine === -1) endLine = dataValue.indexOf('\\r');\n        if (endLine > 0) {\n          var xIndex = -1;\n          var yIndex = -1;\n          // ##DATA TABLE= (X++(I..I)), XYDATA\n          // We need to find the variables\n\n          infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n          if (infos[0].indexOf('++') > 0) {\n            var firstVariable = infos[0].replace(\n              /.*\\(([a-zA-Z0-9]+)\\+\\+.*/,\n              '$1'\n            );\n            var secondVariable = infos[0].replace(\n              /.*\\.\\.([a-zA-Z0-9]+).*/,\n              '$1'\n            );\n            xIndex = ntuples.symbol.indexOf(firstVariable);\n            yIndex = ntuples.symbol.indexOf(secondVariable);\n          }\n\n          if (xIndex === -1) xIndex = 0;\n          if (yIndex === -1) yIndex = 0;\n\n          if (ntuples.first) {\n            if (ntuples.first.length > xIndex) {\n              spectrum.firstX = ntuples.first[xIndex];\n            }\n            if (ntuples.first.length > yIndex) {\n              spectrum.firstY = ntuples.first[yIndex];\n            }\n          }\n          if (ntuples.last) {\n            if (ntuples.last.length > xIndex) {\n              spectrum.lastX = ntuples.last[xIndex];\n            }\n            if (ntuples.last.length > yIndex) {\n              spectrum.lastY = ntuples.last[yIndex];\n            }\n          }\n          if (ntuples.vardim && ntuples.vardim.length > xIndex) {\n            spectrum.nbPoints = ntuples.vardim[xIndex];\n          }\n          if (ntuples.factor) {\n            if (ntuples.factor.length > xIndex) {\n              spectrum.xFactor = ntuples.factor[xIndex];\n            }\n            if (ntuples.factor.length > yIndex) {\n              spectrum.yFactor = ntuples.factor[yIndex];\n            }\n          }\n          if (ntuples.units) {\n            if (ntuples.units.length > xIndex) {\n              spectrum.xUnit = ntuples.units[xIndex];\n            }\n            if (ntuples.units.length > yIndex) {\n              spectrum.yUnit = ntuples.units[yIndex];\n            }\n          }\n          spectrum.datatable = infos[0];\n          if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n            dataLabel = 'PEAKTABLE';\n          } else if (\n            infos[1] &&\n            (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)\n          ) {\n            dataLabel = 'XYDATA';\n            spectrum.deltaX =\n              (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n          }\n        }\n      }\n\n      if (dataLabel === 'XYDATA') {\n        if (wantXY) {\n          prepareSpectrum(result, spectrum);\n          // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n          if (dataValue.match(/.*\\+\\+.*/)) {\n            // ex: (X++(Y..Y))\n            if (!spectrum.deltaX) {\n              spectrum.deltaX =\n                (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n            }\n            fastParseXYData(spectrum, dataValue);\n          } else {\n            parsePeakTable(spectrum, dataValue, result);\n          }\n          spectra.push(spectrum);\n          spectrum = new Spectrum();\n        }\n        continue;\n      } else if (dataLabel === 'PEAKTABLE') {\n        if (wantXY) {\n          prepareSpectrum(result, spectrum);\n          parsePeakTable(spectrum, dataValue, result);\n          spectra.push(spectrum);\n          spectrum = new Spectrum();\n        }\n        continue;\n      }\n      if (dataLabel === 'PEAKASSIGNMENTS') {\n        if (wantXY) {\n          if (dataValue.match(/.*(XYA).*/)) {\n            // ex: (XYA)\n            parseXYA(spectrum, dataValue);\n          }\n          spectra.push(spectrum);\n          spectrum = new Spectrum();\n        }\n        continue;\n      }\n\n      if (dataLabel === 'TITLE') {\n        spectrum.title = dataValue;\n      } else if (dataLabel === 'DATATYPE') {\n        spectrum.dataType = dataValue;\n        if (dataValue.indexOf('nD') > -1) {\n          result.twoD = true;\n        }\n      } else if (dataLabel === 'NTUPLES') {\n        if (dataValue.indexOf('nD') > -1) {\n          result.twoD = true;\n        }\n      } else if (dataLabel === 'XUNITS') {\n        spectrum.xUnit = dataValue;\n      } else if (dataLabel === 'YUNITS') {\n        spectrum.yUnit = dataValue;\n      } else if (dataLabel === 'FIRSTX') {\n        spectrum.firstX = parseFloat(dataValue);\n      } else if (dataLabel === 'LASTX') {\n        spectrum.lastX = parseFloat(dataValue);\n      } else if (dataLabel === 'FIRSTY') {\n        spectrum.firstY = parseFloat(dataValue);\n      } else if (dataLabel === 'LASTY') {\n        spectrum.lastY = parseFloat(dataValue);\n      } else if (dataLabel === 'NPOINTS') {\n        spectrum.nbPoints = parseFloat(dataValue);\n      } else if (dataLabel === 'XFACTOR') {\n        spectrum.xFactor = parseFloat(dataValue);\n      } else if (dataLabel === 'YFACTOR') {\n        spectrum.yFactor = parseFloat(dataValue);\n      } else if (dataLabel === 'MAXX') {\n        spectrum.maxX = parseFloat(dataValue);\n      } else if (dataLabel === 'MINX') {\n        spectrum.minX = parseFloat(dataValue);\n      } else if (dataLabel === 'MAXY') {\n        spectrum.maxY = parseFloat(dataValue);\n      } else if (dataLabel === 'MINY') {\n        spectrum.minY = parseFloat(dataValue);\n      } else if (dataLabel === 'DELTAX') {\n        spectrum.deltaX = parseFloat(dataValue);\n      } else if (dataLabel === '.OBSERVEFREQUENCY' || dataLabel === '$SFO1') {\n        if (!spectrum.observeFrequency) {\n          spectrum.observeFrequency = parseFloat(dataValue);\n        }\n      } else if (dataLabel === '.OBSERVENUCLEUS') {\n        if (!spectrum.xType) {\n          result.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n        }\n      } else if (dataLabel === '$SFO2') {\n        if (!result.indirectFrequency) {\n          result.indirectFrequency = parseFloat(dataValue);\n        }\n      } else if (dataLabel === '$OFFSET') {\n        // OFFSET for Bruker spectra\n        result.shiftOffsetNum = 0;\n        if (!spectrum.shiftOffsetVal) {\n          spectrum.shiftOffsetVal = parseFloat(dataValue);\n        }\n      } else if (dataLabel === '$REFERENCEPOINT') ; else if (dataLabel === 'VARNAME') {\n        ntuples.varname = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'SYMBOL') {\n        ntuples.symbol = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'VARTYPE') {\n        ntuples.vartype = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'VARFORM') {\n        ntuples.varform = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'VARDIM') {\n        ntuples.vardim = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'UNITS') {\n        ntuples.units = dataValue.split(ntuplesSeparator);\n      } else if (dataLabel === 'FACTOR') {\n        ntuples.factor = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'FIRST') {\n        ntuples.first = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'LAST') {\n        ntuples.last = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'MIN') {\n        ntuples.min = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === 'MAX') {\n        ntuples.max = convertToFloatArray(dataValue.split(ntuplesSeparator));\n      } else if (dataLabel === '.NUCLEUS') {\n        if (result.twoD) {\n          result.yType = dataValue.split(ntuplesSeparator)[0];\n        }\n      } else if (dataLabel === 'PAGE') {\n        spectrum.page = dataValue.trim();\n        spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n        spectrum.pageSymbol = spectrum.page.replace(/[=].*/, '');\n        var pageSymbolIndex = ntuples.symbol.indexOf(spectrum.pageSymbol);\n        var unit = '';\n        if (ntuples.units && ntuples.units[pageSymbolIndex]) {\n          unit = ntuples.units[pageSymbolIndex];\n        }\n        if (result.indirectFrequency && unit !== 'PPM') {\n          spectrum.pageValue /= result.indirectFrequency;\n        }\n      } else if (dataLabel === 'RETENTIONTIME') {\n        spectrum.pageValue = parseFloat(dataValue);\n      } else if (isMSField(dataLabel)) {\n        spectrum[convertMSFieldToLabel(dataLabel)] = dataValue;\n      } else if (dataLabel === 'SAMPLEDESCRIPTION') {\n        spectrum.sampleDescription = dataValue;\n      }\n      if (dataLabel.match(options.keepRecordsRegExp)) {\n        if (result.info[dataLabel]) {\n          if (!Array.isArray(result.info[dataLabel])) {\n            result.info[dataLabel] = [result.info[dataLabel]];\n          }\n          result.info[dataLabel].push(dataValue.trim());\n        } else {\n          result.info[dataLabel] = dataValue.trim();\n        }\n      }\n    }\n\n    if (result.profiling) {\n      result.profiling.push({\n        action: 'Finished parsing',\n        time: Date.now() - start\n      });\n    }\n\n    if (Object.keys(ntuples).length > 0) {\n      var newNtuples = [];\n      var keys = Object.keys(ntuples);\n      for (let i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var values = ntuples[key];\n        for (let j = 0; j < values.length; j++) {\n          if (!newNtuples[j]) newNtuples[j] = {};\n          newNtuples[j][key] = values[j];\n        }\n      }\n      result.ntuples = newNtuples;\n    }\n\n    if (result.twoD && wantXY) {\n      add2D(result, options);\n      if (result.profiling) {\n        result.profiling.push({\n          action: 'Finished countour plot calculation',\n          time: Date.now() - start\n        });\n      }\n      if (!options.keepSpectra) {\n        delete result.spectra;\n      }\n    }\n\n    if (options.chromatogram) {\n      options.xy = true;\n    }\n\n    if (options.xy && wantXY) {\n      // the spectraData should not be a oneD array but an object with x and y\n      if (spectra.length > 0) {\n        for (let i = 0; i < spectra.length; i++) {\n          spectrum = spectra[i];\n          if (spectrum.data.length > 0) {\n            for (let j = 0; j < spectrum.data.length; j++) {\n              var data = spectrum.data[j];\n              var newData = {\n                x: new Array(data.length / 2),\n                y: new Array(data.length / 2)\n              };\n              for (var k = 0; k < data.length; k = k + 2) {\n                newData.x[k / 2] = data[k];\n                newData.y[k / 2] = data[k + 1];\n              }\n              spectrum.data[j] = newData;\n            }\n          }\n        }\n      }\n    }\n\n    // maybe it is a GC (HPLC) / MS. In this case we add a new format\n    if (options.chromatogram) {\n      if (result.spectra.length > 1) {\n        complexChromatogram(result);\n      } else {\n        simpleChromatogram(result);\n      }\n      if (result.profiling) {\n        result.profiling.push({\n          action: 'Finished chromatogram calculation',\n          time: Date.now() - start\n        });\n      }\n    }\n\n    if (result.profiling) {\n      result.profiling.push({\n        action: 'Total time',\n        time: Date.now() - start\n      });\n    }\n\n    return result;\n  }\n\n  function convertMSFieldToLabel(value) {\n    return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n  }\n\n  function isMSField(dataLabel) {\n    return GC_MS_FIELDS.indexOf(dataLabel) !== -1;\n  }\n\n  function complexChromatogram(result) {\n    var spectra = result.spectra;\n    var length = spectra.length;\n    var chromatogram = {\n      times: new Array(length),\n      series: {\n        ms: {\n          dimension: 2,\n          data: new Array(length)\n        }\n      }\n    };\n\n    var existingGCMSFields = [];\n    for (let i = 0; i < GC_MS_FIELDS.length; i++) {\n      var label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n      if (spectra[0][label]) {\n        existingGCMSFields.push(label);\n        chromatogram.series[label] = {\n          dimension: 1,\n          data: new Array(length)\n        };\n      }\n    }\n\n    for (let i = 0; i < length; i++) {\n      var spectrum = spectra[i];\n      chromatogram.times[i] = spectrum.pageValue;\n      for (let j = 0; j < existingGCMSFields.length; j++) {\n        chromatogram.series[existingGCMSFields[j]].data[i] = parseFloat(\n          spectrum[existingGCMSFields[j]]\n        );\n      }\n      if (spectrum.data) {\n        chromatogram.series.ms.data[i] = [\n          spectrum.data[0].x,\n          spectrum.data[0].y\n        ];\n      }\n    }\n    result.chromatogram = chromatogram;\n  }\n\n  function simpleChromatogram(result) {\n    var data = result.spectra[0].data[0];\n    result.chromatogram = {\n      times: data.x.slice(),\n      series: {\n        intensity: {\n          dimension: 1,\n          data: data.y.slice()\n        }\n      }\n    };\n  }\n\n  function prepareSpectrum(result, spectrum) {\n    if (!spectrum.xFactor) spectrum.xFactor = 1;\n    if (!spectrum.yFactor) spectrum.yFactor = 1;\n    if (spectrum.observeFrequency) {\n      if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n        spectrum.xUnit = 'PPM';\n        spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n        spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n        spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n        spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n      }\n    }\n    if (spectrum.shiftOffsetVal) {\n      var shift = spectrum.firstX - spectrum.shiftOffsetVal;\n      spectrum.firstX = spectrum.firstX - shift;\n      spectrum.lastX = spectrum.lastX - shift;\n    }\n  }\n\n  function getMedian(data) {\n    data = data.sort(compareNumbers);\n    var l = data.length;\n    return data[Math.floor(l / 2)];\n  }\n\n  function compareNumbers(a, b) {\n    return a - b;\n  }\n\n  function convertTo3DZ(spectra) {\n    var minZ = spectra[0].data[0][0];\n    var maxZ = minZ;\n    var ySize = spectra.length;\n    var xSize = spectra[0].data[0].length / 2;\n    var z = new Array(ySize);\n    for (let i = 0; i < ySize; i++) {\n      z[i] = new Array(xSize);\n      var xVector = spectra[i].data[0];\n      for (let j = 0; j < xSize; j++) {\n        var value = xVector[j * 2 + 1];\n        z[i][j] = value;\n        if (value < minZ) minZ = value;\n        if (value > maxZ) maxZ = value;\n      }\n    }\n\n    const firstX = spectra[0].data[0][0];\n    const lastX = spectra[0].data[0][spectra[0].data[0].length - 2]; // has to be -2 because it is a 1D array [x,y,x,y,...]\n    const firstY = spectra[0].pageValue;\n    const lastY = spectra[ySize - 1].pageValue;\n\n    // Because the min / max value are the only information about the matrix if we invert\n    // min and max we need to invert the array\n    if (firstX > lastX) {\n      for (let spectrum of z) {\n        spectrum.reverse();\n      }\n    }\n    if (firstY > lastY) {\n      z.reverse();\n    }\n\n    return {\n      z: z,\n      minX: Math.min(firstX, lastX),\n      maxX: Math.max(firstX, lastX),\n      minY: Math.min(firstY, lastY),\n      maxY: Math.max(firstY, lastY),\n      minZ: minZ,\n      maxZ: maxZ,\n      noise: getMedian(z[0].map(Math.abs))\n    };\n  }\n\n  function add2D(result, options) {\n    var zData = convertTo3DZ(result.spectra);\n    if (!options.noContour) {\n      result.contourLines = generateContourLines(zData, options);\n      delete zData.z;\n    }\n    result.minMax = zData;\n  }\n\n  function generateContourLines(zData, options) {\n    var noise = zData.noise;\n    var z = zData.z;\n    var povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n    var isOver0, isOver1, isOver2, isOver3;\n    var nbSubSpectra = z.length;\n    var nbPovars = z[0].length;\n    var pAx, pAy, pBx, pBy;\n\n    var x0 = zData.minX;\n    var xN = zData.maxX;\n    var dx = (xN - x0) / (nbPovars - 1);\n    var y0 = zData.minY;\n    var yN = zData.maxY;\n    var dy = (yN - y0) / (nbSubSpectra - 1);\n    var minZ = zData.minZ;\n    var maxZ = zData.maxZ;\n\n    // System.out.prvarln('y0 '+y0+' yN '+yN);\n    // -------------------------\n    // Povars attribution\n    //\n    // 0----1\n    // |  / |\n    // | /  |\n    // 2----3\n    //\n    // ---------------------d------\n\n    var iter = options.nbContourLevels * 2;\n    var contourLevels = new Array(iter);\n    var lineZValue;\n    for (var level = 0; level < iter; level++) {\n      // multiply by 2 for positif and negatif\n      var contourLevel = {};\n      contourLevels[level] = contourLevel;\n      var side = level % 2;\n      var factor =\n        (maxZ - options.noiseMultiplier * noise) *\n        Math.exp((level >> 1) - options.nbContourLevels);\n      if (side === 0) {\n        lineZValue = factor + options.noiseMultiplier * noise;\n      } else {\n        lineZValue = 0 - factor - options.noiseMultiplier * noise;\n      }\n      var lines = [];\n      contourLevel.zValue = lineZValue;\n      contourLevel.lines = lines;\n\n      if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n      for (var iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n        var subSpectra = z[iSubSpectra];\n        var subSpectraAfter = z[iSubSpectra + 1];\n        for (var povar = 0; povar < nbPovars - 1; povar++) {\n          povarHeight0 = subSpectra[povar];\n          povarHeight1 = subSpectra[povar + 1];\n          povarHeight2 = subSpectraAfter[povar];\n          povarHeight3 = subSpectraAfter[povar + 1];\n\n          isOver0 = povarHeight0 > lineZValue;\n          isOver1 = povarHeight1 > lineZValue;\n          isOver2 = povarHeight2 > lineZValue;\n          isOver3 = povarHeight3 > lineZValue;\n\n          // Example povar0 is over the plane and povar1 and\n          // povar2 are below, we find the varersections and add\n          // the segment\n          if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n            pAx =\n              povar +\n              (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n            pAy = iSubSpectra;\n            pBx = povar;\n            pBy =\n              iSubSpectra +\n              (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n            lines.push(pAx * dx + x0);\n            lines.push(pAy * dy + y0);\n            lines.push(pBx * dx + x0);\n            lines.push(pBy * dy + y0);\n          }\n          // remove push does not help !!!!\n          if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n            pAx = povar + 1;\n            pAy =\n              iSubSpectra +\n              1 -\n              (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n            pBx =\n              povar +\n              1 -\n              (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n            pBy = iSubSpectra + 1;\n            lines.push(pAx * dx + x0);\n            lines.push(pAy * dy + y0);\n            lines.push(pBx * dx + x0);\n            lines.push(pBy * dy + y0);\n          }\n          // test around the diagonal\n          if (isOver1 !== isOver2) {\n            pAx =\n              (povar +\n                1 -\n                (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) *\n                dx +\n              x0;\n            pAy =\n              (iSubSpectra +\n                (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) *\n                dy +\n              y0;\n            if (isOver1 !== isOver0) {\n              pBx =\n                povar +\n                1 -\n                (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n              pBy = iSubSpectra;\n              lines.push(pAx);\n              lines.push(pAy);\n              lines.push(pBx * dx + x0);\n              lines.push(pBy * dy + y0);\n            }\n            if (isOver2 !== isOver0) {\n              pBx = povar;\n              pBy =\n                iSubSpectra +\n                1 -\n                (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n              lines.push(pAx);\n              lines.push(pAy);\n              lines.push(pBx * dx + x0);\n              lines.push(pBy * dy + y0);\n            }\n            if (isOver1 !== isOver3) {\n              pBx = povar + 1;\n              pBy =\n                iSubSpectra +\n                (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n              lines.push(pAx);\n              lines.push(pAy);\n              lines.push(pBx * dx + x0);\n              lines.push(pBy * dy + y0);\n            }\n            if (isOver2 !== isOver3) {\n              pBx =\n                povar +\n                (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n              pBy = iSubSpectra + 1;\n              lines.push(pAx);\n              lines.push(pAy);\n              lines.push(pBx * dx + x0);\n              lines.push(pBy * dy + y0);\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      minX: zData.minX,\n      maxX: zData.maxX,\n      minY: zData.minY,\n      maxY: zData.maxY,\n      segments: contourLevels\n    };\n  }\n\n  function fastParseXYData(spectrum, value) {\n    // TODO need to deal with result\n    //  console.log(value);\n    // we check if deltaX is defined otherwise we calculate it\n\n    var yFactor = spectrum.yFactor;\n    var deltaX = spectrum.deltaX;\n\n    spectrum.isXYdata = true;\n    // TODO to be improved using 2 array {x:[], y:[]}\n    var currentData = [];\n    spectrum.data = [currentData];\n\n    var currentX = spectrum.firstX;\n    var currentY = spectrum.firstY;\n\n    // we skip the first line\n    //\n    var endLine = false;\n    var ascii;\n    let i = 0;\n    for (; i < value.length; i++) {\n      ascii = value.charCodeAt(i);\n      if (ascii === 13 || ascii === 10) {\n        endLine = true;\n      } else {\n        if (endLine) break;\n      }\n    }\n\n    // we proceed taking the i after the first line\n    var newLine = true;\n    var isDifference = false;\n    var isLastDifference = false;\n    var lastDifference = 0;\n    var isDuplicate = false;\n    var inComment = false;\n    var currentValue = 0; // can be a difference or a duplicate\n    var lastValue = 0; // must be the real last value\n    var isNegative = false;\n    var inValue = false;\n    var skipFirstValue = false;\n    var decimalPosition = 0;\n    for (; i <= value.length; i++) {\n      if (i === value.length) ascii = 13;\n      else ascii = value.charCodeAt(i);\n      if (inComment) {\n        // we should ignore the text if we are after $$\n        if (ascii === 13 || ascii === 10) {\n          newLine = true;\n          inComment = false;\n        }\n      } else {\n        // when is it a new value ?\n        // when it is not a digit, . or comma\n        // it is a number that is either new or we continue\n        if (ascii <= 57 && ascii >= 48) {\n          // a number\n          inValue = true;\n          if (decimalPosition > 0) {\n            currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n          } else {\n            currentValue *= 10;\n            currentValue += ascii - 48;\n          }\n        } else if (ascii === 44 || ascii === 46) {\n          // a \",\" or \".\"\n          inValue = true;\n          decimalPosition++;\n        } else {\n          if (inValue) {\n            // need to process the previous value\n            if (newLine) {\n              newLine = false; // we don't check the X value\n              // console.log(\"NEW LINE\",isDifference, lastDifference);\n              // if new line and lastDifference, the first value is just a check !\n              // that we don't check ...\n              if (isLastDifference) skipFirstValue = true;\n            } else {\n              // need to deal with duplicate and differences\n              if (skipFirstValue) {\n                skipFirstValue = false;\n              } else {\n                if (isDifference) {\n                  lastDifference = isNegative ? 0 - currentValue : currentValue;\n                  isLastDifference = true;\n                  isDifference = false;\n                } else if (!isDuplicate) {\n                  lastValue = isNegative ? 0 - currentValue : currentValue;\n                }\n                var duplicate = isDuplicate ? currentValue - 1 : 1;\n                for (var j = 0; j < duplicate; j++) {\n                  if (isLastDifference) {\n                    currentY += lastDifference;\n                  } else {\n                    currentY = lastValue;\n                  }\n                  currentData.push(currentX);\n                  currentData.push(currentY * yFactor);\n                  currentX += deltaX;\n                }\n              }\n            }\n            isNegative = false;\n            currentValue = 0;\n            decimalPosition = 0;\n            inValue = false;\n            isDuplicate = false;\n          }\n\n          // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n          if (ascii < 74 && ascii > 63) {\n            inValue = true;\n            isLastDifference = false;\n            currentValue = ascii - 64;\n          } else if (ascii > 96 && ascii < 106) {\n            // negative SQZ digits a b c d e f g h i (ascii 97-105)\n            inValue = true;\n            isLastDifference = false;\n            currentValue = ascii - 96;\n            isNegative = true;\n          } else if (ascii === 115) {\n            // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n            inValue = true;\n            isDuplicate = true;\n            currentValue = 9;\n          } else if (ascii > 82 && ascii < 91) {\n            inValue = true;\n            isDuplicate = true;\n            currentValue = ascii - 82;\n          } else if (ascii > 73 && ascii < 83) {\n            // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n            inValue = true;\n            isDifference = true;\n            currentValue = ascii - 73;\n          } else if (ascii > 105 && ascii < 115) {\n            // negative DIF digits j k l m n o p q r (ascii 106-114)\n            inValue = true;\n            isDifference = true;\n            currentValue = ascii - 105;\n            isNegative = true;\n          } else if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n            // $ sign, we need to check the next one\n            inValue = true;\n            inComment = true;\n          } else if (ascii === 37) {\n            // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n            inValue = true;\n            isDifference = true;\n            currentValue = 0;\n            isNegative = false;\n          } else if (ascii === 45) {\n            // a \"-\"\n            // check if after there is a number, decimal or comma\n            var ascii2 = value.charCodeAt(i + 1);\n            if (\n              (ascii2 >= 48 && ascii2 <= 57) ||\n              ascii2 === 44 ||\n              ascii2 === 46\n            ) {\n              inValue = true;\n              if (!newLine) isLastDifference = false;\n              isNegative = true;\n            }\n          } else if (ascii === 13 || ascii === 10) {\n            newLine = true;\n            inComment = false;\n          }\n          // and now analyse the details ... space or tabulation\n          // if \"+\" we just don't care\n        }\n      }\n    }\n  }\n\n  function parseXYA(spectrum, value) {\n    var removeSymbolRegExp = /(\\(+|\\)+|<+|>+|\\s+)/g;\n\n    spectrum.isXYAdata = true;\n    var values;\n    var currentData = [];\n    spectrum.data = [currentData];\n\n    var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n    for (let i = 1; i < lines.length; i++) {\n      values = lines[i]\n        .trim()\n        .replace(removeSymbolRegExp, '')\n        .split(',');\n      currentData.push(parseFloat(values[0]));\n      currentData.push(parseFloat(values[1]));\n    }\n  }\n\n  function parsePeakTable(spectrum, value, result) {\n    var removeCommentRegExp = /\\$\\$.*/;\n    var peakTableSplitRegExp = /[,\\t ]+/;\n\n    spectrum.isPeaktable = true;\n    var values;\n    var currentData = [];\n    spectrum.data = [currentData];\n\n    // counts for around 20% of the time\n    var lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n    for (let i = 1; i < lines.length; i++) {\n      values = lines[i]\n        .trim()\n        .replace(removeCommentRegExp, '')\n        .split(peakTableSplitRegExp);\n      if (values.length % 2 === 0) {\n        for (let j = 0; j < values.length; j = j + 2) {\n          // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n          currentData.push(parseFloat(values[j]) * spectrum.xFactor);\n          currentData.push(parseFloat(values[j + 1]) * spectrum.yFactor);\n        }\n      } else {\n        result.logs.push(`Format error: ${values}`);\n      }\n    }\n  }\n\n  return convert;\n}\n\nvar convert = getConverter();\n\nfunction JcampConverter(input, options, useWorker) {\n  if (typeof options === 'boolean') {\n    useWorker = options;\n    options = {};\n  }\n  if (useWorker) {\n    return postToWorker(input, options);\n  } else {\n    return convert(input, options);\n  }\n}\n\nvar stamps = {};\nvar worker;\n\nfunction postToWorker(input, options) {\n  if (!worker) {\n    createWorker();\n  }\n  return new Promise(function (resolve) {\n    var stamp = `${Date.now()}${Math.random()}`;\n    stamps[stamp] = resolve;\n    worker.postMessage(\n      JSON.stringify({\n        stamp: stamp,\n        input: input,\n        options: options\n      })\n    );\n  });\n}\n\nfunction createWorker() {\n  var workerURL = URL.createObjectURL(\n    new Blob(\n      [`var getConverter =${getConverter.toString()};var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };`],\n      { type: 'application/javascript' }\n    )\n  );\n  worker = new Worker(workerURL);\n  URL.revokeObjectURL(workerURL);\n  worker.addEventListener('message', function (event) {\n    var data = JSON.parse(event.data);\n    var stamp = data.stamp;\n    if (stamps[stamp]) {\n      stamps[stamp](data.output);\n    }\n  });\n}\n\nfunction createTree(jcamp, options = {}) {\n  const { flatten = false } = options;\n  if (typeof jcamp !== 'string') {\n    throw new TypeError('the JCAMP should be a string');\n  }\n\n  let lines = jcamp.split(/[\\r\\n]+/);\n  let flat = [];\n  let stack = [];\n  let result = [];\n  let current;\n  let ntupleLevel = 0;\n\n  let spaces = jcamp.includes('## ');\n\n  for (var i = 0; i < lines.length; i++) {\n    let line = lines[i];\n    let labelLine = spaces ? line.replace(/ /g, '') : line;\n\n    if (labelLine.substring(0, 9) === '##NTUPLES') {\n      ntupleLevel++;\n    }\n\n    if (labelLine.substring(0, 7) === '##TITLE') {\n      let title = [labelLine.substring(8).trim()];\n      for (let j = i + 1; j < lines.length; j++) {\n        if (lines[j].startsWith('##')) {\n          break;\n        } else {\n          title.push(lines[j].trim());\n        }\n      }\n      stack.push({\n        title: title.join('\\n'),\n        jcamp: `${line}\\n`,\n        children: []\n      });\n      current = stack[stack.length - 1];\n      flat.push(current);\n    } else if (labelLine.substring(0, 5) === '##END' && ntupleLevel === 0) {\n      current.jcamp += `${line}\\n`;\n      var finished = stack.pop();\n      if (stack.length !== 0) {\n        current = stack[stack.length - 1];\n        current.children.push(finished);\n      } else {\n        current = undefined;\n        result.push(finished);\n      }\n    } else if (current && current.jcamp) {\n      current.jcamp += `${line}\\n`;\n      var match = labelLine.match(/^##(.*?)=(.+)/);\n      if (match) {\n        var dataLabel = match[1].replace(/[ _-]/g, '').toUpperCase();\n        if (dataLabel === 'DATATYPE') {\n          current.dataType = match[2].trim();\n        }\n      }\n    }\n\n    if (labelLine.substring(0, 5) === '##END' && ntupleLevel > 0) {\n      ntupleLevel--;\n    }\n  }\n  if (flatten) {\n    flat.forEach((entry) => {\n      entry.children = undefined;\n    });\n    return flat;\n  } else {\n    return result;\n  }\n}\n\nvar src$1 = {\n  convert: JcampConverter,\n  createTree: createTree\n};\nvar src_1 = src$1.convert;\n\nfunction getJcampKind(data) {\n  let datatype = data.spectra[0].dataType.toLowerCase();\n  let yUnit = data.spectra[0].yUnit.toLowerCase();\n\n  if (datatype.match(/infrared/)) {\n    if (yUnit.match(/absorbance/)) {\n      return IR_ABSORBANCE;\n    } else {\n      return IR_TRANSMITTANCE;\n    }\n  }\n  return undefined;\n}\n\nconst IR_TRANSMITTANCE = {\n  normalization: {},\n  importation: {\n    converter: (transmittance) => -Math.log10(transmittance),\n  },\n  kind: 'Infrared',\n  display: {\n    xLabel: 'wavelength [cm-1]',\n    xInverted: true,\n    yLabel: 'Absorbance',\n  },\n};\n\nconst IR_ABSORBANCE = {\n  normalization: {},\n  kind: 'Infrared',\n  display: {\n    xLabel: 'wavelength [cm-1]',\n    xInverted: true,\n    yLabel: 'Absorbance',\n  },\n};\n\n/**\n * Create a spectrum from a jcamp\n * @param {string} jcamp - String containing the JCAMP data\n * @return {Spectrum} - new instance of Spectrum with the provided data\n */\nfunction jcamp(jcamp) {\n  const parsed = src_1(jcamp, { xy: true, keepRecordsRegExp: /TITLE/ });\n  const kind = getJcampKind(parsed);\n  const data = parsed.spectra[0].data[0];\n  const meta = parsed.info;\n  // we convert the data\n  if (kind && kind.importation && kind.importation.converter) {\n    data.y = data.y.map(kind.importation.converter);\n  }\n\n  return { data, kind, meta };\n}\n\n/**\n * In place modification of the 2 arrays to make X unique and sum the Y if X has the same value\n * @param {object} [points={}] : Object of points contains property x (an array) and y (an array)\n * @return points\n */\n\nfunction uniqueX(points = {}) {\n  const { x, y } = points;\n  if (x.length < 2) return;\n  if (x.length !== y.length) {\n    throw new Error('The X and Y arrays mush have the same length');\n  }\n\n  let current = x[0];\n  let counter = 0;\n\n  for (let i = 1; i < x.length; i++) {\n    if (current !== x[i]) {\n      counter++;\n      current = x[i];\n      x[counter] = x[i];\n      if (i !== counter) {\n        y[counter] = 0;\n      }\n    }\n    if (i !== counter) {\n      y[counter] += y[i];\n    }\n  }\n\n  x.length = counter + 1;\n  y.length = counter + 1;\n}\n\n/**\n * Parse a text-file and convert it to an array of XY points\n * @param {string} text - csv or tsv strings\n * @param {object} [options={}]\n * @param {boolean} [options.rescale = false] - will set the maximum value to 1\n * @param {boolean} [options.uniqueX = false] - Make the X values unique (works only with 'xxyy' format). If the X value is repeated the sum of Y is done.\n * @param {number} [options.xColumn = 0] - A number that specifies the x column\n * @param {number} [options.yColumn = 1] - A number that specifies the y column\n * @param {number} [options.maxNumberColumns = (Math.max(xColumn, yColumn)+1)] - A number that specifies the maximum number of y columns\n * @param {number} [options.minNumberColumns = (Math.min(xColumn, yColumn)+1)] - A number that specifies the minimum number of y columns\n * @param {boolean} [options.keepInfo = false] - shoud we keep the non numeric lines. In this case the system will return an object {data, info}\n * @return {object{x:<Array<number>>,y:<Array<number>>}\n */\nfunction parseXY(text, options = {}) {\n  let {\n    rescale = false,\n    uniqueX: uniqueX$1 = false,\n    xColumn = 0,\n    yColumn = 1,\n    keepInfo = false,\n    maxNumberColumns = Number.MAX_SAFE_INTEGER,\n    minNumberColumns = 2,\n  } = options;\n\n  maxNumberColumns = Math.max(maxNumberColumns, xColumn + 1, yColumn + 1);\n  minNumberColumns = Math.max(xColumn + 1, yColumn + 1, minNumberColumns);\n\n  let lines = text.split(/[\\r\\n]+/);\n\n  let maxY = Number.MIN_VALUE;\n  let result = { x: [], y: [] };\n  let info = [];\n  for (let l = 0; l < lines.length; l++) {\n    let line = lines[l].trim();\n    // we will consider only lines that contains only numbers\n    if (line.match(/[0-9]+/) && line.match(/^[0-9eE,;. \\t+-]+$/)) {\n      let fields = line.split(/,[; \\t]+|[; \\t]+/);\n      if (fields.length === 1) {\n        fields = line.split(/[,; \\t]+/);\n      }\n      if (\n        fields &&\n        fields.length >= minNumberColumns &&\n        fields.length <= maxNumberColumns\n      ) {\n        let x = parseFloat(fields[xColumn].replace(',', '.'));\n        let y = parseFloat(fields[yColumn].replace(',', '.'));\n\n        if (y > maxY) maxY = y;\n        result.x.push(x);\n        result.y.push(y);\n      }\n    } else if (line) {\n      info.push({ position: result.x.length, value: line });\n    }\n  }\n\n  if (uniqueX$1) {\n    uniqueX(result);\n  }\n\n  if (rescale) {\n    for (let i = 0; i < result.y.length; i++) {\n      result.y[i] /= maxY;\n    }\n  }\n\n  if (!keepInfo) return result;\n\n  return {\n    info,\n    data: result,\n  };\n}\n\n/**\n * Create a spectrum from a text file\n * @param {string} text - String containing the JCAMP data\n * @return {Spectrum} - new instance of Spectrum with the provided data\n */\nfunction text(text, options = {}) {\n  const { kind, parserOptions = {} } = options;\n\n  const data = parseXY(text, parserOptions);\n\n  // we convert the data\n  if (kind && kind.importation && kind.importation.converter) {\n    data.y = data.y.map(kind.importation.converter);\n  }\n\n  return { data };\n}\n\n/**\n * Creates a g\n * @param {string} text - String containing the text data\n * @param {object} [options={}]\n * @param {string} [options.fs='\\t'] Field separator\n * @return {object} - {matrix, data, x, ids}\n */\nfunction matrix(text, options = {}) {\n  const lines = text.split(/[\\r\\n]+/).filter((value) => value);\n  const { fs = '\\t' } = options;\n  let matrix = [];\n  let ids = [];\n  let meta = [];\n  let x = [];\n\n  let headers = lines[0].split(fs);\n  let labels = [];\n\n  for (let i = 0; i < headers.length; i++) {\n    let header = headers[i];\n    if (isNaN(header)) {\n      labels[i] = header;\n    } else {\n      x = headers.slice(i).map((value) => Number(value));\n      break;\n    }\n  }\n\n  for (let i = 1; i < lines.length; i++) {\n    let line = lines[i];\n    let parts = line.split('\\t');\n    ids.push(parts[0]);\n    let oneMeta = {};\n    meta.push(oneMeta);\n    for (let j = 1; j < parts.length; j++) {\n      if (j < labels.length) {\n        oneMeta[labels[j]] = parts[j];\n      } else {\n        matrix.push(parts.slice(labels.length).map((value) => Number(value)));\n        break;\n      }\n    }\n  }\n  return { x, meta, matrix, ids };\n}\n\nfunction getNormalizationAnnotations(filter = {}, boundary) {\n  let { exclusions = [] } = filter;\n  let annotations = [];\n  exclusions = exclusions.filter((exclusion) => !exclusion.ignore);\n  annotations = exclusions.map((exclusion) => {\n    let annotation = {\n      type: 'rect',\n      position: [\n        { x: exclusion.from, y: boundary.y.min },\n        { x: exclusion.to, y: boundary.y.max },\n      ],\n      strokeWidth: 0,\n      fillColor: 'rgba(255,255,224,1)',\n    };\n    return annotation;\n  });\n  if (filter.from !== undefined) {\n    annotations.push({\n      type: 'rect',\n      position: [\n        { x: 0, y: boundary.y.min },\n        { x: filter.from, y: boundary.y.max },\n      ],\n      strokeWidth: 0,\n      fillColor: 'rgba(255,255,224,1)',\n    });\n  }\n  if (filter.to !== undefined) {\n    annotations.push({\n      type: 'rect',\n      position: [\n        { x: filter.to, y: boundary.y.min },\n        { x: 10000, y: boundary.y.max },\n      ],\n      strokeWidth: 0,\n      fillColor: 'rgba(255,255,224,1)',\n    });\n  }\n  return annotations;\n}\n\n/**\n * @private\n * @param {*} spectra\n */\n\nfunction getBoxPlotData(spectra) {\n  let matrix = [];\n  let x = spectra[0].normalized.x;\n  for (let spectrum of spectra) {\n    matrix.push(spectrum.normalized.y);\n  }\n\n  let nbRow = matrix.length;\n  let nbColumn = matrix[0].length;\n  let result;\n  let aColumn = new Float64Array(nbRow);\n  for (let column = 0; column < nbColumn; column++) {\n    for (let row = 0; row < nbRow; row++) {\n      aColumn[row] = matrix[row][column];\n    }\n    let info = X.boxPlot(aColumn);\n    if (!result) {\n      result = { x };\n      for (let key in info) {\n        result[key] = [];\n      }\n    }\n    for (let key in info) {\n      result[key].push(info[key]);\n    }\n  }\n  return result;\n}\n\nfunction getBoxPlotAnnotations(spectra, options = {}) {\n  const {\n    q13FillColor = '#000',\n    q13FillOpacity = 0.3,\n    q2StrokeColor = '#000',\n    q2StrokeWidth = 3,\n    minMaxFillColor = '#000',\n    minMaxFillOpacity = 0.15,\n  } = options;\n  let annotations = [];\n\n  let data = getBoxPlotData(spectra);\n  if (q13FillOpacity && q13FillColor) {\n    let q13 = [];\n    for (let i = 0; i < data.x.length; i++) {\n      q13.push({\n        x: data.x[i],\n        y: data.Q1[i],\n      });\n    }\n    for (let i = data.x.length - 1; i >= 0; i--) {\n      q13.push({\n        x: data.x[i],\n        y: data.Q3[i],\n      });\n    }\n    annotations.push({\n      type: 'polygon',\n      layer: 0,\n      properties: {\n        fillColor: q13FillColor,\n        fillOpacity: q13FillOpacity,\n        strokeWidth: 0.0000001,\n        position: q13,\n      },\n    });\n  }\n\n  if (q2StrokeColor && q2StrokeWidth) {\n    let q2 = [];\n    for (let i = 0; i < data.x.length; i++) {\n      q2.push({\n        x: data.x[i],\n        y: data.Q2[i],\n      });\n    }\n    // Temp code because polyline is not working\n    for (let i = data.x.length - 1; i >= 0; i--) {\n      q2.push({\n        x: data.x[i],\n        y: data.Q2[i],\n      });\n    }\n\n    annotations.push({\n      type: 'polygon',\n      layer: 0,\n      properties: {\n        strokeWidth: q2StrokeWidth,\n        strokeColor: q2StrokeColor,\n        position: q2,\n      },\n    });\n  }\n\n  if (minMaxFillColor && minMaxFillOpacity) {\n    let minMax = [];\n    for (let i = 0; i < data.x.length; i++) {\n      minMax.push({\n        x: data.x[i],\n        y: data.min[i],\n      });\n    }\n    for (let i = data.x.length - 1; i >= 0; i--) {\n      minMax.push({\n        x: data.x[i],\n        y: data.max[i],\n      });\n    }\n\n    annotations.push({\n      type: 'polygon',\n      layer: 0,\n      properties: {\n        fillColor: minMaxFillColor,\n        fillOpacity: minMaxFillOpacity,\n        strokeWidth: 0.0000001,\n        strokeColor: '#FFF',\n        position: minMax,\n      },\n    });\n  }\n\n  return annotations;\n}\n\nfunction addChartDataStyle(data, spectrum) {\n  data.styles = {\n    unselected: {\n      lineColor: spectrum.meta.color || 'darkgrey',\n      lineWidth: 1,\n      lineStyle: 1,\n    },\n    selected: {\n      lineColor: spectrum.meta.color || 'darkgrey',\n      lineWidth: 3,\n      lineStyle: 1,\n    },\n  };\n  data.label = spectrum.meta.id || spectrum.id;\n}\n\n/**\n * Retrieve a chart with selected original data\n * @param {object} [options={}]\n * @param {Array} [options.ids] List of spectra ids, by default all\n * @param {Array} [options.maxDataPoints=]\n */\nfunction getChart(spectra, options = {}) {\n  const { ids } = options;\n  let chart = {\n    data: [],\n  };\n  for (let spectrum of spectra) {\n    if (!ids || ids.includes(spectrum.id)) {\n      let data = spectrum.getData();\n      addChartDataStyle(data, spectrum);\n      chart.data.push(data);\n    }\n  }\n  return chart;\n}\n\n/**\n * @private\n * @param {*} spectra\n * @param {*} options\n */\n\nfunction getNormalizedData(spectra, options = {}) {\n  const { ids } = options;\n  if (!spectra || !spectra[0]) return {};\n  let matrix = [];\n  let meta = [];\n  let currentIDs = [];\n\n  for (let spectrum of spectra) {\n    if (!ids || ids.includes(spectrum.id)) {\n      currentIDs.push(spectrum.id);\n      matrix.push(spectrum.normalized.y);\n      meta.push(spectrum.meta);\n    }\n  }\n  let x = spectra[0].normalized.x;\n  return { ids: currentIDs, matrix, meta, x };\n}\n\nfunction getTrackAnnotation(spectra, index, options = {}) {\n  const { ids } = options;\n  let annotations = [];\n\n  let normalized = getNormalizedData(spectra, { ids });\n\n  if (normalized.ids.length === 0) return annotations;\n  let line = 0;\n\n  // header containing X coordinate\n  annotations.push({\n    type: 'line',\n    position: [\n      { x: `${70}px`, y: `${15 + 15 * line}px` },\n      { x: `${85}px`, y: `${15 + 15 * line}px` },\n    ],\n    strokeWidth: 0.0000001,\n    label: {\n      size: 16,\n      text: `x: ${normalized.x[index].toPrecision(6)}`,\n      position: { x: `${130}px`, y: `${20 + 15 * line}px` },\n    },\n  });\n  line++;\n\n  for (let i = 0; i < normalized.ids.length; i++) {\n    let id = normalized.ids[i];\n    let meta = normalized.meta[i];\n    let y = normalized.matrix[i][index];\n    annotations.push({\n      type: 'line',\n      position: [\n        { x: `${70}px`, y: `${15 + 15 * line}px` },\n        { x: `${85}px`, y: `${15 + 15 * line}px` },\n      ],\n      strokeColor: meta.color,\n      strokeWidth: 2,\n      label: {\n        text: `${y.toPrecision(4)} - ${id}`,\n        position: { x: `${90}px`, y: `${20 + 15 * line}px` },\n      },\n    });\n    line++;\n  }\n\n  return annotations;\n}\n\nfunction getNormalizedChart(spectra, options = {}) {\n  const { ids } = options;\n  let chart = {\n    data: [],\n  };\n  for (let spectrum of spectra) {\n    if (!ids || ids.includes(spectrum.id)) {\n      let data = spectrum.normalized;\n      addChartDataStyle(data, spectrum);\n      chart.data.push(data);\n    }\n  }\n  return chart;\n}\n\n/**\n *\n * @param {SpectraProcessor} spectraProcessor\n * @param {object} [options={}] scale spectra based on various parameters\n * @param {object} [options.range] from - to\n * @param {Array} [options.ids] ids of selected spectra\n * @param {string} [options.targetID=spectra[0].id]\n * @param {string} [options.method='max'] min, max, range, minMax\n * @param {boolean} [options.relative=false]\n */\nfunction getScaledChart(spectraProcessor, options = {}) {\n  let scaled = spectraProcessor.getScaledData(options);\n\n  let chart = {\n    data: [],\n  };\n\n  for (let i = 0; i < scaled.matrix.length; i++) {\n    let data = {\n      x: scaled.x,\n      y: scaled.matrix[i],\n    };\n    addChartDataStyle(data, { meta: scaled.meta[i], id: scaled.ids[i] });\n    chart.data.push(data);\n  }\n\n  return chart;\n}\n\n/**\n * @private\n */\n\nfunction getAutocorrelation(normalized, index) {\n  let matrix = normalized.matrix;\n  let nbRow = matrix.length;\n  let nbColumn = matrix[0].length;\n  let array1 = new Float64Array(nbRow);\n  let array2 = new Float64Array(nbRow);\n  let result = new Array(nbColumn);\n  for (let j = 0; j < nbRow; j++) {\n    array1[j] = matrix[j][index];\n  }\n  for (let i = 0; i < nbColumn; i++) {\n    for (let j = 0; j < nbRow; j++) {\n      array2[j] = matrix[j][i];\n    }\n    result[i] = X.correlation(array1, array2);\n  }\n  return {\n    x: normalized.x,\n    y: result,\n  };\n}\n\n/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nfunction checkRowIndex(matrix, index, outer) {\n  let max = outer ? matrix.rows : matrix.rows - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Row index out of range');\n  }\n}\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nfunction checkColumnIndex(matrix, index, outer) {\n  let max = outer ? matrix.columns : matrix.columns - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Column index out of range');\n  }\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nfunction checkRowVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.columns) {\n    throw new RangeError(\n      'vector size must be the same as the number of columns',\n    );\n  }\n  return vector;\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nfunction checkColumnVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.rows) {\n    throw new RangeError('vector size must be the same as the number of rows');\n  }\n  return vector;\n}\n\nfunction checkIndices(matrix, rowIndices, columnIndices) {\n  return {\n    row: checkRowIndices(matrix, rowIndices),\n    column: checkColumnIndices(matrix, columnIndices),\n  };\n}\n\nfunction checkRowIndices(matrix, rowIndices) {\n  if (typeof rowIndices !== 'object') {\n    throw new TypeError('unexpected type for row indices');\n  }\n\n  let rowOut = rowIndices.some((r) => {\n    return r < 0 || r >= matrix.rows;\n  });\n\n  if (rowOut) {\n    throw new RangeError('row indices are out of range');\n  }\n\n  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n\n  return rowIndices;\n}\n\nfunction checkColumnIndices(matrix, columnIndices) {\n  if (typeof columnIndices !== 'object') {\n    throw new TypeError('unexpected type for column indices');\n  }\n\n  let columnOut = columnIndices.some((c) => {\n    return c < 0 || c >= matrix.columns;\n  });\n\n  if (columnOut) {\n    throw new RangeError('column indices are out of range');\n  }\n  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);\n\n  return columnIndices;\n}\n\nfunction checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n  if (arguments.length !== 5) {\n    throw new RangeError('expected 4 arguments');\n  }\n  checkNumber('startRow', startRow);\n  checkNumber('endRow', endRow);\n  checkNumber('startColumn', startColumn);\n  checkNumber('endColumn', endColumn);\n  if (\n    startRow > endRow ||\n    startColumn > endColumn ||\n    startRow < 0 ||\n    startRow >= matrix.rows ||\n    endRow < 0 ||\n    endRow >= matrix.rows ||\n    startColumn < 0 ||\n    startColumn >= matrix.columns ||\n    endColumn < 0 ||\n    endColumn >= matrix.columns\n  ) {\n    throw new RangeError('Submatrix indices are out of range');\n  }\n}\n\nfunction newArray(length, value = 0) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array.push(value);\n  }\n  return array;\n}\n\nfunction checkNumber(name, value) {\n  if (typeof value !== 'number') {\n    throw new TypeError(`${name} must be a number`);\n  }\n}\n\nfunction sumByRow(matrix) {\n  let sum = newArray(matrix.rows);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction sumByColumn(matrix) {\n  let sum = newArray(matrix.columns);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction sumAll(matrix) {\n  let v = 0;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v += matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nfunction productByRow(matrix) {\n  let sum = newArray(matrix.rows, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction productByColumn(matrix) {\n  let sum = newArray(matrix.columns, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction productAll(matrix) {\n  let v = 1;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v *= matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nfunction varianceByRow(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let i = 0; i < rows; i++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean[i];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / cols) / cols);\n    }\n  }\n  return variance;\n}\n\nfunction varianceByColumn(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let j = 0; j < cols; j++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let i = 0; i < rows; i++) {\n      x = matrix.get(i, j) - mean[j];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / rows) / rows);\n    }\n  }\n  return variance;\n}\n\nfunction varianceAll(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const size = rows * cols;\n\n  let sum1 = 0;\n  let sum2 = 0;\n  let x = 0;\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean;\n      sum1 += x;\n      sum2 += x * x;\n    }\n  }\n  if (unbiased) {\n    return (sum2 - (sum1 * sum1) / size) / (size - 1);\n  } else {\n    return (sum2 - (sum1 * sum1) / size) / size;\n  }\n}\n\nfunction centerByRow(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[i]);\n    }\n  }\n}\n\nfunction centerByColumn(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[j]);\n    }\n  }\n}\n\nfunction centerAll(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean);\n    }\n  }\n}\n\nfunction getScaleByRow(matrix) {\n  const scale = [];\n  for (let i = 0; i < matrix.rows; i++) {\n    let sum = 0;\n    for (let j = 0; j < matrix.columns; j++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nfunction scaleByRow(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[i]);\n    }\n  }\n}\n\nfunction getScaleByColumn(matrix) {\n  const scale = [];\n  for (let j = 0; j < matrix.columns; j++) {\n    let sum = 0;\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nfunction scaleByColumn(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[j]);\n    }\n  }\n}\n\nfunction getScaleAll(matrix) {\n  const divider = matrix.size - 1;\n  let sum = 0;\n  for (let j = 0; j < matrix.columns; j++) {\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / divider;\n    }\n  }\n  return Math.sqrt(sum);\n}\n\nfunction scaleAll(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale);\n    }\n  }\n}\n\nfunction inspectMatrix() {\n  const indent = ' '.repeat(2);\n  const indentData = ' '.repeat(4);\n  return `${this.constructor.name} {\n${indent}[\n${indentData}${inspectData(this, indentData)}\n${indent}]\n${indent}rows: ${this.rows}\n${indent}columns: ${this.columns}\n}`;\n}\n\nconst maxRows = 15;\nconst maxColumns = 10;\nconst maxNumSize = 8;\n\nfunction inspectData(matrix, indent) {\n  const { rows, columns } = matrix;\n  const maxI = Math.min(rows, maxRows);\n  const maxJ = Math.min(columns, maxColumns);\n  const result = [];\n  for (let i = 0; i < maxI; i++) {\n    let line = [];\n    for (let j = 0; j < maxJ; j++) {\n      line.push(formatNumber(matrix.get(i, j)));\n    }\n    result.push(`${line.join(' ')}`);\n  }\n  if (maxJ !== columns) {\n    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;\n  }\n  if (maxI !== rows) {\n    result.push(`... ${rows - maxRows} more rows`);\n  }\n  return result.join(`\\n${indent}`);\n}\n\nfunction formatNumber(num) {\n  const numStr = String(num);\n  if (numStr.length <= maxNumSize) {\n    return numStr.padEnd(maxNumSize, ' ');\n  }\n  const precise = num.toPrecision(maxNumSize - 2);\n  if (precise.length <= maxNumSize) {\n    return precise;\n  }\n  const exponential = num.toExponential(maxNumSize - 2);\n  const eIndex = exponential.indexOf('e');\n  const e = exponential.substring(eIndex);\n  return exponential.substring(0, maxNumSize - e.length) + e;\n}\n\nfunction installMathOperations(AbstractMatrix, Matrix) {\n  AbstractMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number') return this.addS(value);\n    return this.addM(value);\n  };\n\n  AbstractMatrix.prototype.addS = function addS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.addM = function addM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.add = function add(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.add(value);\n  };\n\n  AbstractMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number') return this.subS(value);\n    return this.subM(value);\n  };\n\n  AbstractMatrix.prototype.subS = function subS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.subM = function subM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sub = function sub(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sub(value);\n  };\n  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;\n  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;\n  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;\n  AbstractMatrix.subtract = AbstractMatrix.sub;\n\n  AbstractMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number') return this.mulS(value);\n    return this.mulM(value);\n  };\n\n  AbstractMatrix.prototype.mulS = function mulS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.mulM = function mulM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mul = function mul(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mul(value);\n  };\n  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;\n  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;\n  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;\n  AbstractMatrix.multiply = AbstractMatrix.mul;\n\n  AbstractMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number') return this.divS(value);\n    return this.divM(value);\n  };\n\n  AbstractMatrix.prototype.divS = function divS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.divM = function divM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.div = function div(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.div(value);\n  };\n  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;\n  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;\n  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;\n  AbstractMatrix.divide = AbstractMatrix.div;\n\n  AbstractMatrix.prototype.mod = function mod(value) {\n    if (typeof value === 'number') return this.modS(value);\n    return this.modM(value);\n  };\n\n  AbstractMatrix.prototype.modS = function modS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.modM = function modM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mod = function mod(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mod(value);\n  };\n  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;\n  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;\n  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;\n  AbstractMatrix.modulus = AbstractMatrix.mod;\n\n  AbstractMatrix.prototype.and = function and(value) {\n    if (typeof value === 'number') return this.andS(value);\n    return this.andM(value);\n  };\n\n  AbstractMatrix.prototype.andS = function andS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.andM = function andM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.and = function and(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.and(value);\n  };\n\n  AbstractMatrix.prototype.or = function or(value) {\n    if (typeof value === 'number') return this.orS(value);\n    return this.orM(value);\n  };\n\n  AbstractMatrix.prototype.orS = function orS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.orM = function orM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.or = function or(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.or(value);\n  };\n\n  AbstractMatrix.prototype.xor = function xor(value) {\n    if (typeof value === 'number') return this.xorS(value);\n    return this.xorM(value);\n  };\n\n  AbstractMatrix.prototype.xorS = function xorS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.xorM = function xorM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.xor = function xor(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.xor(value);\n  };\n\n  AbstractMatrix.prototype.leftShift = function leftShift(value) {\n    if (typeof value === 'number') return this.leftShiftS(value);\n    return this.leftShiftM(value);\n  };\n\n  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.leftShift = function leftShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.leftShift(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {\n    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);\n    return this.signPropagatingRightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.signPropagatingRightShift(value);\n  };\n\n  AbstractMatrix.prototype.rightShift = function rightShift(value) {\n    if (typeof value === 'number') return this.rightShiftS(value);\n    return this.rightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.rightShift = function rightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.rightShift(value);\n  };\n  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;\n  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;\n  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;\n  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;\n\n  AbstractMatrix.prototype.not = function not() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, ~(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.not = function not(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.not();\n  };\n\n  AbstractMatrix.prototype.abs = function abs() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.abs(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.abs = function abs(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.abs();\n  };\n\n  AbstractMatrix.prototype.acos = function acos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acos = function acos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acos();\n  };\n\n  AbstractMatrix.prototype.acosh = function acosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acosh = function acosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acosh();\n  };\n\n  AbstractMatrix.prototype.asin = function asin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asin = function asin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asin();\n  };\n\n  AbstractMatrix.prototype.asinh = function asinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asinh = function asinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asinh();\n  };\n\n  AbstractMatrix.prototype.atan = function atan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atan = function atan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atan();\n  };\n\n  AbstractMatrix.prototype.atanh = function atanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atanh = function atanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atanh();\n  };\n\n  AbstractMatrix.prototype.cbrt = function cbrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cbrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cbrt = function cbrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cbrt();\n  };\n\n  AbstractMatrix.prototype.ceil = function ceil() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.ceil(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.ceil = function ceil(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.ceil();\n  };\n\n  AbstractMatrix.prototype.clz32 = function clz32() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.clz32(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.clz32 = function clz32(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.clz32();\n  };\n\n  AbstractMatrix.prototype.cos = function cos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cos = function cos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cos();\n  };\n\n  AbstractMatrix.prototype.cosh = function cosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cosh = function cosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cosh();\n  };\n\n  AbstractMatrix.prototype.exp = function exp() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.exp(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.exp = function exp(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.exp();\n  };\n\n  AbstractMatrix.prototype.expm1 = function expm1() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.expm1(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.expm1 = function expm1(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.expm1();\n  };\n\n  AbstractMatrix.prototype.floor = function floor() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.floor(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.floor = function floor(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.floor();\n  };\n\n  AbstractMatrix.prototype.fround = function fround() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.fround(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.fround = function fround(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.fround();\n  };\n\n  AbstractMatrix.prototype.log = function log() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log = function log(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log();\n  };\n\n  AbstractMatrix.prototype.log1p = function log1p() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log1p(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log1p = function log1p(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log1p();\n  };\n\n  AbstractMatrix.prototype.log10 = function log10() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log10(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log10 = function log10(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log10();\n  };\n\n  AbstractMatrix.prototype.log2 = function log2() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log2(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log2 = function log2(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log2();\n  };\n\n  AbstractMatrix.prototype.round = function round() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.round(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.round = function round(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.round();\n  };\n\n  AbstractMatrix.prototype.sign = function sign() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sign(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sign = function sign(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sign();\n  };\n\n  AbstractMatrix.prototype.sin = function sin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sin = function sin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sin();\n  };\n\n  AbstractMatrix.prototype.sinh = function sinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sinh = function sinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sinh();\n  };\n\n  AbstractMatrix.prototype.sqrt = function sqrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sqrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sqrt = function sqrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sqrt();\n  };\n\n  AbstractMatrix.prototype.tan = function tan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tan = function tan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tan();\n  };\n\n  AbstractMatrix.prototype.tanh = function tanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tanh = function tanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tanh();\n  };\n\n  AbstractMatrix.prototype.trunc = function trunc() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.trunc(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.trunc = function trunc(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.trunc();\n  };\n\n  AbstractMatrix.pow = function pow(matrix, arg0) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.pow(arg0);\n  };\n\n  AbstractMatrix.prototype.pow = function pow(value) {\n    if (typeof value === 'number') return this.powS(value);\n    return this.powM(value);\n  };\n\n  AbstractMatrix.prototype.powS = function powS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), value));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.powM = function powM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));\n      }\n    }\n    return this;\n  };\n}\n\nclass AbstractMatrix {\n  static from1DArray(newRows, newColumns, newData) {\n    let length = newRows * newColumns;\n    if (length !== newData.length) {\n      throw new RangeError('data length does not match given dimensions');\n    }\n    let newMatrix = new Matrix(newRows, newColumns);\n    for (let row = 0; row < newRows; row++) {\n      for (let column = 0; column < newColumns; column++) {\n        newMatrix.set(row, column, newData[row * newColumns + column]);\n      }\n    }\n    return newMatrix;\n  }\n\n  static rowVector(newData) {\n    let vector = new Matrix(1, newData.length);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(0, i, newData[i]);\n    }\n    return vector;\n  }\n\n  static columnVector(newData) {\n    let vector = new Matrix(newData.length, 1);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(i, 0, newData[i]);\n    }\n    return vector;\n  }\n\n  static zeros(rows, columns) {\n    return new Matrix(rows, columns);\n  }\n\n  static ones(rows, columns) {\n    return new Matrix(rows, columns).fill(1);\n  }\n\n  static rand(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { random = Math.random } = options;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.set(i, j, random());\n      }\n    }\n    return matrix;\n  }\n\n  static randInt(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1000, random = Math.random } = options;\n    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');\n    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let interval = max - min;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        let value = min + Math.round(random() * interval);\n        matrix.set(i, j, value);\n      }\n    }\n    return matrix;\n  }\n\n  static eye(rows, columns, value) {\n    if (columns === undefined) columns = rows;\n    if (value === undefined) value = 1;\n    let min = Math.min(rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, value);\n    }\n    return matrix;\n  }\n\n  static diag(data, rows, columns) {\n    let l = data.length;\n    if (rows === undefined) rows = l;\n    if (columns === undefined) columns = rows;\n    let min = Math.min(l, rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, data[i]);\n    }\n    return matrix;\n  }\n\n  static min(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static max(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new this(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static checkMatrix(value) {\n    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);\n  }\n\n  static isMatrix(value) {\n    return value != null && value.klass === 'Matrix';\n  }\n\n  get size() {\n    return this.rows * this.columns;\n  }\n\n  apply(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        callback.call(this, i, j);\n      }\n    }\n    return this;\n  }\n\n  to1DArray() {\n    let array = [];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        array.push(this.get(i, j));\n      }\n    }\n    return array;\n  }\n\n  to2DArray() {\n    let copy = [];\n    for (let i = 0; i < this.rows; i++) {\n      copy.push([]);\n      for (let j = 0; j < this.columns; j++) {\n        copy[i].push(this.get(i, j));\n      }\n    }\n    return copy;\n  }\n\n  toJSON() {\n    return this.to2DArray();\n  }\n\n  isRowVector() {\n    return this.rows === 1;\n  }\n\n  isColumnVector() {\n    return this.columns === 1;\n  }\n\n  isVector() {\n    return this.rows === 1 || this.columns === 1;\n  }\n\n  isSquare() {\n    return this.rows === this.columns;\n  }\n\n  isSymmetric() {\n    if (this.isSquare()) {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          if (this.get(i, j) !== this.get(j, i)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  isEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isEchelonForm = false;\n          checked = true;\n        }\n      }\n      i++;\n    }\n    return isEchelonForm;\n  }\n\n  isReducedEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isReducedEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isReducedEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isReducedEchelonForm = false;\n          checked = true;\n        }\n      }\n      for (let k = j + 1; k < this.rows; k++) {\n        if (this.get(i, k) !== 0) {\n          isReducedEchelonForm = false;\n        }\n      }\n      i++;\n    }\n    return isReducedEchelonForm;\n  }\n\n  echelonForm() {\n    let result = this.clone();\n    let h = 0;\n    let k = 0;\n    while (h < result.rows && k < result.columns) {\n      let iMax = h;\n      for (let i = h; i < result.rows; i++) {\n        if (result.get(i, k) > result.get(iMax, k)) {\n          iMax = i;\n        }\n      }\n      if (result.get(iMax, k) === 0) {\n        k++;\n      } else {\n        result.swapRows(h, iMax);\n        let tmp = result.get(h, k);\n        for (let j = k; j < result.columns; j++) {\n          result.set(h, j, result.get(h, j) / tmp);\n        }\n        for (let i = h + 1; i < result.rows; i++) {\n          let factor = result.get(i, k) / result.get(h, k);\n          result.set(i, k, 0);\n          for (let j = k + 1; j < result.columns; j++) {\n            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);\n          }\n        }\n        h++;\n        k++;\n      }\n    }\n    return result;\n  }\n\n  reducedEchelonForm() {\n    let result = this.echelonForm();\n    let m = result.columns;\n    let n = result.rows;\n    let h = n - 1;\n    while (h >= 0) {\n      if (result.maxRow(h) === 0) {\n        h--;\n      } else {\n        let p = 0;\n        let pivot = false;\n        while (p < n && pivot === false) {\n          if (result.get(h, p) === 1) {\n            pivot = true;\n          } else {\n            p++;\n          }\n        }\n        for (let i = 0; i < h; i++) {\n          let factor = result.get(i, p);\n          for (let j = p; j < m; j++) {\n            let tmp = result.get(i, j) - factor * result.get(h, j);\n            result.set(i, j, tmp);\n          }\n        }\n        h--;\n      }\n    }\n    return result;\n  }\n\n  set() {\n    throw new Error('set method is unimplemented');\n  }\n\n  get() {\n    throw new Error('get method is unimplemented');\n  }\n\n  repeat(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { rows = 1, columns = 1 } = options;\n    if (!Number.isInteger(rows) || rows <= 0) {\n      throw new TypeError('rows must be a positive integer');\n    }\n    if (!Number.isInteger(columns) || columns <= 0) {\n      throw new TypeError('columns must be a positive integer');\n    }\n    let matrix = new Matrix(this.rows * rows, this.columns * columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n      }\n    }\n    return matrix;\n  }\n\n  fill(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, value);\n      }\n    }\n    return this;\n  }\n\n  neg() {\n    return this.mulS(-1);\n  }\n\n  getRow(index) {\n    checkRowIndex(this, index);\n    let row = [];\n    for (let i = 0; i < this.columns; i++) {\n      row.push(this.get(index, i));\n    }\n    return row;\n  }\n\n  getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n  }\n\n  setRow(index, array) {\n    checkRowIndex(this, index);\n    array = checkRowVector(this, array);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, array[i]);\n    }\n    return this;\n  }\n\n  swapRows(row1, row2) {\n    checkRowIndex(this, row1);\n    checkRowIndex(this, row2);\n    for (let i = 0; i < this.columns; i++) {\n      let temp = this.get(row1, i);\n      this.set(row1, i, this.get(row2, i));\n      this.set(row2, i, temp);\n    }\n    return this;\n  }\n\n  getColumn(index) {\n    checkColumnIndex(this, index);\n    let column = [];\n    for (let i = 0; i < this.rows; i++) {\n      column.push(this.get(i, index));\n    }\n    return column;\n  }\n\n  getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n  }\n\n  setColumn(index, array) {\n    checkColumnIndex(this, index);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, array[i]);\n    }\n    return this;\n  }\n\n  swapColumns(column1, column2) {\n    checkColumnIndex(this, column1);\n    checkColumnIndex(this, column2);\n    for (let i = 0; i < this.rows; i++) {\n      let temp = this.get(i, column1);\n      this.set(i, column1, this.get(i, column2));\n      this.set(i, column2, temp);\n    }\n    return this;\n  }\n\n  addRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[j]);\n      }\n    }\n    return this;\n  }\n\n  subRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[j]);\n      }\n    }\n    return this;\n  }\n\n  mulRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[j]);\n      }\n    }\n    return this;\n  }\n\n  divRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[j]);\n      }\n    }\n    return this;\n  }\n\n  addColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[i]);\n      }\n    }\n    return this;\n  }\n\n  subColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[i]);\n      }\n    }\n    return this;\n  }\n\n  divColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulRow(index, value) {\n    checkRowIndex(this, index);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, this.get(index, i) * value);\n    }\n    return this;\n  }\n\n  mulColumn(index, value) {\n    checkColumnIndex(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, this.get(i, index) * value);\n    }\n    return this;\n  }\n\n  max() {\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  maxIndex() {\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  min() {\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  minIndex() {\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  maxRow(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  maxRowIndex(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  minRow(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  minRowIndex(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  maxColumn(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  maxColumnIndex(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  minColumn(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  minColumnIndex(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  diag() {\n    let min = Math.min(this.rows, this.columns);\n    let diag = [];\n    for (let i = 0; i < min; i++) {\n      diag.push(this.get(i, i));\n    }\n    return diag;\n  }\n\n  norm(type = 'frobenius') {\n    let result = 0;\n    if (type === 'max') {\n      return this.max();\n    } else if (type === 'frobenius') {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j < this.columns; j++) {\n          result = result + this.get(i, j) * this.get(i, j);\n        }\n      }\n      return Math.sqrt(result);\n    } else {\n      throw new RangeError(`unknown norm type: ${type}`);\n    }\n  }\n\n  cumulativeSum() {\n    let sum = 0;\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        sum += this.get(i, j);\n        this.set(i, j, sum);\n      }\n    }\n    return this;\n  }\n\n  dot(vector2) {\n    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n    let vector1 = this.to1DArray();\n    if (vector1.length !== vector2.length) {\n      throw new RangeError('vectors do not have the same size');\n    }\n    let dot = 0;\n    for (let i = 0; i < vector1.length; i++) {\n      dot += vector1[i] * vector2[i];\n    }\n    return dot;\n  }\n\n  mmul(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.columns;\n\n    let result = new Matrix(m, p);\n\n    let Bcolj = new Float64Array(n);\n    for (let j = 0; j < p; j++) {\n      for (let k = 0; k < n; k++) {\n        Bcolj[k] = other.get(k, j);\n      }\n\n      for (let i = 0; i < m; i++) {\n        let s = 0;\n        for (let k = 0; k < n; k++) {\n          s += this.get(i, k) * Bcolj[k];\n        }\n\n        result.set(i, j, s);\n      }\n    }\n    return result;\n  }\n\n  strassen2x2(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(2, 2);\n    const a11 = this.get(0, 0);\n    const b11 = other.get(0, 0);\n    const a12 = this.get(0, 1);\n    const b12 = other.get(0, 1);\n    const a21 = this.get(1, 0);\n    const b21 = other.get(1, 0);\n    const a22 = this.get(1, 1);\n    const b22 = other.get(1, 1);\n\n    // Compute intermediate values.\n    const m1 = (a11 + a22) * (b11 + b22);\n    const m2 = (a21 + a22) * b11;\n    const m3 = a11 * (b12 - b22);\n    const m4 = a22 * (b21 - b11);\n    const m5 = (a11 + a12) * b22;\n    const m6 = (a21 - a11) * (b11 + b12);\n    const m7 = (a12 - a22) * (b21 + b22);\n\n    // Combine intermediate values into the output.\n    const c00 = m1 + m4 - m5 + m7;\n    const c01 = m3 + m5;\n    const c10 = m2 + m4;\n    const c11 = m1 - m2 + m3 + m6;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    return result;\n  }\n\n  strassen3x3(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(3, 3);\n\n    const a00 = this.get(0, 0);\n    const a01 = this.get(0, 1);\n    const a02 = this.get(0, 2);\n    const a10 = this.get(1, 0);\n    const a11 = this.get(1, 1);\n    const a12 = this.get(1, 2);\n    const a20 = this.get(2, 0);\n    const a21 = this.get(2, 1);\n    const a22 = this.get(2, 2);\n\n    const b00 = other.get(0, 0);\n    const b01 = other.get(0, 1);\n    const b02 = other.get(0, 2);\n    const b10 = other.get(1, 0);\n    const b11 = other.get(1, 1);\n    const b12 = other.get(1, 2);\n    const b20 = other.get(2, 0);\n    const b21 = other.get(2, 1);\n    const b22 = other.get(2, 2);\n\n    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n    const m2 = (a00 - a10) * (-b01 + b11);\n    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n    const m5 = (a10 + a11) * (-b00 + b01);\n    const m6 = a00 * b00;\n    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n    const m8 = (-a00 + a20) * (b02 - b12);\n    const m9 = (a20 + a21) * (-b00 + b02);\n    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n    const m13 = (a02 - a22) * (b11 - b21);\n    const m14 = a02 * b20;\n    const m15 = (a21 + a22) * (-b20 + b21);\n    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n    const m17 = (a02 - a12) * (b12 - b22);\n    const m18 = (a11 + a12) * (-b20 + b22);\n    const m19 = a01 * b10;\n    const m20 = a12 * b21;\n    const m21 = a10 * b02;\n    const m22 = a20 * b01;\n    const m23 = a22 * b22;\n\n    const c00 = m6 + m14 + m19;\n    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n    const c11 = m2 + m4 + m5 + m6 + m20;\n    const c12 = m14 + m16 + m17 + m18 + m21;\n    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n    const c21 = m12 + m13 + m14 + m15 + m22;\n    const c22 = m6 + m7 + m8 + m9 + m23;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(0, 2, c02);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    result.set(1, 2, c12);\n    result.set(2, 0, c20);\n    result.set(2, 1, c21);\n    result.set(2, 2, c22);\n    return result;\n  }\n\n  mmulStrassen(y) {\n    y = Matrix.checkMatrix(y);\n    let x = this.clone();\n    let r1 = x.rows;\n    let c1 = x.columns;\n    let r2 = y.rows;\n    let c2 = y.columns;\n    if (c1 !== r2) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,\n      );\n    }\n\n    // Put a matrix into the top left of a matrix of zeros.\n    // `rows` and `cols` are the dimensions of the output matrix.\n    function embed(mat, rows, cols) {\n      let r = mat.rows;\n      let c = mat.columns;\n      if (r === rows && c === cols) {\n        return mat;\n      } else {\n        let resultat = AbstractMatrix.zeros(rows, cols);\n        resultat = resultat.setSubMatrix(mat, 0, 0);\n        return resultat;\n      }\n    }\n\n    // Make sure both matrices are the same size.\n    // This is exclusively for simplicity:\n    // this algorithm can be implemented with matrices of different sizes.\n\n    let r = Math.max(r1, r2);\n    let c = Math.max(c1, c2);\n    x = embed(x, r, c);\n    y = embed(y, r, c);\n\n    // Our recursive multiplication function.\n    function blockMult(a, b, rows, cols) {\n      // For small matrices, resort to naive multiplication.\n      if (rows <= 512 || cols <= 512) {\n        return a.mmul(b); // a is equivalent to this\n      }\n\n      // Apply dynamic padding.\n      if (rows % 2 === 1 && cols % 2 === 1) {\n        a = embed(a, rows + 1, cols + 1);\n        b = embed(b, rows + 1, cols + 1);\n      } else if (rows % 2 === 1) {\n        a = embed(a, rows + 1, cols);\n        b = embed(b, rows + 1, cols);\n      } else if (cols % 2 === 1) {\n        a = embed(a, rows, cols + 1);\n        b = embed(b, rows, cols + 1);\n      }\n\n      let halfRows = parseInt(a.rows / 2, 10);\n      let halfCols = parseInt(a.columns / 2, 10);\n      // Subdivide input matrices.\n      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n      // Compute intermediate values.\n      let m1 = blockMult(\n        AbstractMatrix.add(a11, a22),\n        AbstractMatrix.add(b11, b22),\n        halfRows,\n        halfCols,\n      );\n      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);\n      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);\n      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);\n      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);\n      let m6 = blockMult(\n        AbstractMatrix.sub(a21, a11),\n        AbstractMatrix.add(b11, b12),\n        halfRows,\n        halfCols,\n      );\n      let m7 = blockMult(\n        AbstractMatrix.sub(a12, a22),\n        AbstractMatrix.add(b21, b22),\n        halfRows,\n        halfCols,\n      );\n\n      // Combine intermediate values into the output.\n      let c11 = AbstractMatrix.add(m1, m4);\n      c11.sub(m5);\n      c11.add(m7);\n      let c12 = AbstractMatrix.add(m3, m5);\n      let c21 = AbstractMatrix.add(m2, m4);\n      let c22 = AbstractMatrix.sub(m1, m2);\n      c22.add(m3);\n      c22.add(m6);\n\n      // Crop output to the desired size (undo dynamic padding).\n      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);\n      resultat = resultat.setSubMatrix(c11, 0, 0);\n      resultat = resultat.setSubMatrix(c12, c11.rows, 0);\n      resultat = resultat.setSubMatrix(c21, 0, c11.columns);\n      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\n      return resultat.subMatrix(0, rows - 1, 0, cols - 1);\n    }\n    return blockMult(x, y, r, c);\n  }\n\n  scaleRows(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.rows; i++) {\n      const row = this.getRow(i);\n      rescale(row, { min, max, output: row });\n      newMatrix.setRow(i, row);\n    }\n    return newMatrix;\n  }\n\n  scaleColumns(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.columns; i++) {\n      const column = this.getColumn(i);\n      rescale(column, {\n        min: min,\n        max: max,\n        output: column,\n      });\n      newMatrix.setColumn(i, column);\n    }\n    return newMatrix;\n  }\n\n  flipRows() {\n    const middle = Math.ceil(this.columns / 2);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < middle; j++) {\n        let first = this.get(i, j);\n        let last = this.get(i, this.columns - 1 - j);\n        this.set(i, j, last);\n        this.set(i, this.columns - 1 - j, first);\n      }\n    }\n    return this;\n  }\n\n  flipColumns() {\n    const middle = Math.ceil(this.rows / 2);\n    for (let j = 0; j < this.columns; j++) {\n      for (let i = 0; i < middle; i++) {\n        let first = this.get(i, j);\n        let last = this.get(this.rows - 1 - i, j);\n        this.set(i, j, last);\n        this.set(this.rows - 1 - i, j, first);\n      }\n    }\n    return this;\n  }\n\n  kroneckerProduct(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.rows;\n    let q = other.columns;\n\n    let result = new Matrix(m * p, n * q);\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        for (let k = 0; k < p; k++) {\n          for (let l = 0; l < q; l++) {\n            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  transpose() {\n    let result = new Matrix(this.columns, this.rows);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        result.set(j, i, this.get(i, j));\n      }\n    }\n    return result;\n  }\n\n  sortRows(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.rows; i++) {\n      this.setRow(i, this.getRow(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  sortColumns(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.columns; i++) {\n      this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  subMatrix(startRow, endRow, startColumn, endColumn) {\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    let newMatrix = new Matrix(\n      endRow - startRow + 1,\n      endColumn - startColumn + 1,\n    );\n    for (let i = startRow; i <= endRow; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixRow(indices, startColumn, endColumn) {\n    if (startColumn === undefined) startColumn = 0;\n    if (endColumn === undefined) endColumn = this.columns - 1;\n    if (\n      startColumn > endColumn ||\n      startColumn < 0 ||\n      startColumn >= this.columns ||\n      endColumn < 0 ||\n      endColumn >= this.columns\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        if (indices[i] < 0 || indices[i] >= this.rows) {\n          throw new RangeError(`Row index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixColumn(indices, startRow, endRow) {\n    if (startRow === undefined) startRow = 0;\n    if (endRow === undefined) endRow = this.rows - 1;\n    if (\n      startRow > endRow ||\n      startRow < 0 ||\n      startRow >= this.rows ||\n      endRow < 0 ||\n      endRow >= this.rows\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startRow; j <= endRow; j++) {\n        if (indices[i] < 0 || indices[i] >= this.columns) {\n          throw new RangeError(`Column index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n      }\n    }\n    return newMatrix;\n  }\n\n  setSubMatrix(matrix, startRow, startColumn) {\n    matrix = Matrix.checkMatrix(matrix);\n    let endRow = startRow + matrix.rows - 1;\n    let endColumn = startColumn + matrix.columns - 1;\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    for (let i = 0; i < matrix.rows; i++) {\n      for (let j = 0; j < matrix.columns; j++) {\n        this.set(startRow + i, startColumn + j, matrix.get(i, j));\n      }\n    }\n    return this;\n  }\n\n  selection(rowIndices, columnIndices) {\n    let indices = checkIndices(this, rowIndices, columnIndices);\n    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);\n    for (let i = 0; i < indices.row.length; i++) {\n      let rowIndex = indices.row[i];\n      for (let j = 0; j < indices.column.length; j++) {\n        let columnIndex = indices.column[j];\n        newMatrix.set(i, j, this.get(rowIndex, columnIndex));\n      }\n    }\n    return newMatrix;\n  }\n\n  trace() {\n    let min = Math.min(this.rows, this.columns);\n    let trace = 0;\n    for (let i = 0; i < min; i++) {\n      trace += this.get(i, i);\n    }\n    return trace;\n  }\n\n  clone() {\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let row = 0; row < this.rows; row++) {\n      for (let column = 0; column < this.columns; column++) {\n        newMatrix.set(row, column, this.get(row, column));\n      }\n    }\n    return newMatrix;\n  }\n\n  sum(by) {\n    switch (by) {\n      case 'row':\n        return sumByRow(this);\n      case 'column':\n        return sumByColumn(this);\n      case undefined:\n        return sumAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  product(by) {\n    switch (by) {\n      case 'row':\n        return productByRow(this);\n      case 'column':\n        return productByColumn(this);\n      case undefined:\n        return productAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  mean(by) {\n    const sum = this.sum(by);\n    switch (by) {\n      case 'row': {\n        for (let i = 0; i < this.rows; i++) {\n          sum[i] /= this.columns;\n        }\n        return sum;\n      }\n      case 'column': {\n        for (let i = 0; i < this.columns; i++) {\n          sum[i] /= this.rows;\n        }\n        return sum;\n      }\n      case undefined:\n        return sum / this.size;\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  variance(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { unbiased = true, mean = this.mean(by) } = options;\n    if (typeof unbiased !== 'boolean') {\n      throw new TypeError('unbiased must be a boolean');\n    }\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByRow(this, unbiased, mean);\n      }\n      case 'column': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByColumn(this, unbiased, mean);\n      }\n      case undefined: {\n        if (typeof mean !== 'number') {\n          throw new TypeError('mean must be a number');\n        }\n        return varianceAll(this, unbiased, mean);\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  standardDeviation(by, options) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    const variance = this.variance(by, options);\n    if (by === undefined) {\n      return Math.sqrt(variance);\n    } else {\n      for (let i = 0; i < variance.length; i++) {\n        variance[i] = Math.sqrt(variance[i]);\n      }\n      return variance;\n    }\n  }\n\n  center(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { center = this.mean(by) } = options;\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByRow(this, center);\n        return this;\n      }\n      case 'column': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByColumn(this, center);\n        return this;\n      }\n      case undefined: {\n        if (typeof center !== 'number') {\n          throw new TypeError('center must be a number');\n        }\n        centerAll(this, center);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  scale(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    let scale = options.scale;\n    switch (by) {\n      case 'row': {\n        if (scale === undefined) {\n          scale = getScaleByRow(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByRow(this, scale);\n        return this;\n      }\n      case 'column': {\n        if (scale === undefined) {\n          scale = getScaleByColumn(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByColumn(this, scale);\n        return this;\n      }\n      case undefined: {\n        if (scale === undefined) {\n          scale = getScaleAll(this);\n        } else if (typeof scale !== 'number') {\n          throw new TypeError('scale must be a number');\n        }\n        scaleAll(this, scale);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n}\n\nAbstractMatrix.prototype.klass = 'Matrix';\nif (typeof Symbol !== 'undefined') {\n  AbstractMatrix.prototype[\n    Symbol.for('nodejs.util.inspect.custom')\n  ] = inspectMatrix;\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\n// Synonyms\nAbstractMatrix.random = AbstractMatrix.rand;\nAbstractMatrix.randomInt = AbstractMatrix.randInt;\nAbstractMatrix.diagonal = AbstractMatrix.diag;\nAbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;\nAbstractMatrix.identity = AbstractMatrix.eye;\nAbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;\nAbstractMatrix.prototype.tensorProduct =\n  AbstractMatrix.prototype.kroneckerProduct;\n\nclass Matrix extends AbstractMatrix {\n  constructor(nRows, nColumns) {\n    super();\n    if (Matrix.isMatrix(nRows)) {\n      return nRows.clone();\n    } else if (Number.isInteger(nRows) && nRows > 0) {\n      // Create an empty matrix\n      this.data = [];\n      if (Number.isInteger(nColumns) && nColumns > 0) {\n        for (let i = 0; i < nRows; i++) {\n          this.data.push(new Float64Array(nColumns));\n        }\n      } else {\n        throw new TypeError('nColumns must be a positive integer');\n      }\n    } else if (Array.isArray(nRows)) {\n      // Copy the values from the 2D array\n      const arrayData = nRows;\n      nRows = arrayData.length;\n      nColumns = arrayData[0].length;\n      if (typeof nColumns !== 'number' || nColumns === 0) {\n        throw new TypeError(\n          'Data must be a 2D array with at least one element',\n        );\n      }\n      this.data = [];\n      for (let i = 0; i < nRows; i++) {\n        if (arrayData[i].length !== nColumns) {\n          throw new RangeError('Inconsistent array dimensions');\n        }\n        this.data.push(Float64Array.from(arrayData[i]));\n      }\n    } else {\n      throw new TypeError(\n        'First argument must be a positive number or an array',\n      );\n    }\n    this.rows = nRows;\n    this.columns = nColumns;\n    return this;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n\n  removeRow(index) {\n    checkRowIndex(this, index);\n    if (this.rows === 1) {\n      throw new RangeError('A matrix cannot have less than one row');\n    }\n    this.data.splice(index, 1);\n    this.rows -= 1;\n    return this;\n  }\n\n  addRow(index, array) {\n    if (array === undefined) {\n      array = index;\n      index = this.rows;\n    }\n    checkRowIndex(this, index, true);\n    array = Float64Array.from(checkRowVector(this, array));\n    this.data.splice(index, 0, array);\n    this.rows += 1;\n    return this;\n  }\n\n  removeColumn(index) {\n    checkColumnIndex(this, index);\n    if (this.columns === 1) {\n      throw new RangeError('A matrix cannot have less than one column');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns - 1);\n      for (let j = 0; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      for (let j = index + 1; j < this.columns; j++) {\n        newRow[j - 1] = this.data[i][j];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns -= 1;\n    return this;\n  }\n\n  addColumn(index, array) {\n    if (typeof array === 'undefined') {\n      array = index;\n      index = this.columns;\n    }\n    checkColumnIndex(this, index, true);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns + 1);\n      let j = 0;\n      for (; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      newRow[j++] = array[i];\n      for (; j < this.columns + 1; j++) {\n        newRow[j] = this.data[i][j - 1];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns += 1;\n    return this;\n  }\n}\n\ninstallMathOperations(AbstractMatrix, Matrix);\n\n/**\n * @private\n */\n\nfunction getMeanData(normalized) {\n  let matrix = new Matrix(normalized.matrix);\n  return {\n    x: normalized.x,\n    y: matrix.mean('column'),\n  };\n}\n\n/**\n * @private\n * @param {*} spectra\n * @param {object} [options={}]\n * @param {string} [options.fs='\\t'] field separator\n * @param {string} [options.rs='\\n'] record (line) separator\n */\n\nfunction getNormalizedText(spectra, options = {}) {\n  let { fs = '\\t', rs = '\\n' } = options;\n  let { matrix, meta, ids, x } = getNormalizedData(spectra);\n  let allKeysObject = {};\n  for (let metum of meta) {\n    for (let key of Object.keys(metum)) {\n      let type = typeof metum[key];\n      if (type === 'number' || type === 'string' || type === 'boolean') {\n        allKeysObject[key] = true;\n      }\n    }\n  }\n  let allKeys = Object.keys(allKeysObject);\n\n  let lines = [];\n  let line = [];\n  line.push('id', ...allKeys, ...x);\n  lines.push(line.join(fs));\n\n  for (let i = 0; i < ids.length; i++) {\n    line = [];\n    line.push(ids[i]);\n    for (let key of allKeys) {\n      line.push(meta[i][key]);\n    }\n    line.push(...matrix[i]);\n    lines.push(line.join(fs));\n  }\n\n  return lines.join(rs);\n}\n\nfunction getFromToIndex$1(xs, range) {\n  let { from, to } = range;\n  if (from === undefined) {\n    from = xs[0];\n  }\n  if (to === undefined) {\n    to = xs[xs.length - 1];\n  }\n\n  return {\n    fromIndex: X.findClosestIndex(xs, from),\n    toIndex: X.findClosestIndex(xs, to),\n  };\n}\n\nfunction min$1(spectra, targetSpectrum, range = {}) {\n  let fromToIndex = getFromToIndex$1(targetSpectrum.normalized.x, range);\n\n  let targetValue = XY.minYPoint(targetSpectrum.normalized, fromToIndex).y;\n\n  let values = spectra.map(\n    (spectrum) => XY.minYPoint(spectrum.normalized, fromToIndex).y,\n  );\n\n  let matrix = [];\n  for (let i = 0; i < spectra.length; i++) {\n    let spectrum = spectra[i];\n    let factor = targetValue / values[i];\n    matrix.push(X.multiply(spectrum.normalized.y, factor));\n  }\n\n  return matrix;\n}\n\nfunction max$1(spectra, targetSpectrum, range = {}) {\n  let fromToIndex = getFromToIndex$1(targetSpectrum.normalized.x, range);\n\n  let targetValue = XY.maxYPoint(targetSpectrum.normalized, fromToIndex).y;\n\n  let values = spectra.map(\n    (spectrum) => XY.maxYPoint(spectrum.normalized, fromToIndex).y,\n  );\n\n  let matrix = [];\n  for (let i = 0; i < spectra.length; i++) {\n    let spectrum = spectra[i];\n    let factor = targetValue / values[i];\n    matrix.push(X.multiply(spectrum.normalized.y, factor));\n  }\n\n  return matrix;\n}\n\nfunction maybeToPrecision(value, digits) {\n  if (value < 0) {\n    value = 0 - value;\n    if (typeof digits === 'number') {\n      return `- ${value.toPrecision(digits)}`;\n    } else {\n      return `- ${value.toString()}`;\n    }\n  } else {\n    if (typeof digits === 'number') {\n      return value.toPrecision(digits);\n    } else {\n      return value.toString();\n    }\n  }\n}\n\nfunction checkArraySize(x, y) {\n  if (!Array.isArray(x) || !Array.isArray(y)) {\n    throw new TypeError('x and y must be arrays');\n  }\n  if (x.length !== y.length) {\n    throw new RangeError('x and y arrays must have the same length');\n  }\n}\n\nclass BaseRegression {\n  constructor() {\n    if (new.target === BaseRegression) {\n      throw new Error('BaseRegression must be subclassed');\n    }\n  }\n\n  predict(x) {\n    if (typeof x === 'number') {\n      return this._predict(x);\n    } else if (Array.isArray(x)) {\n      const y = [];\n      for (let i = 0; i < x.length; i++) {\n        y.push(this._predict(x[i]));\n      }\n      return y;\n    } else {\n      throw new TypeError('x must be a number or array');\n    }\n  }\n\n  _predict() {\n    throw new Error('_predict must be implemented');\n  }\n\n  train() {\n    // Do nothing for this package\n  }\n\n  toString() {\n    return '';\n  }\n\n  toLaTeX() {\n    return '';\n  }\n\n  /**\n   * Return the correlation coefficient of determination (r) and chi-square.\n   * @param {Array<number>} x\n   * @param {Array<number>} y\n   * @return {object}\n   */\n  score(x, y) {\n    if (!Array.isArray(x) || !Array.isArray(y) || x.length !== y.length) {\n      throw new Error('x and y must be arrays of the same length');\n    }\n\n    const n = x.length;\n    const y2 = new Array(n);\n    for (let i = 0; i < n; i++) {\n      y2[i] = this._predict(x[i]);\n    }\n\n    let xSum = 0;\n    let ySum = 0;\n    let chi2 = 0;\n    let rmsd = 0;\n    let xSquared = 0;\n    let ySquared = 0;\n    let xY = 0;\n    for (let i = 0; i < n; i++) {\n      xSum += y2[i];\n      ySum += y[i];\n      xSquared += y2[i] * y2[i];\n      ySquared += y[i] * y[i];\n      xY += y2[i] * y[i];\n      if (y[i] !== 0) {\n        chi2 += ((y[i] - y2[i]) * (y[i] - y2[i])) / y[i];\n      }\n      rmsd += (y[i] - y2[i]) * (y[i] - y2[i]);\n    }\n\n    const r =\n      (n * xY - xSum * ySum) /\n      Math.sqrt((n * xSquared - xSum * xSum) * (n * ySquared - ySum * ySum));\n\n    return {\n      r: r,\n      r2: r * r,\n      chi2: chi2,\n      rmsd: Math.sqrt(rmsd / n)\n    };\n  }\n}\n\nclass SimpleLinearRegression extends BaseRegression {\n  constructor(x, y) {\n    super();\n    if (x === true) {\n      this.slope = y.slope;\n      this.intercept = y.intercept;\n      this.coefficients = [y.intercept, y.slope];\n    } else {\n      checkArraySize(x, y);\n      regress(this, x, y);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: 'simpleLinearRegression',\n      slope: this.slope,\n      intercept: this.intercept\n    };\n  }\n\n  _predict(x) {\n    return this.slope * x + this.intercept;\n  }\n\n  computeX(y) {\n    return (y - this.intercept) / this.slope;\n  }\n\n  toString(precision) {\n    let result = 'f(x) = ';\n    if (this.slope !== 0) {\n      const xFactor = maybeToPrecision(this.slope, precision);\n      result += `${xFactor === '1' ? '' : `${xFactor} * `}x`;\n      if (this.intercept !== 0) {\n        const absIntercept = Math.abs(this.intercept);\n        const operator = absIntercept === this.intercept ? '+' : '-';\n        result += ` ${operator} ${maybeToPrecision(absIntercept, precision)}`;\n      }\n    } else {\n      result += maybeToPrecision(this.intercept, precision);\n    }\n    return result;\n  }\n\n  toLaTeX(precision) {\n    return this.toString(precision);\n  }\n\n  static load(json) {\n    if (json.name !== 'simpleLinearRegression') {\n      throw new TypeError('not a SLR model');\n    }\n    return new SimpleLinearRegression(true, json);\n  }\n}\n\nfunction regress(slr, x, y) {\n  const n = x.length;\n  let xSum = 0;\n  let ySum = 0;\n\n  let xSquared = 0;\n  let xY = 0;\n\n  for (let i = 0; i < n; i++) {\n    xSum += x[i];\n    ySum += y[i];\n    xSquared += x[i] * x[i];\n    xY += x[i] * y[i];\n  }\n\n  const numerator = n * xY - xSum * ySum;\n  slr.slope = numerator / (n * xSquared - xSum * xSum);\n  slr.intercept = (1 / n) * ySum - slr.slope * (1 / n) * xSum;\n  slr.coefficients = [slr.intercept, slr.slope];\n}\n\nfunction minMax(spectra, targetSpectrum, range = {}) {\n  let fromToIndex = getFromToIndex$1(targetSpectrum.normalized.x, range);\n\n  let targetValue = {\n    min: XY.minYPoint(targetSpectrum.normalized, fromToIndex).y,\n    max: XY.maxYPoint(targetSpectrum.normalized, fromToIndex).y,\n  };\n\n  let values = spectra.map((spectrum) => {\n    return {\n      min: XY.minYPoint(spectrum.normalized, fromToIndex).y,\n      max: XY.maxYPoint(spectrum.normalized, fromToIndex).y,\n    };\n  });\n\n  let matrix = [];\n  for (let i = 0; i < spectra.length; i++) {\n    let spectrum = spectra[i];\n    const regression = new SimpleLinearRegression(\n      [targetValue.min, targetValue.max],\n      [values[i].min, values[i].max],\n    );\n\n    let length = spectrum.normalized.y.length;\n    let scaled = new Array(length);\n    for (let j = 0; j < length; j++) {\n      scaled[j] = regression.computeX(spectrum.normalized.y[j]);\n    }\n    matrix.push(scaled);\n  }\n\n  return matrix;\n}\n\nfunction range(spectra, targetSpectrum, range = {}) {\n  let fromToIndex = getFromToIndex$1(targetSpectrum.normalized.x, range);\n\n  let targetValue = XY.integration(targetSpectrum.normalized, fromToIndex);\n\n  let values = spectra.map((spectrum) =>\n    XY.integration(spectrum.normalized, fromToIndex),\n  );\n\n  let matrix = [];\n  for (let i = 0; i < spectra.length; i++) {\n    let spectrum = spectra[i];\n    let factor = targetValue / values[i];\n    matrix.push(X.multiply(spectrum.normalized.y, factor));\n  }\n\n  return matrix;\n}\n\n/**\n * @private\n * @param {Array<Spectrum>} spectra\n * @param {object} [options={}] scale spectra based on various parameters\n * @param {object} [options.range] from - to\n * @param {Array} [options.ids] ids of selected spectra\n * @param {string} [options.targetID=spectra[0].id]\n * @param {string} [options.method='max'] min, max, range, minMax\n * @param {boolean} [options.relative=false]\n * @returns {object} { ids:[], matrix:[Array], meta:[object], x:[] }\n */\n\nfunction getScaledData(spectraProcessor, options = {}) {\n  if (!spectraProcessor.spectra || !spectraProcessor.spectra[0]) return {};\n  const { range: range$1, targetID, relative, method, ids } = options;\n\n  let targetSpectrum =\n    spectraProcessor.getSpectrum(targetID) || spectraProcessor.spectra[0];\n  let spectra = spectraProcessor.getSpectra(ids);\n\n  let result;\n  if (method === '' || method === undefined) {\n    result = getNormalizedData(spectra);\n  } else {\n    let matrix;\n    switch (method.toLowerCase()) {\n      case 'min':\n        matrix = min$1(spectra, targetSpectrum, range$1);\n        break;\n      case 'max':\n        matrix = max$1(spectra, targetSpectrum, range$1);\n        break;\n      case 'minmax':\n        matrix = minMax(spectra, targetSpectrum, range$1);\n        break;\n      case 'range':\n        matrix = range(spectra, targetSpectrum, range$1);\n        break;\n      default:\n        throw new Error(`getScaledData: unknown method: ${method}`);\n    }\n    let meta = [];\n    let currentIDs = [];\n    for (let spectrum of spectra) {\n      currentIDs.push(spectrum.id);\n      meta.push(spectrum.meta);\n    }\n    let x = spectra[0].normalized.x;\n    result = { ids: currentIDs, matrix, meta, x };\n  }\n\n  if (relative) {\n    for (let i = 0; i < result.matrix.length; i++) {\n      result.matrix[i] = X.subtract(\n        result.matrix[i],\n        targetSpectrum.normalized.y,\n      );\n    }\n  }\n\n  return result;\n}\n\nclass SpectraProcessor {\n  /**\n   * Manager a large number of spectra with the possibility to normalize the data\n   * and skip the original data.\n   * @param {object} [options={}]\n   * @param {boolean} [options.maxMemory=64M]\n   * @param {object} [options.normalization={}] options to normalize the spectra before comparison\n   * @param {number} [options.normalization.from]\n   * @param {number} [options.normalization.to]\n   * @param {number} [options.normalization.numberOfPoints]\n   * @param {array<object>} [options.normalization.filters]\n   * @param {string} [options.normalization.filters.X.name]\n   * @param {object} [options.normalization.filters.X.options]\n   * @param {array<object>} [options.normalization.exclusions]\n   * @param {string} [options.normalization.exclusions.X.from]\n   * @param {object} [options.normalization.exclusions.X.to]\n   */\n  constructor(options = {}) {\n    this.normalization = options.normalization;\n    this.maxMemory = options.maxMemory || 64 * 1024 * 1024;\n    this.keepOriginal = true;\n    this.spectra = [];\n    this.boundaries = {\n      minX: Number.MAX_VALUE,\n      maxX: Number.MIN_VALUE,\n      minY: Number.MAX_VALUE,\n      maxY: Number.MIN_VALUE,\n    };\n  }\n\n  getNormalizationAnnotations() {\n    return getNormalizationAnnotations(\n      this.normalization,\n      this.getNormalizedBoundary(),\n    );\n  }\n\n  /**\n   * Recalculate the normalized data using the stored original data if available\n   * This will throw an error in the original data is not present\n   * @param {number} [normalization.from]\n   * @param {number} [normalization.to]\n   * @param {number} [normalization.numberOfPoints]\n   * @param {array<object>} [normalization.filters]\n   * @param {string} [normalization.filters.X.name]\n   * @param {object} [normalization.filters.X.options]\n   * @param {array<object>} [normalization.exclusions]\n   * @param {string} [normalization.exclusions.X.from]\n   * @param {object} [normalization.exclusions.X.to]\n   */\n  setNormalization(normalization = {}) {\n    if (JSON.stringify(this.normalization) === JSON.stringify(normalization)) {\n      return;\n    }\n    this.normalization = normalization;\n    for (let spectrum of this.spectra) {\n      spectrum.updateNormalization(this.normalization);\n    }\n  }\n\n  getNormalization() {\n    return this.normalization;\n  }\n\n  /**\n   * Returns an object {x:[], y:[]} containing the autocorrelation for the\n   * specified index\n   * @param {integer} [index] point of the spectrum to autocorrelate\n   * @param {object} [options={}]\n   * @param {array} [options.ids=[]] list of ids, by default all spectra\n   */\n  getAutocorrelation(index, options) {\n    return getAutocorrelation(this.getNormalizedData(options), index);\n  }\n\n  /**\n   * Returns a {x:[], y:[]} containg the average of specified spectra\n   * @param {object} [options={}]\n   * @param {array} [options.ids=[]] list of ids, by default all spectra\n   */\n  getMeanData(options) {\n    return getMeanData(this.getNormalizedData(options));\n  }\n\n  /**\n   * Returns an object contains 4 parameters with the normalized data\n   * @returns {object} { ids:[], matrix:[Array], meta:[object], x:[] }\n   * @param {object} [options={}]\n   * @param {Array} [options.ids] List of spectra ids to export, by default all\n   */\n  getNormalizedData(options = {}) {\n    const { ids } = options;\n    let spectra = this.getSpectra(ids);\n    return getNormalizedData(spectra);\n  }\n\n  /**\n   * Returns a tab separated value containing the normalized data\n   * @param {object} [options={}]\n   * @param {Array} [options.ids] List of spectra ids to export, by default all\n   * @param {string} [options.fs='\\t'] field separator\n   * @param {string} [options.rs='\\n'] record (line) separator\n   * @returns {string}\n   */\n  getNormalizedText(options = {}) {\n    const { ids } = options;\n    let spectra = this.getSpectra(ids);\n    return getNormalizedText(spectra, options);\n  }\n\n  getMinMaxX() {\n    let min = Number.MAX_VALUE;\n    let max = Number.MIN_VALUE;\n    for (let spectrum of this.spectra) {\n      if (spectrum.minX < min) min = spectrum.minX;\n      if (spectrum.maxX > max) max = spectrum.maxX;\n    }\n    return { min, max };\n  }\n\n  /**\n\n   * Returns an object contains 4 parameters with the scaled data\n   * @param {object} [options={}] scale spectra based on various parameters\n   * @param {object} [options.range] from - to\n   * @param {Array} [options.ids] ids of selected spectra, by default all\n   * @param {string} [options.targetID=spectra[0].id]\n   * @param {string} [options.method='max'] min, max, range, minMax\n   * @param {boolean} [options.relative=false]\n   * @returns {object} { ids:[], matrix:[Array], meta:[object], x:[] }\n   */\n  getScaledData(options) {\n    return getScaledData(this, options);\n  }\n\n  /**\n   * Add jcamp\n   * By default TITLE from the jcamp will be in the meta information\n   * @param {string} text\n   * @param {object} [options={}]\n   * @param {object} [options.parserOptions={}] XY parser options\n   * @param {object} [options.meta={}]\n   * @param {string} [options.meta.color]\n   * @param {object} [options.id={}]\n   * @param {object} [options.kind]\n   * @param {boolean} [options.force=false] replace existing spectrum (same ID)\n   */\n\n  addFromText(text$1, options = {}) {\n    if (options.force !== true && options.id && this.contains(options.id)) {\n      return;\n    }\n    let parsed = text(text$1, options);\n    let meta = { ...parsed.meta, ...(options.meta || {}) };\n    this.addFromData(parsed.data, { meta, id: options.id });\n  }\n\n  /**\n   * Add jcamp\n   * By default TITLE from the jcamp will be in the meta information\n   * @param {string} jcamp\n   * @param {object} [options={}]\n   * @param {object} [options.meta={}]\n   * @param {string} [options.meta.color]\n   * @param {object} [options.id={}]\n   * @param {boolean} [options.force=false] replace existing spectrum (same ID)\n   */\n\n  addFromJcamp(jcamp$1, options = {}) {\n    if (options.force !== true && options.id && this.contains(options.id)) {\n      return;\n    }\n    let parsed = jcamp(jcamp$1);\n    let meta = { ...parsed.meta, ...(options.meta || {}) };\n    this.addFromData(parsed.data, { meta, id: options.id });\n  }\n\n  updateRangesInfo(options) {\n    for (let spectrum of this.spectra) {\n      spectrum.updateRangesInfo(options);\n    }\n  }\n\n  /**\n   * Add a spectrum based on the data\n   * @param {object} data {x, y}}\n   * @param {object} [options={}]\n   * @param {object} [options.meta={}]\n   * @param {object} [options.id]\n   * @param {object} [options.normalization={}]\n   * @param {object} [options.normalized]\n   * @return {Spectrum}\n   */\n\n  addFromData(data, options = {}) {\n    if (this.spectra.length === 0) this.keepOriginal = true;\n    const id =\n      options.id ||\n      Math.random()\n        .toString(36)\n        .substring(2, 10);\n    let index = this.getSpectrumIndex(id);\n    if (index === undefined) index = this.spectra.length;\n    let spectrum = new Spectrum(data.x, data.y, id, {\n      meta: options.meta,\n      normalized: options.normalized,\n      normalization: this.normalization,\n    });\n    this.spectra[index] = spectrum;\n    if (!this.keepOriginal) {\n      spectrum.removeOriginal();\n    } else {\n      let memoryInfo = this.getMemoryInfo();\n      if (memoryInfo.total > this.maxMemory) {\n        this.keepOriginal = false;\n        this.removeOriginals();\n      }\n    }\n  }\n\n  removeOriginals() {\n    for (let spectrum of this.spectra) {\n      spectrum.removeOriginal();\n    }\n  }\n\n  /**\n   * Remove the spectrum from the SpectraProcessor for the specified id\n   * @param {string} id\n   */\n  removeSpectrum(id) {\n    let index = this.getSpectrumIndex(id);\n    if (index === undefined) return undefined;\n    return this.spectra.splice(index, 1);\n  }\n\n  /**\n   * Remove all the spectra not present in the list\n   * @param {Array} [ids] Array of ids of the spectra to keep\n   */\n  removeSpectraNotIn(ids) {\n    let currentIDs = this.spectra.map((spectrum) => spectrum.id);\n    for (let id of currentIDs) {\n      if (!ids.includes(id)) {\n        this.removeSpectrum(id);\n      }\n    }\n  }\n\n  /**\n   * Checks if the ID of a spectrum exists in the SpectraProcessor\n   * @param {string} id\n   */\n  contains(id) {\n    return !isNaN(this.getSpectrumIndex(id));\n  }\n\n  /**\n   * Returns the index of the spectrum in the spectra array\n   * @param {string} id\n   * @returns {number}\n   */\n  getSpectrumIndex(id) {\n    if (!id) return undefined;\n    for (let i = 0; i < this.spectra.length; i++) {\n      let spectrum = this.spectra[i];\n      if (spectrum.id === id) return i;\n    }\n    return undefined;\n  }\n\n  /**\n   * Returns a spectrum from its ID\n   * @param {Array} ids\n   * @returns {Array<Spectrum}\n   */\n  getSpectra(ids) {\n    if (!ids || !Array.isArray(ids)) return this.spectra;\n    let spectra = [];\n    for (let id of ids) {\n      let index = this.getSpectrumIndex(id);\n      if (index !== undefined) {\n        spectra.push(this.spectra[index]);\n      }\n    }\n    return spectra;\n  }\n\n  /**\n   * Returns the index of the spectrum in the spectra array\n   * @param {string} id\n   * @returns {number}\n   */\n  getSpectrum(id) {\n    let index = this.getSpectrumIndex(id);\n    if (index === undefined) return undefined;\n    return this.spectra[index];\n  }\n\n  /**\n   * Returns a JSGraph chart object for all the spectra\n   * @returns {object}\n   */\n  getChart() {\n    return getChart(this.spectra);\n  }\n\n  /**\n   * Returns a JSGraph annotation object for the specified index\n   * @returns {object}\n   */\n  getTrackAnnotation(index, options) {\n    return getTrackAnnotation(this.spectra, index, options);\n  }\n\n  /**\n   * Returns a JSGraph annotation object for box plot\n   * @returns {object}\n   */\n  getBoxPlotAnnotations(options) {\n    return getBoxPlotAnnotations(this.spectra, options);\n  }\n\n  /**\n   * Returns a JSGraph chart object for all the normalized spectra\n   * @param {object} [options={}]\n   * @param {Array} [options.ids] ids of the spectra to select, by default all\n   * @returns {object}\n   */\n  getNormalizedChart(options) {\n    return getNormalizedChart(this.spectra, options);\n  }\n\n  /**\n   * Returns a JSGraph chart object for all the scaled normalized spectra\n   * @param {object} [options={}]\n   * @param {Array} [options.ids] ids of the spectra to select, by default all\n   * @param {object} [options.range] from - to\n   * @param {string} [options.targetID=spectra[0].id]\n   * @param {string} [options.method='max'] min, max, range, minMax\n   * @param {boolean} [options.relative=false]\n   * @returns {object}\n   */\n  getScaledChart(options) {\n    return getScaledChart(this, options);\n  }\n\n  getMemoryInfo() {\n    let memoryInfo = { original: 0, normalized: 0, total: 0 };\n    this.spectra.forEach((spectrum) => {\n      let memory = spectrum.memory;\n      memoryInfo.original += memory.original;\n      memoryInfo.normalized += memory.normalized;\n      memoryInfo.total += memory.total;\n    });\n    memoryInfo.keepOriginal = this.keepOriginal;\n    memoryInfo.maxMemory = this.maxMemory;\n    return memoryInfo;\n  }\n\n  getNormalizedBoundary() {\n    let boundary = {\n      x: { min: Number.MAX_VALUE, max: Number.MIN_VALUE },\n      y: { min: Number.MAX_VALUE, max: Number.MIN_VALUE },\n    };\n    for (let spectrum of this.spectra) {\n      if (spectrum.normalizedBoundary.x.min < boundary.x.min) {\n        boundary.x.min = spectrum.normalizedBoundary.x.min;\n      }\n      if (spectrum.normalizedBoundary.x.max > boundary.x.max) {\n        boundary.x.max = spectrum.normalizedBoundary.x.max;\n      }\n      if (spectrum.normalizedBoundary.y.min < boundary.y.min) {\n        boundary.y.min = spectrum.normalizedBoundary.y.min;\n      }\n      if (spectrum.normalizedBoundary.y.max > boundary.y.max) {\n        boundary.y.max = spectrum.normalizedBoundary.y.max;\n      }\n    }\n    return boundary;\n  }\n\n  /**\n   * Create SpectraProcessor from normalized TSV\n   * @param {string} text\n   * @param {object} [options={}]\n   * @param {object} [options.separator='\\t']\n   */\n  static fromNormalizedMatrix(text, options = {}) {\n    let parsed = matrix(text, options);\n    if (!parsed) {\n      throw new Error('Can not parse TSV file');\n    }\n    let spectraProcessor = new SpectraProcessor();\n\n    spectraProcessor.setNormalization({\n      from: parsed.x[0],\n      to: parsed.x[parsed.x.length - 1],\n      numberOfPoints: parsed.x.length,\n    });\n    spectraProcessor.keepOriginal = false;\n\n    for (let i = 0; i < parsed.ids.length; i++) {\n      spectraProcessor.addFromData(\n        { x: [], y: [] },\n        {\n          normalized: {\n            x: parsed.x,\n            y: parsed.matrix[i],\n          },\n          id: parsed.ids[i],\n          meta: parsed.meta[i],\n        },\n      );\n    }\n\n    return spectraProcessor;\n  }\n}\n\nexports.SpectraProcessor = SpectraProcessor;\n"],"names":["toString","Object","prototype","object","call","endsWith","defineProperty","exports","value","array","fn","module","createCommonjsModule","compareNumbers","a","b","sum","values","i","length","max","l","min","minMax","arithmeticMean","mean","geometricMean","mul","Math","pow","logMean","lnsum","log","grandMean","means","samples","n","truncatedMean","percent","alreadySorted","undefined","concat","sort","k","floor","harmonicMean","RangeError","contraHarmonicMean","r1","r2","median","half","variance","unbiased","theMean","theVariance","x","standardDeviation","sqrt","standardError","robustMeanAndStdev","y","averageDeviations","Array","abs","stdev","quartiles","quart","q1","ceil","q2","q3","pooledStandardDeviation","pooledVariance","vari","mode","itemCount","itemArray","count","index","indexOf","maxValue","maxIndex","covariance","vector1","vector2","mean1","mean2","cov","skewness","s2","s3","dev","m2","g","kurtosis","s4","v","entropy","eps","weightedMean","weights","weightedStandardDeviation","weightedVariance","z","w","center","inPlace","result","standardize","standardDev","cumulativeSum","array_4","filterX","points","options","from","to","exclusions","zones","filter","exclusion","JSON","parse","stringify","forEach","currentFrom","push","getZones","currentZoneIndex","newX","newY","position","src","_typeof","obj","Symbol","iterator","constructor","sequentialFill","input","arguments","TypeError","_options","_options$from","_options$to","_options$size","size","step","Error","isArray","_i","integral","x0","x1","slope","intercept","equallySpaced","arrayXY","xLength","reverse","slice","variant","numberOfPoints","isNaN","toRemove","reduce","previous","unitsPerPoint","totalPoints","currentNbPoints","round","getZones$1","xResult","yResult","zone","zoneResult","processZone","output","halfStep","lastStep","start","previousX","Number","MAX_VALUE","previousY","nextX","nextY","frontOutsideSpectra","backOutsideSpectra","currentValue","currentPoints","j","main","equallySpacedSlot","initialOriginalStep","lastOriginalStep","MIN_VALUE","sumAtMin","sumAtMax","add","equallySpacedSmooth","norm","_options$algorithm","algorithm","toLowerCase","absoluteSumValue","sumValue","absoluteSum","map","element","rescale","currentMin","minValue","currentMax","_options$min","autoMinMax","_options$max","factor","check","isAnyArray$1","findClosestIndex","target","low","high","middle","getFromToIndex","fromIndex","toIndex","getTargetIndex","targetIndex","XY","integration","maxY","maximaY","maxima","startEqualIndex","maxYPoint","current","minimaY","minYPoint","nbPoints","minY","slot","currentX","first","sortX","data","minClosestYPoint","previousIndex","MIN_SAFE_INTEGER","currentIndex","maxClosestYPoint","realMaxYPoint","alpha","log10","beta","gamma","p","realMinYPoint","peakInfo","currentDiff","multiplier","newDiff","after","before","inflectionBefore","inflectionAfter","extrema","inflectionMiddle","width","X","array1","array2","constant","isConstant","array3","boxPlot","q1max","q3min","info","Q1","Q2","Q3","middleOver","divide","multiply","rotate","shift","subtract","correlation","A","B","sumA","sumA2","sumB","sumB2","sumAB","Spectrum","id","meta","normalization","normalized","normalizedBoundary","updateNormalizedBoundary","updateNormalization","updateMemory","this","original","memory","total","removeOriginal","getXY","getConverter","ntuplesSeparator","GC_MS_FIELDS","convertToFloatArray","stringArray","floatArray","parseFloat","defaultOptions","keepRecordsRegExp","xy","withoutXY","chromatogram","keepSpectra","noContour","nbContourLevels","noiseMultiplier","profiling","convertMSFieldToLabel","replace","isMSField","dataLabel","prepareSpectrum","spectrum","xFactor","yFactor","observeFrequency","xUnit","toUpperCase","firstX","lastX","deltaX","shiftOffsetVal","getMedian","fastParseXYData","isXYdata","currentData","ascii","currentY","firstY","endLine","charCodeAt","newLine","isDifference","isLastDifference","lastDifference","isDuplicate","inComment","lastValue","isNegative","inValue","skipFirstValue","decimalPosition","duplicate","ascii2","parseXYA","removeSymbolRegExp","isXYAdata","lines","split","trim","parsePeakTable","removeCommentRegExp","peakTableSplitRegExp","isPeaktable","logs","jcamp","ldr","dataValue","ldrs","infos","wantXY","assign","Date","now","ntuples","spectra","action","time","substring","xIndex","yIndex","firstVariable","secondVariable","symbol","last","lastY","vardim","units","yUnit","datatable","title","dataType","twoD","maxX","minX","xType","indirectFrequency","shiftOffsetNum","varname","vartype","varform","yType","page","pageValue","pageSymbol","pageSymbolIndex","unit","sampleDescription","match","keys","newNtuples","key","zData","minZ","maxZ","ySize","xSize","xVector","noise","convertTo3DZ","contourLines","povarHeight0","povarHeight1","povarHeight2","povarHeight3","isOver0","isOver1","isOver2","isOver3","pAx","pAy","pBx","pBy","lineZValue","nbSubSpectra","nbPovars","dx","y0","dy","iter","contourLevels","level","contourLevel","side","exp","zValue","iSubSpectra","subSpectra","subSpectraAfter","povar","segments","generateContourLines","add2D","newData","times","series","ms","dimension","existingGCMSFields","label","complexChromatogram","intensity","simpleChromatogram","getData","filters","name","meanFct","std","stdFct","process","kind","getNormalized","ranges","updateRangesInfo","range","fromToIndex","maxPoint","convert","worker","stamps","src_1","useWorker","workerURL","URL","createObjectURL","Blob","type","Worker","revokeObjectURL","addEventListener","event","stamp","Promise","resolve","random","postMessage","postToWorker","IR_TRANSMITTANCE","importation","converter","transmittance","display","xLabel","xInverted","yLabel","IR_ABSORBANCE","parsed","datatype","getJcampKind","parseXY","text","uniqueX","uniqueX$1","xColumn","yColumn","keepInfo","maxNumberColumns","MAX_SAFE_INTEGER","minNumberColumns","line","fields","counter","getBoxPlotAnnotations","q13FillColor","q13FillOpacity","q2StrokeColor","q2StrokeWidth","minMaxFillColor","minMaxFillOpacity","annotations","matrix","nbRow","nbColumn","aColumn","Float64Array","column","row","getBoxPlotData","q13","layer","properties","fillColor","fillOpacity","strokeWidth","strokeColor","addChartDataStyle","styles","unselected","lineColor","color","lineWidth","lineStyle","selected","getNormalizedData","ids","currentIDs","includes","checkRowIndex","outer","rows","checkColumnIndex","columns","checkRowVector","vector","to1DArray","checkColumnVector","checkRowIndices","rowIndices","some","r","checkColumnIndices","columnIndices","c","checkRange","startRow","endRow","startColumn","endColumn","checkNumber","newArray","maxRows","maxColumns","maxNumSize","formatNumber","num","numStr","String","padEnd","precise","toPrecision","exponential","toExponential","eIndex","e","AbstractMatrix","newRows","newColumns","newMatrix","Matrix","set","fill","isInteger","interval","zeros","matrix1","matrix2","checkMatrix","get","isMatrix","klass","apply","callback","to2DArray","copy","toJSON","isRowVector","isColumnVector","isVector","isSquare","isSymmetric","isEchelonForm","previousColumn","checked","isReducedEchelonForm","echelonForm","clone","h","iMax","swapRows","tmp","reducedEchelonForm","m","maxRow","pivot","repeat","setSubMatrix","neg","mulS","getRow","getRowVector","rowVector","setRow","row1","row2","temp","getColumn","getColumnVector","columnVector","setColumn","swapColumns","column1","column2","addRowVector","subRowVector","mulRowVector","divRowVector","addColumnVector","subColumnVector","mulColumnVector","divColumnVector","mulRow","mulColumn","idx","minIndex","maxRowIndex","minRow","minRowIndex","maxColumn","maxColumnIndex","minColumn","minColumnIndex","diag","dot","mmul","other","Bcolj","s","strassen2x2","a11","b11","a12","b12","a21","b21","a22","b22","m1","m3","m4","m5","c00","c01","c10","c11","strassen3x3","a00","a01","a02","a10","a20","b00","b01","b02","b10","b20","m6","m7","m8","m9","m12","m13","m14","m15","m16","m17","m18","c02","c12","c20","c21","c22","mmulStrassen","c1","c2","embed","mat","cols","resultat","console","warn","blockMult","halfRows","parseInt","halfCols","subMatrix","sub","scaleRows","isFinite","scaleColumns","flipRows","flipColumns","kroneckerProduct","q","transpose","sortRows","compareFunction","sortColumns","subMatrixRow","indices","subMatrixColumn","selection","checkIndices","rowIndex","columnIndex","trace","by","sumByRow","sumByColumn","sumAll","product","productByRow","productByColumn","productAll","sum1","sum2","varianceByRow","varianceByColumn","varianceAll","centerByRow","centerByColumn","centerAll","scale","getScaleByRow","scaleByRow","getScaleByColumn","scaleByColumn","divider","getScaleAll","scaleAll","for","indent","indentData","maxI","maxJ","join","inspectData","rand","randomInt","randInt","diagonal","identity","eye","negate","tensorProduct","nRows","nColumns","arrayData","removeRow","splice","addRow","removeColumn","newRow","addColumn","getFromToIndex$1","xs","maybeToPrecision","digits","addS","addM","subS","subM","subtractS","subtractM","mulM","multiplyS","multiplyM","div","divS","divM","divideS","divideM","mod","modS","modM","modulus","modulusS","modulusM","and","andS","andM","or","orS","orM","xor","xorS","xorM","leftShift","leftShiftS","leftShiftM","signPropagatingRightShift","signPropagatingRightShiftS","signPropagatingRightShiftM","rightShift","rightShiftS","rightShiftM","zeroFillRightShift","zeroFillRightShiftS","zeroFillRightShiftM","not","acos","acosh","asin","asinh","atan","atanh","cbrt","clz32","cos","cosh","expm1","fround","log1p","log2","sign","sin","sinh","tan","tanh","trunc","arg0","powS","powM","installMathOperations","BaseRegression","predict","_predict","train","toLaTeX","score","y2","xSum","ySum","chi2","rmsd","xSquared","ySquared","xY","SimpleLinearRegression","coefficients","checkArraySize","slr","numerator","regress","computeX","precision","absIntercept","operator","json","getScaledData","spectraProcessor","range$1","targetID","relative","method","targetSpectrum","getSpectrum","getSpectra","targetValue","min$1","max$1","regression","scaled","SpectraProcessor","maxMemory","keepOriginal","boundaries","getNormalizationAnnotations","boundary","ignore","getNormalizedBoundary","setNormalization","getNormalization","getAutocorrelation","getMeanData","getNormalizedText","fs","rs","allKeysObject","metum","allKeys","getMinMaxX","addFromText","text$1","force","contains","parserOptions","addFromData","addFromJcamp","jcamp$1","getSpectrumIndex","getMemoryInfo","removeOriginals","removeSpectrum","removeSpectraNotIn","getChart","chart","getTrackAnnotation","getNormalizedChart","getScaledChart","memoryInfo","headers","labels","header","parts","oneMeta"],"mappings":"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"}