!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).spectraProcessor={})}(this,(function(t){"use strict";function e(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function r(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,o)}return r}function o(t){for(var o=1;o<arguments.length;o++){var n=null!=arguments[o]?arguments[o]:{};o%2?r(n,!0).forEach((function(r){e(t,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(n).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}const n=Object.prototype.toString;var i,s=function(t){return n.call(t).endsWith("Array]")},a=function(t,e){return t(e={exports:{}},e.exports),e.exports}((function(t,e){Object.defineProperty(e,"__esModule",{value:!0});var r=function(t,e){return t(e={exports:{}},e.exports),e.exports}((function(t,e){function r(t,e){return t-e}e.sum=function(t){for(var e=0,r=0;r<t.length;r++)e+=t[r];return e},e.max=function(t){for(var e=t[0],r=t.length,o=1;o<r;o++)t[o]>e&&(e=t[o]);return e},e.min=function(t){for(var e=t[0],r=t.length,o=1;o<r;o++)t[o]<e&&(e=t[o]);return e},e.minMax=function(t){for(var e=t[0],r=t[0],o=t.length,n=1;n<o;n++)t[n]<e&&(e=t[n]),t[n]>r&&(r=t[n]);return{min:e,max:r}},e.arithmeticMean=function(t){for(var e=0,r=t.length,o=0;o<r;o++)e+=t[o];return e/r},e.mean=e.arithmeticMean,e.geometricMean=function(t){for(var e=1,r=t.length,o=0;o<r;o++)e*=t[o];return Math.pow(e,1/r)},e.logMean=function(t){for(var e=0,r=t.length,o=0;o<r;o++)e+=Math.log(t[o]);return e/r},e.grandMean=function(t,e){for(var r=0,o=0,n=t.length,i=0;i<n;i++)r+=e[i]*t[i],o+=e[i];return r/o},e.truncatedMean=function(t,e,o){void 0===o&&(o=!1),o||(t=[].concat(t).sort(r));for(var n=t.length,i=Math.floor(n*e),s=0,a=i;a<n-i;a++)s+=t[a];return s/(n-2*i)},e.harmonicMean=function(t){for(var e=0,r=t.length,o=0;o<r;o++){if(0===t[o])throw new RangeError("value at index "+o+"is zero");e+=1/t[o]}return r/e},e.contraHarmonicMean=function(t){for(var e=0,r=0,o=t.length,n=0;n<o;n++)e+=t[n]*t[n],r+=t[n];if(r<0)throw new RangeError("sum of values is negative");return e/r},e.median=function(t,e){void 0===e&&(e=!1),e||(t=[].concat(t).sort(r));var o=t.length,n=Math.floor(o/2);return o%2==0?.5*(t[n-1]+t[n]):t[n]},e.variance=function(t,r){void 0===r&&(r=!0);for(var o=e.mean(t),n=0,i=t.length,s=0;s<i;s++){var a=t[s]-o;n+=a*a}return r?n/(i-1):n/i},e.standardDeviation=function(t,r){return Math.sqrt(e.variance(t,r))},e.standardError=function(t){return e.standardDeviation(t)/Math.sqrt(t.length)},e.robustMeanAndStdev=function(t){var e=0,o=t.length,n=0;for(n=0;n<o;n++)e+=t[n];e/=o;var i=new Array(o);for(n=0;n<o;n++)i[n]=Math.abs(t[n]-e);return i.sort(r),{mean:e,stdev:o%2==1?i[(o-1)/2]/.6745:.5*(i[o/2]+i[o/2-1])/.6745}},e.quartiles=function(t,o){void 0===o&&(o=!1),o||(t=[].concat(t).sort(r));var n=t.length/4;return{q1:t[Math.ceil(n)-1],q2:e.median(t,!0),q3:t[Math.ceil(3*n)-1]}},e.pooledStandardDeviation=function(t,r){return Math.sqrt(e.pooledVariance(t,r))},e.pooledVariance=function(t,r){void 0===r&&(r=!0);for(var o=0,n=0,i=t.length,s=0;s<i;s++){var a=t[s],l=e.variance(a);o+=(a.length-1)*l,n+=r?a.length-1:a.length}return o/n},e.mode=function(t){var e,r=t.length,o=new Array(r);for(e=0;e<r;e++)o[e]=0;var n=new Array(r),i=0;for(e=0;e<r;e++){var s=n.indexOf(t[e]);s>=0?o[s]++:(n[i]=t[e],o[i]=1,i++)}var a=0,l=0;for(e=0;e<i;e++)o[e]>a&&(a=o[e],l=e);return n[l]},e.covariance=function(t,r,o){void 0===o&&(o=!0);var n=e.mean(t),i=e.mean(r);if(t.length!==r.length)throw"Vectors do not have the same dimensions";for(var s=0,a=t.length,l=0;l<a;l++){s+=(t[l]-n)*(r[l]-i)}return o?s/(a-1):s/a},e.skewness=function(t,r){void 0===r&&(r=!0);for(var o=e.mean(t),n=0,i=0,s=t.length,a=0;a<s;a++){var l=t[a]-o;n+=l*l,i+=l*l*l}var h=n/s,u=i/s/Math.pow(h,1.5);return r?Math.sqrt(s*(s-1))/(s-2)*u:u},e.kurtosis=function(t,r){void 0===r&&(r=!0);for(var o=e.mean(t),n=t.length,i=0,s=0,a=0;a<n;a++){var l=t[a]-o;i+=l*l,s+=l*l*l*l}var h=i/n;if(r){var u=i/(n-1);return n*(n+1)/((n-1)*(n-2)*(n-3))*(s/(u*u))-3*((n-1)*(n-1)/((n-2)*(n-3)))}return s/n/(h*h)-3},e.entropy=function(t,e){void 0===e&&(e=0);for(var r=0,o=t.length,n=0;n<o;n++)r+=t[n]*Math.log(t[n]+e);return-r},e.weightedMean=function(t,e){for(var r=0,o=t.length,n=0;n<o;n++)r+=t[n]*e[n];return r},e.weightedStandardDeviation=function(t,r){return Math.sqrt(e.weightedVariance(t,r))},e.weightedVariance=function(t,r){for(var o=e.weightedMean(t,r),n=0,i=t.length,s=0,a=0,l=0;l<i;l++){var h=t[l]-o,u=r[l];n+=u*(h*h),a+=u,s+=u*u}return n*(a/(a*a-s))},e.center=function(t,r){void 0===r&&(r=!1);var o=t;r||(o=[].concat(t));for(var n=e.mean(o),i=o.length,s=0;s<i;s++)o[s]-=n},e.standardize=function(t,r,o){void 0===r&&(r=e.standardDeviation(t)),void 0===o&&(o=!1);for(var n=t.length,i=o?t:new Array(n),s=0;s<n;s++)i[s]=t[s]/r;return i},e.cumulativeSum=function(t){var e=t.length,r=new Array(e);r[0]=t[0];for(var o=1;o<e;o++)r[o]=r[o-1]+t[o];return r}})),n=(r.sum,r.max,r.min,r.minMax);r.arithmeticMean,r.mean,r.geometricMean,r.logMean,r.grandMean,r.truncatedMean,r.harmonicMean,r.contraHarmonicMean,r.median,r.variance,r.standardDeviation,r.standardError,r.robustMeanAndStdev,r.quartiles,r.pooledStandardDeviation,r.pooledVariance,r.mode,r.covariance,r.skewness,r.kurtosis,r.entropy,r.weightedMean,r.weightedStandardDeviation,r.weightedVariance,r.center,r.standardize,r.cumulativeSum;function i(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:o}=t,{from:n=r[0],to:i=r[r.length-1],exclusions:s=[]}=e;let a=function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];t>e&&([t,e]=[e,t]),r=r.filter(t=>void 0!==t.from&&void 0!==t.to),(r=JSON.parse(JSON.stringify(r))).forEach(t=>{t.from>t.to&&([t.to,t.from]=[t.from,t.to])}),r.sort((t,e)=>t.from-e.from),r.forEach(r=>{r.from<t&&(r.from=t),r.to>e&&(r.to=e)});for(let t=0;t<r.length-1;t++)r[t].to>r[t+1].from&&(r[t].to=r[t+1].from);if(!(r=r.filter(t=>t.from<t.to))||0===r.length)return[{from:t,to:e}];let o=[],n=t;for(let t of r)n<t.from&&o.push({from:n,to:t.from}),n=t.to;return n<e&&o.push({from:n,to:e}),o}(n,i,s),l=0,h=[],u=[],f=0;for(;f<r.length;){if(r[f]<=a[l].to&&r[f]>=a[l].from)h.push(r[f]),u.push(o[f]);else if(r[f]>a[l].to&&!a[++l])break;f++}return{x:h,y:u}}const a=Object.prototype.toString;var l=function(t){return a.call(t).endsWith("Array]")};function h(t){return(h="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function u(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"!==h(t)||l(t)||(e=t,t=[]),!l(t))throw new TypeError("input must be an array");var r=e,o=r.from,n=void 0===o?0:o,i=r.to,s=void 0===i?10:i,a=r.size,u=void 0===a?t.length:a,f=r.step;if(u&&f)throw new Error("step is defined by the array size");if(u||(u=f?Math.floor((s-n)/f)+1:s-n+1),!f&&u&&(f=(s-n)/(u-1)),Array.isArray(t)){t.length=0;for(var c=0;c<u;c++)t.push(n),n+=f}else{if(t.length!==u)throw new Error("sequentialFill typed array must have the correct length");for(var m=0;m<u;m++)t[m]=n,n+=f}return t}function f(t,e,r,o){return.5*r*e*e+o*e-(.5*r*t*t+o*t)}function c(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{x:r,y:o}=t,n=r.length,i=!1;r.length>1&&r[0]>r[1]&&(r=r.slice().reverse(),o=o.slice().reverse(),i=!0);let{from:s=r[0],to:a=r[n-1],variant:l="smooth",numberOfPoints:h=100,exclusions:u=[]}=e;if(n!==o.length)throw new RangeError("the x and y vector doesn't have the same size.");if("number"!=typeof s||isNaN(s))throw new RangeError("'from' option must be a number");if("number"!=typeof a||isNaN(a))throw new RangeError("'to' option must be a number");if("number"!=typeof h||isNaN(h))throw new RangeError("'numberOfPoints' option must be a number");if(h<2)throw new RangeError("'numberOfPoints' option must be greater than 1");let f=function(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];t>e&&([t,e]=[e,t]),o=o.filter(t=>void 0!==t.from&&void 0!==t.to),(o=JSON.parse(JSON.stringify(o))).forEach(t=>{t.from>t.to&&([t.to,t.from]=[t.from,t.to])}),o.sort((t,e)=>t.from-e.from),o.forEach(r=>{r.from<t&&(r.from=t),r.to>e&&(r.to=e)});for(let t=0;t<o.length-1;t++)o[t].to>o[t+1].from&&(o[t].to=o[t+1].from);if(!(o=o.filter(t=>t.from<t.to))||0===o.length)return[{from:t,to:e,numberOfPoints:r}];let n=o.reduce((t,e)=>t+=e.to-e.from,0),i=(e-t-n)/r,s=[],a=t,l=0;for(let t of o){let e=Math.round((t.from-a)/i);l+=e,e>0&&s.push({from:a,to:t.from,numberOfPoints:e}),a=t.to}return r-l>0&&s.push({from:a,to:e,numberOfPoints:r-l}),s}(s,a,h,u),c=[],p=[];for(let t of f){let e=m(r,o,t.from,t.to,t.numberOfPoints,l);c=c.concat(e.x),p=p.concat(e.y)}return i?s<a?{x:c.reverse(),y:p.reverse()}:{x:c,y:p}:s<a?{x:c,y:p}:{x:c.reverse(),y:p.reverse()}}function m(t,e,r,o,n,i){if(n<1)throw new RangeError("the number of points must be at least 1");var s="slot"===i?function(t,e,r,o,n){var i=t.length,s=(o-r)/(n-1),a=s/2,l=t[t.length-1]-t[t.length-2],h=r-a,u=new Array(n),f=h,c=h+s,m=-Number.MAX_VALUE,p=0,g=t[0],d=e[0],w=0,y=!0,x=0,v=0,b=1,M=0;t:for(;;){if(m>=g)throw new Error("x must be an increasing serie");for(;m-c>0;){if(y&&(v++,y=!1),u[M]=v<=0?0:x/v,++M===n)break t;f=c,c+=s,x=0,v=0}m>f&&(x+=p,v++),(m===-Number.MAX_VALUE||w>1)&&v--,m=g,p=d,b<i?(g=t[b],d=e[b],b++):(g+=l,d=0,w++)}return u}(t,e,r,o,n):function(t,e,r,o,n){var i=t.length,s=(o-r)/(n-1),a=s/2,l=new Array(n),h=t[1]-t[0],u=t[i-1]-t[i-2],c=r-a,m=r+a,p=Number.MIN_VALUE,g=0,d=t[0]-h,w=0,y=0,x=0,v=0,b=0,M=0,E=0,A=0;t:for(;;){for(p<=c&&c<=d&&(b=y+(S=f(0,c-p,x,g)));d-m>=0;){var S=f(0,m-p,x,g);if(M=y+S,l[A++]=(M-b)/s,A===n)break t;c=m,m+=s,b=M}y+=f(p,d,x,v),p=d,g=w,E<i?(d=t[E],w=e[E],E++):E===i&&(d+=u,w=0),v=-(x=(w-g)/(d-p))*p+g}return l}(t,e,r,o,n);return{x:u({from:r,to:o,size:n}),y:s}}function p(t){if(!l(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=t[0],r=1;r<t.length;r++)t[r]>e&&(e=t[r]);return e}function g(t){var e=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).algorithm,r=void 0===e?"absolute":e;if(!Array.isArray(t))throw new Error("input must be an array");if(0===t.length)throw new Error("input must not be empty");switch(r.toLowerCase()){case"absolute":var o=function(t){for(var e=0,r=0;r<t.length;r++)e+=Math.abs(t[r]);return e}(t);return 0===o?t.slice(0):t.map((function(t){return t/o}));case"max":var n=p(t);return 0===n?t.slice(0):t.map((function(t){return t/n}));case"sum":var i=function(t){if(!l(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0;r<t.length;r++)e+=t[r];return e}(t);return 0===i?t.slice(0):t.map((function(t){return t/i}));default:throw new Error("norm: unknown algorithm: ".concat(r))}}function d(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!l(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!l(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var o=function(t){if(!l(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=t[0],r=1;r<t.length;r++)t[r]<e&&(e=t[r]);return e}(t),n=p(t);if(o===n)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var i=r.min,s=void 0===i?r.autoMinMax?o:0:i,a=r.max,h=void 0===a?r.autoMinMax?n:1:a;if(s>=h)throw new RangeError("min option must be smaller than max option");for(var u=(h-s)/(n-o),f=0;f<t.length;f++)e[f]=(t[f]-o)*u+s;return e}function w(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!s(t.x)||!s(t.y))throw new Error("Points must be an object of x and y arrays");if(t.x.length!==t.y.length)throw new Error("The x and y arrays mush have the same length")}function y(t,e){let r=0,o=t.length-1,n=0;for(;o-r>1;)if(t[n=r+(o-r>>1)]<e)r=n;else{if(!(t[n]>e))return n;o=n}return r<t.length-1?Math.abs(e-t[r])<Math.abs(t[r+1]-e)?r:r+1:r}function x(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{fromIndex:r,toIndex:o,from:n,to:i}=e;return void 0===r&&(r=void 0!==n?y(t,n):0),void 0===o&&(o=void 0!==i?y(t,i):t.length-1),{fromIndex:r,toIndex:o}}function v(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{target:r,targetIndex:o}=e;return void 0===o?void 0!==r?y(t,r):0:o}const b={check:w,integral:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{reverse:r=!1}=e;w(t);const{x:o,y:n}=t;if(o.length<2)return 0;const{fromIndex:i,toIndex:s}=x(o,e);let a,l=0;if(r){a={x:[o[s]],y:[0]};for(let t=s;t>i;t--)l+=(o[t]-o[t-1])*(n[t-1]+n[t])/2,a.x.push(o[t-1]),a.y.push(l);a.x.reverse(),a.y.reverse()}else{a={x:[o[i]],y:[0]};for(let t=i;t<s;t++)l+=(o[t+1]-o[t])*(n[t+1]+n[t])/2,a.x.push(o[t+1]),a.y.push(l)}return a},integration:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(t);const{x:r,y:o}=t;if(r.length<2)return 0;const{fromIndex:n,toIndex:i}=x(r,e);let s=0;for(let t=n;t<i;t++)s+=(r[t+1]-r[t])*(o[t+1]+o[t])/2;return s},maxY:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(t);const{x:r,y:o}=t;if(r.length<2)return 0;const{fromIndex:n,toIndex:i}=x(r,e);let s=o[n];for(let t=n;t<=i;t++)o[t]>s&&(s=o[t]);return s},maximaY:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};w(t);const{x:e,y:r}=t;if(e.length<3)return[];let o=[],n=-1;for(let t=1;t<e.length-1;t++)if(r[t-1]<r[t]&&r[t+1]<r[t])o.push({x:e[t],y:r[t],index:t});else if(r[t-1]<r[t]&&r[t+1]===r[t])n=t;else if(r[t-1]===r[t]&&r[t+1]<r[t]){let i=(t+n)/2>>0;o.push({x:e[i],y:r[i],index:i})}return o},maxYPoint:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(t);const{x:r,y:o}=t;if(r.length<2)return 0;const{fromIndex:n,toIndex:i}=x(r,e);let s={x:r[n],y:o[n]};for(let t=n;t<=i;t++)o[t]>s.y&&(s={x:r[t],y:o[t]});return s},minimaY:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};w(t);const{x:e,y:r}=t;if(e.length<3)return[];let o=[],n=-1;for(let t=1;t<e.length-1;t++)if(r[t-1]>r[t]&&r[t+1]>r[t])o.push({x:e[t],y:r[t],index:t});else if(r[t-1]>r[t]&&r[t+1]===r[t])n=t;else if(r[t-1]===r[t]&&r[t+1]>r[t]){let i=(t+n)/2>>0;o.push({x:e[i],y:r[i],index:i})}return o},minYPoint:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(t);const{x:r,y:o}=t;if(r.length<2)return 0;const{fromIndex:n,toIndex:i}=x(r,e);let s={x:r[n],y:o[n]};for(let t=n;t<=i;t++)o[t]<s.y&&(s={x:r[t],y:o[t]});return s},reduce:function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{from:o=t[0],to:n=t[t.length-1],nbPoints:i=4e3}=r,s=y(t,o),a=y(t,n);if(s>0&&t[s]>o&&s--,a<t.length-1&&t[a]<n&&a++,a-s<i)return{x:t.slice(s,a+1),y:e.slice(s,a+1)};let l=[t[s]],h=[e[s]],u=Number.MAX_VALUE,f=Number.MIN_VALUE;i=i%2==0?i/2+1:(i-1)/2+1;let c=(t[a]-t[s])/(i-1),m=t[s]+c,p=!0;for(let r=s+1;r<=a;r++)p?(u=e[r],f=e[r],p=!1):(e[r]<u&&(u=e[r]),e[r]>f&&(f=e[r])),(t[r]>=m||r===a)&&(l.push(m-c/2),h.push(u),l.push(m),h.push(f),m+=c,p=!0);return{x:l,y:h}},sortX:function(t){const{x:e,y:r}=t;if(e.length!==r.length)throw TypeError("sortX: length of x and y must be identical");return e.length<2||e[0]<e[1]?t:{x:e.slice(0).reverse(),y:r.slice(0).reverse()}},minClosestYPoint:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(t);const{x:r,y:o}=t;let{target:n,targetIndex:i}=e;void 0===i&&(i=void 0!==n?y(r,n):0);let s=Number.MIN_SAFE_INTEGER,a=i,l=o[i];for(;a!==s;)s=a,a>0&&o[a-1]<l?a--:a<r.length-1&&o[a+1]<l&&a++,l=o[a];return{x:r[a],y:o[a],index:a}},maxClosestYPoint:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(t);const{x:r,y:o}=t;let{target:n,targetIndex:i}=e;void 0===i&&(i=void 0!==n?y(r,n):0);let s=Number.MIN_SAFE_INTEGER,a=i,l=o[i];for(;a!==s;)s=a,a>0&&o[a-1]>l?a--:a<r.length-1&&o[a+1]>l&&a++,l=o[a];return{x:r[a],y:o[a],index:a}},realMaxYPoint:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(t);const{x:r,y:o}=t,n=v(r,e);if(o[n-1]>0&&o[n+1]>0&&o[n]>=o[n-1]&&o[n]>=o[n+1]){let t=20*Math.log10(o[n-1]),e=20*Math.log10(o[n]),i=20*Math.log10(o[n+1]),s=.5*(t-i)/(t-2*e+i);return{x:r[n]+(r[n]-r[n-1])*s,y:o[n]-.25*(o[n-1]-o[n+1])*s,index:n}}return{x:r[n],y:o[n],index:n}},realMinYPoint:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(t);const{x:r,y:o}=t,n=v(r,e);if(o[n-1]<0&&o[n+1]<0&&o[n]<=o[n-1]&&o[n]<=o[n+1]){let t=20*Math.log10(-o[n-1]),e=20*Math.log10(-o[n]),i=20*Math.log10(-o[n+1]),s=.5*(t-i)/(t-2*e+i);return{x:r[n]+(r[n]-r[n-1])*s,y:o[n]-.25*(o[n-1]-o[n+1])*s,index:n}}return{x:r[n],y:o[n],index:n}},peakInfo:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};w(t);const{x:r,y:o}=t;if(r.length<3)return;let{targetIndex:n,target:i}=e;if(void 0===n&&void 0!==i&&(n=y(r,i)),void 0===n)throw new Error("peakInfo: need to specify target or targetIndex");let s=n,a=o[s]-o[s+1],l=a<0?-1:1;for(a*=l;s<r.length-1;){let t=(o[++s]-o[s+1])*l;if(t<a)break;a=t}let h={x:r[s],y:o[s]};for(a=(o[s=n]-o[s-1])*l;s>1;){let t=(o[--s]-o[s-1])*l;if(t<a)break;a=t}let u={x:r[s],y:o[s]};return{inflectionBefore:u,inflectionAfter:h,extrema:{x:r[n],y:o[n]},inflectionMiddle:{x:(u.x+h.x)/2,y:(u.y+h.y)/2},width:Math.abs(u.x-h.x)}}};const M={add:function(t,e){let r,o=!1;if(Array.isArray(e)){if(t.length!==e.length)throw new Error("sub: size of array1 and array2 must be identical")}else o=!0,r=Number(e);let n=new Array(t.length);if(o)for(let e=0;e<t.length;e++)n[e]=t[e]+r;else for(let r=0;r<t.length;r++)n[r]=t[r]+e[r];return n},boxPlot:function(t){if((t=t.slice(0).sort((t,e)=>t-e)).length<5)throw Error("boxPlot: can not calculate info if array contains less than 3 elements");let e,r,o={Q1:0,Q2:0,Q3:0,min:t[0],max:t[t.length-1]};if(t.length%2==1){let n=(t.length-1)/2;o.Q2=t[n],e=n-1,r=n+1}else e=(r=t.length/2)-1,o.Q2=(t[e]+t[r])/2;if(e%2==0)o.Q1=t[e/2],o.Q3=t[(t.length+r-1)/2];else{o.Q1=(t[(e+1)/2]+t[(e-1)/2])/2;let n=(t.length+r)/2;o.Q3=(t[n]+t[n-1])/2}return o},divide:function(t,e){let r,o=!1;if(Array.isArray(e)){if(t.length!==e.length)throw new Error("sub: size of array1 and array2 must be identical")}else o=!0,r=Number(e);let n=new Array(t.length);if(o)for(let e=0;e<t.length;e++)n[e]=t[e]/r;else for(let r=0;r<t.length;r++)n[r]=t[r]/e[r];return n},findClosestIndex:y,getTargetIndex:v,multiply:function(t,e){let r,o=!1;if(Array.isArray(e)){if(t.length!==e.length)throw new Error("sub: size of array1 and array2 must be identical")}else o=!0,r=Number(e);let n=new Array(t.length);if(o)for(let e=0;e<t.length;e++)n[e]=t[e]*r;else for(let r=0;r<t.length;r++)n[r]=t[r]*e[r];return n},rotate:function(t,e){return(e%=t.length)<0&&(e+=t.length),t.slice(t.length-e).concat(t.slice(0,t.length-e))},subtract:function(t,e){let r,o=!1;if(Array.isArray(e)){if(t.length!==e.length)throw new Error("sub: size of array1 and array2 must be identical")}else o=!0,r=Number(e);let n=new Array(t.length);if(o)for(let e=0;e<t.length;e++)n[e]=t[e]-r;else for(let r=0;r<t.length;r++)n[r]=t[r]-e[r];return n},correlation:function(t,e){let r=t.length,o=0,n=0,i=0,s=0,a=0;for(let l=0;l<r;l++){let r=t[l],h=e[l];o+=r,n+=r**2,i+=h,s+=h**2,a+=r*h}return(r*a-o*i)/(Math.sqrt(r*n-o**2)*Math.sqrt(r*s-i**2))}};class E{constructor(t,e,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{meta:n={},normalization:i={},normalized:s}=o;t&&t.length>1&&t[0]>t[1]?(this.x=t.reverse(),this.y=e.reverse()):(this.x=t||[],this.y=e||[]),this.id=r,this.meta=n,this.normalizedBoundary={x:{min:0,max:0},y:{min:0,max:0}},s?(this.normalized=s,this.updateNormalizedBoundary()):this.updateNormalization(i),this.updateMemory()}get minX(){return this.x[0]}get maxX(){return this.x[this.x.length-1]}updateMemory(){let t=16*(this.x&&this.x.length||0),e=16*this.normalized.x.length;this.memory={original:t,normalized:e,total:t+e}}removeOriginal(){this.x=void 0,this.y=void 0,this.updateMemory()}getXY(){if(!Array.isArray(this.x)||!Array.isArray(this.y))throw new Error("Can not get normalized data");return{x:this.x,y:this.y}}}function A(){const t=/[, \t]+/,e=["TIC",".RIC","SCANNUMBER"];function r(t){var e=[];for(let r=0;r<t.length;r++)e.push(parseFloat(t[r]));return e}class o{}const n={keepRecordsRegExp:/^$/,xy:!1,withoutXY:!1,chromatogram:!1,keepSpectra:!1,noContour:!1,nbContourLevels:7,noiseMultiplier:5,profiling:!1};function i(t){return t.toLowerCase().replace(/[^a-z0-9]/g,"")}function s(t){return-1!==e.indexOf(t)}function a(t,e){if(e.xFactor||(e.xFactor=1),e.yFactor||(e.yFactor=1),e.observeFrequency&&e.xUnit&&"HZ"===e.xUnit.toUpperCase()&&(e.xUnit="PPM",e.xFactor=e.xFactor/e.observeFrequency,e.firstX=e.firstX/e.observeFrequency,e.lastX=e.lastX/e.observeFrequency,e.deltaX=e.deltaX/e.observeFrequency),e.shiftOffsetVal){var r=e.firstX-e.shiftOffsetVal;e.firstX=e.firstX-r,e.lastX=e.lastX-r}}function l(t){var e=(t=t.sort(h)).length;return t[Math.floor(e/2)]}function h(t,e){return t-e}function u(t,e){var r=t.yFactor,o=t.deltaX;t.isXYdata=!0;var n=[];t.data=[n];var i,s=t.firstX,a=t.firstY,l=!1;let h=0;for(;h<e.length;h++)if(13===(i=e.charCodeAt(h))||10===i)l=!0;else if(l)break;for(var u=!0,f=!1,c=!1,m=0,p=!1,g=!1,d=0,w=0,y=!1,x=!1,v=!1,b=0;h<=e.length;h++)if(i=h===e.length?13:e.charCodeAt(h),g)13!==i&&10!==i||(u=!0,g=!1);else if(i<=57&&i>=48)x=!0,b>0?d+=(i-48)/Math.pow(10,b++):(d*=10,d+=i-48);else if(44===i||46===i)x=!0,b++;else{if(x){if(u)u=!1,c&&(v=!0);else if(v)v=!1;else{f?(m=y?0-d:d,c=!0,f=!1):p||(w=y?0-d:d);for(var M=p?d-1:1,E=0;E<M;E++)c?a+=m:a=w,n.push(s),n.push(a*r),s+=o}y=!1,d=0,b=0,x=!1,p=!1}if(i<74&&i>63)x=!0,c=!1,d=i-64;else if(i>96&&i<106)x=!0,c=!1,d=i-96,y=!0;else if(115===i)x=!0,p=!0,d=9;else if(i>82&&i<91)x=!0,p=!0,d=i-82;else if(i>73&&i<83)x=!0,f=!0,d=i-73;else if(i>105&&i<115)x=!0,f=!0,d=i-105,y=!0;else if(36===i&&36===e.charCodeAt(h+1))x=!0,g=!0;else if(37===i)x=!0,f=!0,d=0,y=!1;else if(45===i){var A=e.charCodeAt(h+1);(A>=48&&A<=57||44===A||46===A)&&(x=!0,u||(c=!1),y=!0)}else 13!==i&&10!==i||(u=!0,g=!1)}}function f(t,e){var r,o=/(\(+|\)+|<+|>+|\s+)/g;t.isXYAdata=!0;var n=[];t.data=[n];var i=e.split(/,? *,?[;\r\n]+ */);for(let t=1;t<i.length;t++)r=i[t].trim().replace(o,"").split(","),n.push(parseFloat(r[0])),n.push(parseFloat(r[1]))}function c(t,e,r){var o,n=/\$\$.*/,i=/[,\t ]+/;t.isPeaktable=!0;var s=[];t.data=[s];var a=e.split(/,? *,?[;\r\n]+ */);for(let e=1;e<a.length;e++)if((o=a[e].trim().replace(n,"").split(i)).length%2==0)for(let e=0;e<o.length;e+=2)s.push(parseFloat(o[e])*t.xFactor),s.push(parseFloat(o[e+1])*t.yFactor);else r.logs.push("Format error: ".concat(o))}return function(h,m){var p,g,d,w,y,x,v,b=!(m=Object.assign({},n,m)).withoutXY,M=Date.now(),E={},A={};A.profiling=!!m.profiling&&[],A.logs=[];var S=[];A.spectra=S,A.info={};var z=new o;if("string"!=typeof h)throw new TypeError("the JCAMP should be a string");A.profiling&&A.profiling.push({action:"Before split to LDRS",time:Date.now()-M}),w=h.split(/[\r\n]+##/),A.profiling&&A.profiling.push({action:"Split to LDRS",time:Date.now()-M}),w[0]&&(w[0]=w[0].replace(/^[\r\n ]*##/,""));for(let e=0;e<w.length;e++){if((y=(p=w[e]).indexOf("="))>0?(g=p.substring(0,y),d=p.substring(y+1).trim()):(g=p,d=""),"DATATABLE"===(g=g.replace(/[_ -]/g,"").toUpperCase())&&(-1===(x=d.indexOf("\n"))&&(x=d.indexOf("\r")),x>0)){var R=-1,N=-1;if((v=d.substring(0,x).split(/[ ,;\t]+/))[0].indexOf("++")>0){var F=v[0].replace(/.*\(([a-zA-Z0-9]+)\+\+.*/,"$1"),I=v[0].replace(/.*\.\.([a-zA-Z0-9]+).*/,"$1");R=E.symbol.indexOf(F),N=E.symbol.indexOf(I)}-1===R&&(R=0),-1===N&&(N=0),E.first&&(E.first.length>R&&(z.firstX=E.first[R]),E.first.length>N&&(z.firstY=E.first[N])),E.last&&(E.last.length>R&&(z.lastX=E.last[R]),E.last.length>N&&(z.lastY=E.last[N])),E.vardim&&E.vardim.length>R&&(z.nbPoints=E.vardim[R]),E.factor&&(E.factor.length>R&&(z.xFactor=E.factor[R]),E.factor.length>N&&(z.yFactor=E.factor[N])),E.units&&(E.units.length>R&&(z.xUnit=E.units[R]),E.units.length>N&&(z.yUnit=E.units[N])),z.datatable=v[0],v[1]&&v[1].indexOf("PEAKS")>-1?g="PEAKTABLE":v[1]&&(v[1].indexOf("XYDATA")||v[0].indexOf("++")>0)&&(g="XYDATA",z.deltaX=(z.lastX-z.firstX)/(z.nbPoints-1))}if("XYDATA"!==g)if("PEAKTABLE"!==g)if("PEAKASSIGNMENTS"!==g){if("TITLE"===g)z.title=d;else if("DATATYPE"===g)z.dataType=d,d.indexOf("nD")>-1&&(A.twoD=!0);else if("NTUPLES"===g)d.indexOf("nD")>-1&&(A.twoD=!0);else if("XUNITS"===g)z.xUnit=d;else if("YUNITS"===g)z.yUnit=d;else if("FIRSTX"===g)z.firstX=parseFloat(d);else if("LASTX"===g)z.lastX=parseFloat(d);else if("FIRSTY"===g)z.firstY=parseFloat(d);else if("LASTY"===g)z.lastY=parseFloat(d);else if("NPOINTS"===g)z.nbPoints=parseFloat(d);else if("XFACTOR"===g)z.xFactor=parseFloat(d);else if("YFACTOR"===g)z.yFactor=parseFloat(d);else if("MAXX"===g)z.maxX=parseFloat(d);else if("MINX"===g)z.minX=parseFloat(d);else if("MAXY"===g)z.maxY=parseFloat(d);else if("MINY"===g)z.minY=parseFloat(d);else if("DELTAX"===g)z.deltaX=parseFloat(d);else if(".OBSERVEFREQUENCY"===g||"$SFO1"===g)z.observeFrequency||(z.observeFrequency=parseFloat(d));else if(".OBSERVENUCLEUS"===g)z.xType||(A.xType=d.replace(/[^a-zA-Z0-9]/g,""));else if("$SFO2"===g)A.indirectFrequency||(A.indirectFrequency=parseFloat(d));else if("$OFFSET"===g)A.shiftOffsetNum=0,z.shiftOffsetVal||(z.shiftOffsetVal=parseFloat(d));else if("$REFERENCEPOINT"===g);else if("VARNAME"===g)E.varname=d.split(t);else if("SYMBOL"===g)E.symbol=d.split(t);else if("VARTYPE"===g)E.vartype=d.split(t);else if("VARFORM"===g)E.varform=d.split(t);else if("VARDIM"===g)E.vardim=r(d.split(t));else if("UNITS"===g)E.units=d.split(t);else if("FACTOR"===g)E.factor=r(d.split(t));else if("FIRST"===g)E.first=r(d.split(t));else if("LAST"===g)E.last=r(d.split(t));else if("MIN"===g)E.min=r(d.split(t));else if("MAX"===g)E.max=r(d.split(t));else if(".NUCLEUS"===g)A.twoD&&(A.yType=d.split(t)[0]);else if("PAGE"===g){z.page=d.trim(),z.pageValue=parseFloat(d.replace(/^.*=/,"")),z.pageSymbol=z.page.replace(/[=].*/,"");var O=E.symbol.indexOf(z.pageSymbol),T="";E.units&&E.units[O]&&(T=E.units[O]),A.indirectFrequency&&"PPM"!==T&&(z.pageValue/=A.indirectFrequency)}else"RETENTIONTIME"===g?z.pageValue=parseFloat(d):s(g)?z[i(g)]=d:"SAMPLEDESCRIPTION"===g&&(z.sampleDescription=d);g.match(m.keepRecordsRegExp)&&(A.info[g]?(Array.isArray(A.info[g])||(A.info[g]=[A.info[g]]),A.info[g].push(d.trim())):A.info[g]=d.trim())}else b&&(d.match(/.*(XYA).*/)&&f(z,d),S.push(z),z=new o);else b&&(a(A,z),c(z,d,A),S.push(z),z=new o);else b&&(a(A,z),d.match(/.*\+\+.*/)?(z.deltaX||(z.deltaX=(z.lastX-z.firstX)/(z.nbPoints-1)),u(z,d)):c(z,d,A),S.push(z),z=new o)}if(A.profiling&&A.profiling.push({action:"Finished parsing",time:Date.now()-M}),Object.keys(E).length>0){var k=[],C=Object.keys(E);for(let t=0;t<C.length;t++){var P=C[t],X=E[P];for(let t=0;t<X.length;t++)k[t]||(k[t]={}),k[t][P]=X[t]}A.ntuples=k}if(A.twoD&&b&&(!function(t,e){var r=function(t){var e=t[0].data[0][0],r=e,o=t.length,n=t[0].data[0].length/2,i=new Array(o);for(let l=0;l<o;l++){i[l]=new Array(n);var s=t[l].data[0];for(let t=0;t<n;t++){var a=s[2*t+1];i[l][t]=a,a<e&&(e=a),a>r&&(r=a)}}const h=t[0].data[0][0],u=t[0].data[0][t[0].data[0].length-2],f=t[0].pageValue,c=t[o-1].pageValue;if(h>u)for(let t of i)t.reverse();f>c&&i.reverse();return{z:i,minX:Math.min(h,u),maxX:Math.max(h,u),minY:Math.min(f,c),maxY:Math.max(f,c),minZ:e,maxZ:r,noise:l(i[0].map(Math.abs))}}(t.spectra);e.noContour||(t.contourLines=function(t,e){for(var r,o,n,i,s,a,l,h,u,f,c,m,p,g=t.noise,d=t.z,w=d.length,y=d[0].length,x=t.minX,v=(t.maxX-x)/(y-1),b=t.minY,M=(t.maxY-b)/(w-1),E=t.minZ,A=t.maxZ,S=2*e.nbContourLevels,z=new Array(S),R=0;R<S;R++){var N={};z[R]=N;var F=R%2,I=(A-e.noiseMultiplier*g)*Math.exp((R>>1)-e.nbContourLevels);p=0===F?I+e.noiseMultiplier*g:0-I-e.noiseMultiplier*g;var O=[];if(N.zValue=p,N.lines=O,!(p<=E||p>=A))for(var T=0;T<w-1;T++)for(var k=d[T],C=d[T+1],P=0;P<y-1;P++)r=k[P],o=k[P+1],n=C[P],i=C[P+1],l=n>p,h=i>p,(s=r>p)!==(a=o>p)&&s!==l&&(u=P+(p-r)/(o-r),f=T,c=P,m=T+(p-r)/(n-r),O.push(u*v+x),O.push(f*M+b),O.push(c*v+x),O.push(m*M+b)),h!==a&&h!==l&&(u=P+1,f=T+1-(p-i)/(o-i),c=P+1-(p-i)/(n-i),m=T+1,O.push(u*v+x),O.push(f*M+b),O.push(c*v+x),O.push(m*M+b)),a!==l&&(u=(P+1-(p-o)/(n-o))*v+x,f=(T+(p-o)/(n-o))*M+b,a!==s&&(c=P+1-(p-o)/(r-o),m=T,O.push(u),O.push(f),O.push(c*v+x),O.push(m*M+b)),l!==s&&(c=P,m=T+1-(p-n)/(r-n),O.push(u),O.push(f),O.push(c*v+x),O.push(m*M+b)),a!==h&&(c=P+1,m=T+(p-o)/(i-o),O.push(u),O.push(f),O.push(c*v+x),O.push(m*M+b)),l!==h&&(c=P+(p-n)/(i-n),m=T+1,O.push(u),O.push(f),O.push(c*v+x),O.push(m*M+b)))}return{minX:t.minX,maxX:t.maxX,minY:t.minY,maxY:t.maxY,segments:z}}(r,e),delete r.z);t.minMax=r}(A,m),A.profiling&&A.profiling.push({action:"Finished countour plot calculation",time:Date.now()-M}),m.keepSpectra||delete A.spectra),m.chromatogram&&(m.xy=!0),m.xy&&b&&S.length>0)for(let t=0;t<S.length;t++)if((z=S[t]).data.length>0)for(let t=0;t<z.data.length;t++){for(var D=z.data[t],V={x:new Array(D.length/2),y:new Array(D.length/2)},q=0;q<D.length;q+=2)V.x[q/2]=D[q],V.y[q/2]=D[q+1];z.data[t]=V}return m.chromatogram&&(A.spectra.length>1?function(t){var r=t.spectra,o=r.length,n={times:new Array(o),series:{ms:{dimension:2,data:new Array(o)}}},s=[];for(let t=0;t<e.length;t++){var a=i(e[t]);r[0][a]&&(s.push(a),n.series[a]={dimension:1,data:new Array(o)})}for(let t=0;t<o;t++){var l=r[t];n.times[t]=l.pageValue;for(let e=0;e<s.length;e++)n.series[s[e]].data[t]=parseFloat(l[s[e]]);l.data&&(n.series.ms.data[t]=[l.data[0].x,l.data[0].y])}t.chromatogram=n}(A):function(t){var e=t.spectra[0].data[0];t.chromatogram={times:e.x.slice(),series:{intensity:{dimension:1,data:e.y.slice()}}}}(A),A.profiling&&A.profiling.push({action:"Finished chromatogram calculation",time:Date.now()-M})),A.profiling&&A.profiling.push({action:"Total time",time:Date.now()-M}),A}}E.prototype.getData=function(t){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r={x:t.x,y:t.y};return e&&(r=i({x:t.x,y:t.y},e)),r}(this,t)},E.prototype.updateNormalization=function(t){this.normalized=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!Array.isArray(t.x)||!Array.isArray(t.y))throw new Error("getNormalized: Can not get normalized data, missing original data.");let{from:o=t.x[0],to:n=t.x[t.x.length-1],numberOfPoints:i=1024,filters:s=[],exclusions:a=[]}=e,l=t.y.slice(0);for(let e of s)switch(e.name){case"centerMean":{let e=r.mean(t.y),o=t=>t-e;l=l.map(o);break}case"scaleSD":{let e=r.standardDeviation(t.y),o=t=>t/e;l=l.map(o);break}case"normalize":l=g(l);break;case"rescale":l=d(l);break;case"":case void 0:break;default:throw new Error("Unknown process kind: ".concat(process.kind))}return c({x:t.x,y:l},{from:o,to:n,numberOfPoints:i,exclusions:a})}(this,t),this.ranges={},this.updateMemory(),this.updateNormalizedBoundary()},E.prototype.updateRangesInfo=function(t){!function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.ranges={};for(let r of e){r=JSON.parse(JSON.stringify(r)),t.ranges[r.label]=r;let e={fromIndex:M.findClosestIndex(t.normalized.x,r.from),toIndex:M.findClosestIndex(t.normalized.x,r.to)};r.integration=b.integration(t.normalized,e),r.maxPoint=b.maxYPoint(t.normalized,e),r.x=t.normalized.x.slice(e.fromIndex,e.toIndex+1),r.y=t.normalized.y.slice(e.fromIndex,e.toIndex+1)}}(this,t)},E.prototype.updateNormalizedBoundary=function(){this.normalizedBoundary.x={min:this.normalized.x[0],max:this.normalized.x[this.normalized.x.length-1]},this.normalizedBoundary.y=n(this.normalized.y)};var S=A();var z,R={};var N=function(t,e,r){return"boolean"==typeof e&&(r=e,e={}),r?function(t,e){z||(r=URL.createObjectURL(new Blob(["var getConverter =".concat(A.toString(),";var convert = getConverter(); onmessage = function (event) { var data = JSON.parse(event.data); postMessage(JSON.stringify({stamp: data.stamp, output: convert(data.input, data.options)})); };")],{type:"application/javascript"})),z=new Worker(r),URL.revokeObjectURL(r),z.addEventListener("message",(function(t){var e=JSON.parse(t.data),r=e.stamp;R[r]&&R[r](e.output)})));var r;return new Promise((function(r){var o="".concat(Date.now()).concat(Math.random());R[o]=r,z.postMessage(JSON.stringify({stamp:o,input:t,options:e}))}))}(t,e):S(t,e)};const F={normalization:{},importation:{converter:t=>-Math.log10(t)},kind:"Infrared",display:{xLabel:"wavelength [cm-1]",xInverted:!0,yLabel:"Absorbance"}},I={normalization:{},kind:"Infrared",display:{xLabel:"wavelength [cm-1]",xInverted:!0,yLabel:"Absorbance"}};function O(t){const e=N(t,{xy:!0,keepRecordsRegExp:/TITLE/}),r=function(t){let e=t.spectra[0].dataType.toLowerCase(),r=t.spectra[0].yUnit.toLowerCase();if(e.match(/infrared/))return r.match(/absorbance/)?I:F}(e),o=e.spectra[0].data[0],n=e.info;return r&&r.importation&&r.importation.converter&&(o.y=o.y.map(r.importation.converter)),{data:o,kind:r,meta:n}}function T(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{rescale:r=!1,uniqueX:o=!1,xColumn:n=0,yColumn:i=1,keepInfo:s=!1,maxNumberColumns:a=Number.MAX_SAFE_INTEGER,minNumberColumns:l=2}=e;a=Math.max(a,n+1,i+1),l=Math.max(n+1,i+1,l);let h=t.split(/[\r\n]+/),u=Number.MIN_VALUE,f={x:[],y:[]},c=[];for(let t=0;t<h.length;t++){let e=h[t].trim();if(e.match(/[0-9]+/)&&e.match(/^[0-9eE,;. \t+-]+$/)){let t=e.split(/,[; \t]+|[; \t]+/);if(1===t.length&&(t=e.split(/[,; \t]+/)),t&&t.length>=l&&t.length<=a){let e=parseFloat(t[n].replace(",",".")),r=parseFloat(t[i].replace(",","."));r>u&&(u=r),f.x.push(e),f.y.push(r)}}else e&&c.push({position:f.x.length,value:e})}if(o&&function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{x:e,y:r}=t;if(e.length<2)return;if(e.length!==r.length)throw new Error("The X and Y arrays mush have the same length");let o=e[0],n=0;for(let t=1;t<e.length;t++)o!==e[t]&&(n++,o=e[t],e[n]=e[t],t!==n&&(r[n]=0)),t!==n&&(r[n]+=r[t]);e.length=n+1,r.length=n+1}(f),r)for(let t=0;t<f.y.length;t++)f.y[t]/=u;return s?{info:c,data:f}:f}function k(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{q13FillColor:r="#000",q13FillOpacity:o=.3,q2StrokeColor:n="#000",q2StrokeWidth:i=3,minMaxFillColor:s="#000",minMaxFillOpacity:a=.15}=e;let l=[],h=function(t){let e=[],r=t[0].normalized.x;for(let r of t)e.push(r.normalized.y);let o,n=e.length,i=e[0].length,s=new Float64Array(n);for(let t=0;t<i;t++){for(let r=0;r<n;r++)s[r]=e[r][t];let i=M.boxPlot(s);if(!o){o={x:r};for(let t in i)o[t]=[]}for(let t in i)o[t].push(i[t])}return o}(t);if(o&&r){let t=[];for(let e=0;e<h.x.length;e++)t.push({x:h.x[e],y:h.Q1[e]});for(let e=h.x.length-1;e>=0;e--)t.push({x:h.x[e],y:h.Q3[e]});l.push({type:"polygon",layer:0,properties:{fillColor:r,fillOpacity:o,strokeWidth:1e-7,position:t}})}if(n&&i){let t=[];for(let e=0;e<h.x.length;e++)t.push({x:h.x[e],y:h.Q2[e]});for(let e=h.x.length-1;e>=0;e--)t.push({x:h.x[e],y:h.Q2[e]});l.push({type:"polygon",layer:0,properties:{strokeWidth:i,strokeColor:n,position:t}})}if(s&&a){let t=[];for(let e=0;e<h.x.length;e++)t.push({x:h.x[e],y:h.min[e]});for(let e=h.x.length-1;e>=0;e--)t.push({x:h.x[e],y:h.max[e]});l.push({type:"polygon",layer:0,properties:{fillColor:s,fillOpacity:a,strokeWidth:1e-7,strokeColor:"#FFF",position:t}})}return l}function C(t,e){t.styles={unselected:{lineColor:e.meta.color||"darkgrey",lineWidth:1,lineStyle:1},selected:{lineColor:e.meta.color||"darkgrey",lineWidth:3,lineStyle:1}},t.label=e.meta.id||e.id}function P(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{ids:r}=e;if(!t||!t[0])return{};let o=[],n=[],i=[];for(let e of t)r&&!r.includes(e.id)||(i.push(e.id),o.push(e.normalized.y),n.push(e.meta));return{ids:i,matrix:o,meta:n,x:t[0].normalized.x}}function X(t,e,r){let o=r?t.rows:t.rows-1;if(e<0||e>o)throw new RangeError("Row index out of range")}function D(t,e,r){let o=r?t.columns:t.columns-1;if(e<0||e>o)throw new RangeError("Column index out of range")}function V(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function q(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function L(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for row indices");if(e.some(e=>e<0||e>=t.rows))throw new RangeError("row indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function Y(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for column indices");if(e.some(e=>e<0||e>=t.columns))throw new RangeError("column indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function j(t,e,r,o,n){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(_("startRow",e),_("endRow",r),_("startColumn",o),_("endColumn",n),e>r||o>n||e<0||e>=t.rows||r<0||r>=t.rows||o<0||o>=t.columns||n<0||n>=t.columns)throw new RangeError("Submatrix indices are out of range")}function U(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=[];for(let o=0;o<t;o++)r.push(e);return r}function _(t,e){if("number"!=typeof e)throw new TypeError("".concat(t," must be a number"))}const B=15,J=10,Q=8;function W(t){const e=String(t);if(e.length<=Q)return e.padEnd(Q," ");const r=t.toPrecision(Q-2);if(r.length<=Q)return r;const o=t.toExponential(Q-2),n=o.indexOf("e"),i=o.substring(n);return o.substring(0,Q-i.length)+i}class ${static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let o=new G(t,e);for(let n=0;n<t;n++)for(let t=0;t<e;t++)o.set(n,t,r[n*e+t]);return o}static rowVector(t){let e=new G(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new G(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new G(t,e)}static ones(t,e){return new G(t,e).fill(1)}static rand(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("object"!=typeof r)throw new TypeError("options must be an object");const{random:o=Math.random}=r;let n=new G(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)n.set(r,t,o());return n}static randInt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("object"!=typeof r)throw new TypeError("options must be an object");const{min:o=0,max:n=1e3,random:i=Math.random}=r;if(!Number.isInteger(o))throw new TypeError("min must be an integer");if(!Number.isInteger(n))throw new TypeError("max must be an integer");if(o>=n)throw new RangeError("min must be smaller than max");let s=n-o,a=new G(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=o+Math.round(i()*s);a.set(r,t,e)}return a}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let o=Math.min(t,e),n=this.zeros(t,e);for(let t=0;t<o;t++)n.set(t,t,r);return n}static diag(t,e,r){let o=t.length;void 0===e&&(e=o),void 0===r&&(r=e);let n=Math.min(o,e,r),i=this.zeros(e,r);for(let e=0;e<n;e++)i.set(e,e,t[e]);return i}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,o=t.columns,n=new G(r,o);for(let i=0;i<r;i++)for(let r=0;r<o;r++)n.set(i,r,Math.min(t.get(i,r),e.get(i,r)));return n}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,o=t.columns,n=new this(r,o);for(let i=0;i<r;i++)for(let r=0;r<o;r++)n.set(i,r,Math.max(t.get(i,r),e.get(i,r)));return n}static checkMatrix(t){return $.isMatrix(t)?t:new G(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,o=!0,n=!1;for(;t<this.rows&&o;){for(e=0,n=!1;e<this.columns&&!1===n;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(n=!0,r=e):(o=!1,n=!0);t++}return o}isReducedEchelonForm(){let t=0,e=0,r=-1,o=!0,n=!1;for(;t<this.rows&&o;){for(e=0,n=!1;e<this.columns&&!1===n;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(n=!0,r=e):(o=!1,n=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(o=!1);t++}return o}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let o=e;for(let n=e;n<t.rows;n++)t.get(n,r)>t.get(o,r)&&(o=n);if(0===t.get(o,r))r++;else{t.swapRows(e,o);let n=t.get(e,r);for(let o=r;o<t.columns;o++)t.set(e,o,t.get(e,o)/n);for(let o=e+1;o<t.rows;o++){let n=t.get(o,r)/t.get(e,r);t.set(o,r,0);for(let i=r+1;i<t.columns;i++)t.set(o,i,t.get(o,i)-t.get(e,i)*n)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,o=r-1;for(;o>=0;)if(0===t.maxRow(o))o--;else{let n=0,i=!1;for(;n<r&&!1===i;)1===t.get(o,n)?i=!0:n++;for(let r=0;r<o;r++){let i=t.get(r,n);for(let s=n;s<e;s++){let e=t.get(r,s)-i*t.get(o,s);t.set(r,s,e)}}o--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let o=new G(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)o.setSubMatrix(this,this.rows*t,this.columns*e);return o}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){X(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return G.rowVector(this.getRow(t))}setRow(t,e){X(this,t),e=V(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){X(this,t),X(this,e);for(let r=0;r<this.columns;r++){let o=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,o)}return this}getColumn(t){D(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return G.columnVector(this.getColumn(t))}setColumn(t,e){D(this,t),e=q(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){D(this,t),D(this,e);for(let r=0;r<this.rows;r++){let o=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,o)}return this}addRowVector(t){t=V(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=V(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=V(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=V(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=q(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=q(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=q(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=q(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){X(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){D(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)>t&&(t=this.get(r,o),e[0]=r,e[1]=o);return e}min(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let o=0;o<this.columns;o++)this.get(r,o)<t&&(t=this.get(r,o),e[0]=r,e[1]=o);return e}maxRow(t){X(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){X(this,t);let e=this.get(t,0),r=[t,0];for(let o=1;o<this.columns;o++)this.get(t,o)>e&&(e=this.get(t,o),r[1]=o);return r}minRow(t){X(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){X(this,t);let e=this.get(t,0),r=[t,0];for(let o=1;o<this.columns;o++)this.get(t,o)<e&&(e=this.get(t,o),r[1]=o);return r}maxColumn(t){D(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){D(this,t);let e=this.get(0,t),r=[0,t];for(let o=1;o<this.rows;o++)this.get(o,t)>e&&(e=this.get(o,t),r[0]=o);return r}minColumn(t){D(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){D(this,t);let e=this.get(0,t),r=[0,t];for(let o=1;o<this.rows;o++)this.get(o,t)<e&&(e=this.get(o,t),r[0]=o);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"frobenius",e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r)*this.get(t,r);return Math.sqrt(e)}throw new RangeError("unknown norm type: ".concat(t))}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){$.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let o=0;o<e.length;o++)r+=e[o]*t[o];return r}mmul(t){t=G.checkMatrix(t);let e=this.rows,r=this.columns,o=t.columns,n=new G(e,o),i=new Float64Array(r);for(let s=0;s<o;s++){for(let e=0;e<r;e++)i[e]=t.get(e,s);for(let t=0;t<e;t++){let e=0;for(let o=0;o<r;o++)e+=this.get(t,o)*i[o];n.set(t,s,e)}}return n}strassen2x2(t){t=G.checkMatrix(t);let e=new G(2,2);const r=this.get(0,0),o=t.get(0,0),n=this.get(0,1),i=t.get(0,1),s=this.get(1,0),a=t.get(1,0),l=this.get(1,1),h=t.get(1,1),u=(r+l)*(o+h),f=(s+l)*o,c=r*(i-h),m=l*(a-o),p=(r+n)*h,g=u+m-p+(n-l)*(a+h),d=c+p,w=f+m,y=u-f+c+(s-r)*(o+i);return e.set(0,0,g),e.set(0,1,d),e.set(1,0,w),e.set(1,1,y),e}strassen3x3(t){t=G.checkMatrix(t);let e=new G(3,3);const r=this.get(0,0),o=this.get(0,1),n=this.get(0,2),i=this.get(1,0),s=this.get(1,1),a=this.get(1,2),l=this.get(2,0),h=this.get(2,1),u=this.get(2,2),f=t.get(0,0),c=t.get(0,1),m=t.get(0,2),p=t.get(1,0),g=t.get(1,1),d=t.get(1,2),w=t.get(2,0),y=t.get(2,1),x=t.get(2,2),v=(r-i)*(-c+g),b=(-r+i+s)*(f-c+g),M=(i+s)*(-f+c),E=r*f,A=(-r+l+h)*(f-m+d),S=(-r+l)*(m-d),z=(l+h)*(-f+m),R=(-n+h+u)*(g+w-y),N=(n-u)*(g-y),F=n*w,I=(h+u)*(-w+y),O=(-n+s+a)*(d+w-x),T=(n-a)*(d-x),k=(s+a)*(-w+x),C=E+F+o*p,P=(r+o+n-i-s-h-u)*g+b+M+E+R+F+I,X=E+A+z+(r+o+n-s-a-l-h)*d+F+O+k,D=v+s*(-f+c+p-g-d-w+x)+b+E+F+O+T,V=v+b+M+E+a*y,q=F+O+T+k+i*m,L=E+A+S+h*(-f+m+p-g-d-w+y)+R+N+F,Y=R+N+F+I+l*c,j=E+A+S+z+u*x;return e.set(0,0,C),e.set(0,1,P),e.set(0,2,X),e.set(1,0,D),e.set(1,1,V),e.set(1,2,q),e.set(2,0,L),e.set(2,1,Y),e.set(2,2,j),e}mmulStrassen(t){t=G.checkMatrix(t);let e=this.clone(),r=e.rows,o=e.columns,n=t.rows,i=t.columns;function s(t,e,r){let o=t.rows,n=t.columns;if(o===e&&n===r)return t;{let o=$.zeros(e,r);return o=o.setSubMatrix(t,0,0)}}o!==n&&console.warn("Multiplying ".concat(r," x ").concat(o," and ").concat(n," x ").concat(i," matrix: dimensions do not match."));let a=Math.max(r,n),l=Math.max(o,i);return function t(e,r,o,n){if(o<=512||n<=512)return e.mmul(r);o%2==1&&n%2==1?(e=s(e,o+1,n+1),r=s(r,o+1,n+1)):o%2==1?(e=s(e,o+1,n),r=s(r,o+1,n)):n%2==1&&(e=s(e,o,n+1),r=s(r,o,n+1));let i=parseInt(e.rows/2,10),a=parseInt(e.columns/2,10),l=e.subMatrix(0,i-1,0,a-1),h=r.subMatrix(0,i-1,0,a-1),u=e.subMatrix(0,i-1,a,e.columns-1),f=r.subMatrix(0,i-1,a,r.columns-1),c=e.subMatrix(i,e.rows-1,0,a-1),m=r.subMatrix(i,r.rows-1,0,a-1),p=e.subMatrix(i,e.rows-1,a,e.columns-1),g=r.subMatrix(i,r.rows-1,a,r.columns-1),d=t($.add(l,p),$.add(h,g),i,a),w=t($.add(c,p),h,i,a),y=t(l,$.sub(f,g),i,a),x=t(p,$.sub(m,h),i,a),v=t($.add(l,u),g,i,a),b=t($.sub(c,l),$.add(h,f),i,a),M=t($.sub(u,p),$.add(m,g),i,a),E=$.add(d,x);E.sub(v),E.add(M);let A=$.add(y,v),S=$.add(w,x),z=$.sub(d,w);z.add(y),z.add(b);let R=$.zeros(2*E.rows,2*E.columns);return(R=(R=(R=(R=R.setSubMatrix(E,0,0)).setSubMatrix(A,E.rows,0)).setSubMatrix(S,0,E.columns)).setSubMatrix(z,E.rows,E.columns)).subMatrix(0,o-1,0,n-1)}(e=s(e,a,l),t=s(t,a,l),a,l)}scaleRows(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let o=new G(this.rows,this.columns);for(let t=0;t<this.rows;t++){const n=this.getRow(t);d(n,{min:e,max:r,output:n}),o.setRow(t,n)}return o}scaleColumns(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let o=new G(this.rows,this.columns);for(let t=0;t<this.columns;t++){const n=this.getColumn(t);d(n,{min:e,max:r,output:n}),o.setColumn(t,n)}return o}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),o=this.get(e,this.columns-1-r);this.set(e,r,o),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),o=this.get(this.rows-1-r,e);this.set(r,e,o),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=G.checkMatrix(t);let e=this.rows,r=this.columns,o=t.rows,n=t.columns,i=new G(e*o,r*n);for(let s=0;s<e;s++)for(let e=0;e<r;e++)for(let r=0;r<o;r++)for(let a=0;a<n;a++)i.set(o*s+r,n*e+a,this.get(s,e)*t.get(r,a));return i}transpose(){let t=new G(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Z;for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Z;for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,o){j(this,t,e,r,o);let n=new G(e-t+1,o-r+1);for(let i=t;i<=e;i++)for(let e=r;e<=o;e++)n.set(i-t,e-r,this.get(i,e));return n}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let o=new G(t.length,r-e+1);for(let n=0;n<t.length;n++)for(let i=e;i<=r;i++){if(t[n]<0||t[n]>=this.rows)throw new RangeError("Row index out of range: ".concat(t[n]));o.set(n,i-e,this.get(t[n],i))}return o}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let o=new G(r-e+1,t.length);for(let n=0;n<t.length;n++)for(let i=e;i<=r;i++){if(t[n]<0||t[n]>=this.columns)throw new RangeError("Column index out of range: ".concat(t[n]));o.set(i-e,n,this.get(i,t[n]))}return o}setSubMatrix(t,e,r){j(this,e,e+(t=G.checkMatrix(t)).rows-1,r,r+t.columns-1);for(let o=0;o<t.rows;o++)for(let n=0;n<t.columns;n++)this.set(e+o,r+n,t.get(o,n));return this}selection(t,e){let r=function(t,e,r){return{row:L(t,e),column:Y(t,r)}}(this,t,e),o=new G(t.length,e.length);for(let t=0;t<r.row.length;t++){let e=r.row[t];for(let n=0;n<r.column.length;n++){let i=r.column[n];o.set(t,n,this.get(e,i))}}return o}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new G(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return function(t){let e=U(t.rows);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[r]+=t.get(r,o);return e}(this);case"column":return function(t){let e=U(t.columns);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[o]+=t.get(r,o);return e}(this);case void 0:return function(t){let e=0;for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)e+=t.get(r,o);return e}(this);default:throw new Error("invalid option: ".concat(t))}}product(t){switch(t){case"row":return function(t){let e=U(t.rows,1);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[r]*=t.get(r,o);return e}(this);case"column":return function(t){let e=U(t.columns,1);for(let r=0;r<t.rows;++r)for(let o=0;o<t.columns;++o)e[o]*=t.get(r,o);return e}(this);case void 0:return function(t){let e=1;for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)e*=t.get(r,o);return e}(this);default:throw new Error("invalid option: ".concat(t))}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error("invalid option: ".concat(t))}}variance(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:o=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!Array.isArray(o))throw new TypeError("mean must be an array");return function(t,e,r){const o=t.rows,n=t.columns,i=[];for(let s=0;s<o;s++){let o=0,a=0,l=0;for(let e=0;e<n;e++)o+=l=t.get(s,e)-r[s],a+=l*l;e?i.push((a-o*o/n)/(n-1)):i.push((a-o*o/n)/n)}return i}(this,r,o);case"column":if(!Array.isArray(o))throw new TypeError("mean must be an array");return function(t,e,r){const o=t.rows,n=t.columns,i=[];for(let s=0;s<n;s++){let n=0,a=0,l=0;for(let e=0;e<o;e++)n+=l=t.get(e,s)-r[s],a+=l*l;e?i.push((a-n*n/o)/(o-1)):i.push((a-n*n/o)/o)}return i}(this,r,o);case void 0:if("number"!=typeof o)throw new TypeError("mean must be a number");return function(t,e,r){const o=t.rows,n=t.columns,i=o*n;let s=0,a=0,l=0;for(let e=0;e<o;e++)for(let o=0;o<n;o++)s+=l=t.get(e,o)-r,a+=l*l;return e?(a-s*s/i)/(i-1):(a-s*s/i)/i}(this,r,o);default:throw new Error("invalid option: ".concat(t))}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!Array.isArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)-e[r])}(this,r),this;case"column":if(!Array.isArray(r))throw new TypeError("center must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)-e[o])}(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)-e)}(this,r),this;default:throw new Error("invalid option: ".concat(t))}}scale(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.rows;r++){let o=0;for(let e=0;e<t.columns;e++)o+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(o))}return e}(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)/e[r])}(this,r),this;case"column":if(void 0===r)r=function(t){const e=[];for(let r=0;r<t.columns;r++){let o=0;for(let e=0;e<t.rows;e++)o+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(o))}return e}(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)/e[o])}(this,r),this;case void 0:if(void 0===r)r=function(t){const e=t.size-1;let r=0;for(let o=0;o<t.columns;o++)for(let n=0;n<t.rows;n++)r+=Math.pow(t.get(n,o),2)/e;return Math.sqrt(r)}(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return function(t,e){for(let r=0;r<t.rows;r++)for(let o=0;o<t.columns;o++)t.set(r,o,t.get(r,o)/e)}(this,r),this;default:throw new Error("invalid option: ".concat(t))}}}function Z(t,e){return t-e}$.prototype.klass="Matrix","undefined"!=typeof Symbol&&($.prototype[Symbol.for("nodejs.util.inspect.custom")]=function(){const t=" ".repeat(2),e=" ".repeat(4);return"".concat(this.constructor.name," {\n").concat(t,"[\n").concat(e).concat(function(t,e){const{rows:r,columns:o}=t,n=Math.min(r,B),i=Math.min(o,J),s=[];for(let e=0;e<n;e++){let r=[];for(let o=0;o<i;o++)r.push(W(t.get(e,o)));s.push("".concat(r.join(" ")))}i!==o&&(s[s.length-1]+=" ... ".concat(o-J," more columns"));n!==r&&s.push("... ".concat(r-B," more rows"));return s.join("\n".concat(e))}(this,e),"\n").concat(t,"]\n").concat(t,"rows: ").concat(this.rows,"\n").concat(t,"columns: ").concat(this.columns,"\n}")}),$.random=$.rand,$.randomInt=$.randInt,$.diagonal=$.diag,$.prototype.diagonal=$.prototype.diag,$.identity=$.eye,$.prototype.negate=$.prototype.neg,$.prototype.tensorProduct=$.prototype.kroneckerProduct;class G extends ${constructor(t,e){if(super(),G.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>0){if(this.data=[],!(Number.isInteger(e)&&e>0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!Array.isArray(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if(t=r.length,"number"!=typeof(e=r[0].length)||0===e)throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let o=0;o<t;o++){if(r[o].length!==e)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(r[o]))}}}return this.rows=t,this.columns=e,this}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){if(X(this,t),1===this.rows)throw new RangeError("A matrix cannot have less than one row");return this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),X(this,t,!0),e=Float64Array.from(V(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){if(D(this,t),1===this.columns)throw new RangeError("A matrix cannot have less than one column");for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let o=0;o<t;o++)r[o]=this.data[e][o];for(let o=t+1;o<this.columns;o++)r[o-1]=this.data[e][o];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),D(this,t,!0),e=q(this,e);for(let r=0;r<this.rows;r++){const o=new Float64Array(this.columns+1);let n=0;for(;n<t;n++)o[n]=this.data[r][n];for(o[n++]=e[r];n<this.columns+1;n++)o[n]=this.data[r][n-1];this.data[r]=o}return this.columns+=1,this}}function K(t,e){let{from:r,to:o}=e;return void 0===r&&(r=t[0]),void 0===o&&(o=t[t.length-1]),{fromIndex:M.findClosestIndex(t,r),toIndex:M.findClosestIndex(t,o)}}function H(t,e){return t<0?(t=0-t,"- ".concat("number"==typeof e?t.toPrecision(e):t.toString())):"number"==typeof e?t.toPrecision(e):t.toString()}!function(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this}}($,G);class tt{constructor(){if(new.target===tt)throw new Error("BaseRegression must be subclassed")}predict(t){if("number"==typeof t)return this._predict(t);if(Array.isArray(t)){const e=[];for(let r=0;r<t.length;r++)e.push(this._predict(t[r]));return e}throw new TypeError("x must be a number or array")}_predict(){throw new Error("_predict must be implemented")}train(){}toString(){return""}toLaTeX(){return""}score(t,e){if(!Array.isArray(t)||!Array.isArray(e)||t.length!==e.length)throw new Error("x and y must be arrays of the same length");const r=t.length,o=new Array(r);for(let e=0;e<r;e++)o[e]=this._predict(t[e]);let n=0,i=0,s=0,a=0,l=0,h=0,u=0;for(let t=0;t<r;t++)n+=o[t],i+=e[t],l+=o[t]*o[t],h+=e[t]*e[t],u+=o[t]*e[t],0!==e[t]&&(s+=(e[t]-o[t])*(e[t]-o[t])/e[t]),a+=(e[t]-o[t])*(e[t]-o[t]);const f=(r*u-n*i)/Math.sqrt((r*l-n*n)*(r*h-i*i));return{r:f,r2:f*f,chi2:s,rmsd:Math.sqrt(a/r)}}}class et extends tt{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=[e.intercept,e.slope]):(function(t,e){if(!Array.isArray(t)||!Array.isArray(e))throw new TypeError("x and y must be arrays");if(t.length!==e.length)throw new RangeError("x and y arrays must have the same length")}(t,e),function(t,e,r){const o=e.length;let n=0,i=0,s=0,a=0;for(let t=0;t<o;t++)n+=e[t],i+=r[t],s+=e[t]*e[t],a+=e[t]*r[t];const l=o*a-n*i;t.slope=l/(o*s-n*n),t.intercept=1/o*i-t.slope*(1/o)*n,t.coefficients=[t.intercept,t.slope]}(this,t,e))}toJSON(){return{name:"simpleLinearRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){let e="f(x) = ";if(0!==this.slope){const r=H(this.slope,t);if(e+="".concat("1"===r?"":"".concat(r," * "),"x"),0!==this.intercept){const r=Math.abs(this.intercept),o=r===this.intercept?"+":"-";e+=" ".concat(o," ").concat(H(r,t))}}else e+=H(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("simpleLinearRegression"!==t.name)throw new TypeError("not a SLR model");return new et(!0,t)}}function rt(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t.spectra||!t.spectra[0])return{};const{range:r,targetID:o,relative:n,method:i,ids:s}=e;let a,l=t.getSpectrum(o)||t.spectra[0],h=t.getSpectra(s);if(""===i||void 0===i)a=P(h);else{let t;switch(i.toLowerCase()){case"min":t=function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=K(e.normalized.x,r),n=b.minYPoint(e.normalized,o).y,i=t.map(t=>b.minYPoint(t.normalized,o).y),s=[];for(let e=0;e<t.length;e++){let r=t[e],o=n/i[e];s.push(M.multiply(r.normalized.y,o))}return s}(h,l,r);break;case"max":t=function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=K(e.normalized.x,r),n=b.maxYPoint(e.normalized,o).y,i=t.map(t=>b.maxYPoint(t.normalized,o).y),s=[];for(let e=0;e<t.length;e++){let r=t[e],o=n/i[e];s.push(M.multiply(r.normalized.y,o))}return s}(h,l,r);break;case"minmax":t=function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=K(e.normalized.x,r),n={min:b.minYPoint(e.normalized,o).y,max:b.maxYPoint(e.normalized,o).y},i=t.map(t=>({min:b.minYPoint(t.normalized,o).y,max:b.maxYPoint(t.normalized,o).y})),s=[];for(let e=0;e<t.length;e++){let r=t[e];const o=new et([n.min,n.max],[i[e].min,i[e].max]);let a=r.normalized.y.length,l=new Array(a);for(let t=0;t<a;t++)l[t]=o.computeX(r.normalized.y[t]);s.push(l)}return s}(h,l,r);break;case"range":t=function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=K(e.normalized.x,r),n=b.integration(e.normalized,o),i=t.map(t=>b.integration(t.normalized,o)),s=[];for(let e=0;e<t.length;e++){let r=t[e],o=n/i[e];s.push(M.multiply(r.normalized.y,o))}return s}(h,l,r);break;default:throw new Error("getScaledData: unknown method: ".concat(i))}let e=[],o=[];for(let t of h)o.push(t.id),e.push(t.meta);a={ids:o,matrix:t,meta:e,x:h[0].normalized.x}}if(n)for(let t=0;t<a.matrix.length;t++)a.matrix[t]=M.subtract(a.matrix[t],l.normalized.y);return a}class ot{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.normalization=t.normalization,this.maxMemory=t.maxMemory||67108864,this.keepOriginal=!0,this.spectra=[],this.boundaries={minX:Number.MAX_VALUE,maxX:Number.MIN_VALUE,minY:Number.MAX_VALUE,maxY:Number.MIN_VALUE}}getNormalizationAnnotations(){return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1?arguments[1]:void 0,{exclusions:r=[]}=t,o=[];return o=(r=r.filter(t=>!t.ignore)).map(t=>{return{type:"rect",position:[{x:t.from,y:e.y.min},{x:t.to,y:e.y.max}],strokeWidth:0,fillColor:"rgba(255,255,224,1)"}}),void 0!==t.from&&o.push({type:"rect",position:[{x:0,y:e.y.min},{x:t.from,y:e.y.max}],strokeWidth:0,fillColor:"rgba(255,255,224,1)"}),void 0!==t.to&&o.push({type:"rect",position:[{x:t.to,y:e.y.min},{x:1e4,y:e.y.max}],strokeWidth:0,fillColor:"rgba(255,255,224,1)"}),o}(this.normalization,this.getNormalizedBoundary())}setNormalization(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(JSON.stringify(this.normalization)!==JSON.stringify(t)){this.normalization=t;for(let t of this.spectra)t.updateNormalization(this.normalization)}}getNormalization(){return this.normalization}getAutocorrelation(t,e){return function(t,e){let r=t.matrix,o=r.length,n=r[0].length,i=new Float64Array(o),s=new Float64Array(o),a=new Array(n);for(let t=0;t<o;t++)i[t]=r[t][e];for(let t=0;t<n;t++){for(let e=0;e<o;e++)s[e]=r[e][t];a[t]=M.correlation(i,s)}return{x:t.x,y:a}}(this.getNormalizedData(e),t)}getMeanData(t){return function(t){let e=new G(t.matrix);return{x:t.x,y:e.mean("column")}}(this.getNormalizedData(t))}getNormalizedData(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{ids:e}=t;return P(this.getSpectra(e))}getNormalizedText(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{ids:e}=t;return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{fs:r="\t",rs:o="\n"}=e,{matrix:n,meta:i,ids:s,x:a}=P(t),l={};for(let t of i)for(let e of Object.keys(t)){let r=typeof t[e];"number"!==r&&"string"!==r&&"boolean"!==r||(l[e]=!0)}let h=Object.keys(l),u=[],f=[];f.push("id",...h,...a),u.push(f.join(r));for(let t=0;t<s.length;t++){(f=[]).push(s[t]);for(let e of h)f.push(i[t][e]);f.push(...n[t]),u.push(f.join(r))}return u.join(o)}(this.getSpectra(e),t)}getMinMaxX(){let t=Number.MAX_VALUE,e=Number.MIN_VALUE;for(let r of this.spectra)r.minX<t&&(t=r.minX),r.maxX>e&&(e=r.maxX);return{min:t,max:e}}getScaledData(t){return rt(this,t)}addFromText(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!0!==e.force&&e.id&&this.contains(e.id))return;let r=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{kind:r,parserOptions:o={}}=e,n=T(t,o);return r&&r.importation&&r.importation.converter&&(n.y=n.y.map(r.importation.converter)),{data:n}}(t,e),n=o({},r.meta,{},e.meta||{});this.addFromData(r.data,{meta:n,id:e.id})}addFromJcamp(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!0!==e.force&&e.id&&this.contains(e.id))return;let r=O(t),n=o({},r.meta,{},e.meta||{});this.addFromData(r.data,{meta:n,id:e.id})}updateRangesInfo(t){for(let e of this.spectra)e.updateRangesInfo(t)}addFromData(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};0===this.spectra.length&&(this.keepOriginal=!0);const r=e.id||Math.random().toString(36).substring(2,10);let o=this.getSpectrumIndex(r);void 0===o&&(o=this.spectra.length);let n=new E(t.x,t.y,r,{meta:e.meta,normalized:e.normalized,normalization:this.normalization});if(this.spectra[o]=n,this.keepOriginal){this.getMemoryInfo().total>this.maxMemory&&(this.keepOriginal=!1,this.removeOriginals())}else n.removeOriginal()}removeOriginals(){for(let t of this.spectra)t.removeOriginal()}removeSpectrum(t){let e=this.getSpectrumIndex(t);if(void 0!==e)return this.spectra.splice(e,1)}removeSpectraNotIn(t){let e=this.spectra.map(t=>t.id);for(let r of e)t.includes(r)||this.removeSpectrum(r)}contains(t){return!isNaN(this.getSpectrumIndex(t))}getSpectrumIndex(t){if(t)for(let e=0;e<this.spectra.length;e++){if(this.spectra[e].id===t)return e}}getSpectra(t){if(!t||!Array.isArray(t))return this.spectra;let e=[];for(let r of t){let t=this.getSpectrumIndex(r);void 0!==t&&e.push(this.spectra[t])}return e}getSpectrum(t){let e=this.getSpectrumIndex(t);if(void 0!==e)return this.spectra[e]}getChart(){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{ids:r}=e;let o={data:[]};for(let e of t)if(!r||r.includes(e.id)){let t=e.getData();C(t,e),o.data.push(t)}return o}(this.spectra)}getTrackAnnotation(t,e){return function(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{ids:o}=r;let n=[],i=P(t,{ids:o});if(0===i.ids.length)return n;let s=0;n.push({type:"line",position:[{x:"".concat(70,"px"),y:"".concat(15+15*s,"px")},{x:"".concat(85,"px"),y:"".concat(15+15*s,"px")}],strokeWidth:1e-7,label:{size:16,text:"x: ".concat(i.x[e].toPrecision(6)),position:{x:"".concat(130,"px"),y:"".concat(20+15*s,"px")}}}),s++;for(let t=0;t<i.ids.length;t++){let r=i.ids[t],o=i.meta[t],a=i.matrix[t][e];n.push({type:"line",position:[{x:"".concat(70,"px"),y:"".concat(15+15*s,"px")},{x:"".concat(85,"px"),y:"".concat(15+15*s,"px")}],strokeColor:o.color,strokeWidth:2,label:{text:"".concat(a.toPrecision(4)," - ").concat(r),position:{x:"".concat(90,"px"),y:"".concat(20+15*s,"px")}}}),s++}return n}(this.spectra,t,e)}getBoxPlotAnnotations(t){return k(this.spectra,t)}getNormalizedChart(t){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{ids:r}=e;let o={data:[]};for(let e of t)if(!r||r.includes(e.id)){let t=e.normalized;C(t,e),o.data.push(t)}return o}(this.spectra,t)}getScaledChart(t){return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=t.getScaledData(e),o={data:[]};for(let t=0;t<r.matrix.length;t++){let e={x:r.x,y:r.matrix[t]};C(e,{meta:r.meta[t],id:r.ids[t]}),o.data.push(e)}return o}(this,t)}getMemoryInfo(){let t={original:0,normalized:0,total:0};return this.spectra.forEach(e=>{let r=e.memory;t.original+=r.original,t.normalized+=r.normalized,t.total+=r.total}),t.keepOriginal=this.keepOriginal,t.maxMemory=this.maxMemory,t}getNormalizedBoundary(){let t={x:{min:Number.MAX_VALUE,max:Number.MIN_VALUE},y:{min:Number.MAX_VALUE,max:Number.MIN_VALUE}};for(let e of this.spectra)e.normalizedBoundary.x.min<t.x.min&&(t.x.min=e.normalizedBoundary.x.min),e.normalizedBoundary.x.max>t.x.max&&(t.x.max=e.normalizedBoundary.x.max),e.normalizedBoundary.y.min<t.y.min&&(t.y.min=e.normalizedBoundary.y.min),e.normalizedBoundary.y.max>t.y.max&&(t.y.max=e.normalizedBoundary.y.max);return t}static fromNormalizedMatrix(t){let e=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const r=t.split(/[\r\n]+/).filter(t=>t),{fs:o="\t"}=e;let n=[],i=[],s=[],a=[],l=r[0].split(o),h=[];for(let t=0;t<l.length;t++){let e=l[t];if(!isNaN(e)){a=l.slice(t).map(t=>Number(t));break}h[t]=e}for(let t=1;t<r.length;t++){let e=r[t].split("\t");i.push(e[0]);let o={};s.push(o);for(let t=1;t<e.length;t++){if(!(t<h.length)){n.push(e.slice(h.length).map(t=>Number(t)));break}o[h[t]]=e[t]}}return{x:a,meta:s,matrix:n,ids:i}}(t,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{});if(!e)throw new Error("Can not parse TSV file");let r=new ot;r.setNormalization({from:e.x[0],to:e.x[e.x.length-1],numberOfPoints:e.x.length}),r.keepOriginal=!1;for(let t=0;t<e.ids.length;t++)r.addFromData({x:[],y:[]},{normalized:{x:e.x,y:e.matrix[t]},id:e.ids[t],meta:e.meta[t]});return r}}e.SpectraProcessor=ot})),l=(i=a)&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i,h=a.SpectraProcessor;t.SpectraProcessor=h,t.default=l,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=spectra-processor.min.js.map
